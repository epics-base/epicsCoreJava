<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.6.0_18) on Mon Jun 21 14:41:31 EDT 2010 -->
<TITLE>
org.epics.pvData.pv
</TITLE>

<META NAME="date" CONTENT="2010-06-21">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="org.epics.pvData.pv";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Package</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <FONT CLASS="NavBarFont1">Class</FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-use.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../../org/epics/pvData/property/package-summary.html"><B>PREV PACKAGE</B></A>&nbsp;
&nbsp;<A HREF="../../../../org/epics/pvData/pvCopy/package-summary.html"><B>NEXT PACKAGE</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../../index.html?org/epics/pvData/pv/package-summary.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="package-summary.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<H2>
Package org.epics.pvData.pv
</H2>
<h1 style="text-align: center">EPICS PVData: pv<br />
package: org.epics.pvData.pv<br />
2010.06.16
<P>
<B>See:</B>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#package_description"><B>Description</B></A>
<P>

<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Interface Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/epics/pvData/pv/Array.html" title="interface in org.epics.pvData.pv">Array</A></B></TD>
<TD>Base interface for array field reflection.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/epics/pvData/pv/BitSetSerializable.html" title="interface in org.epics.pvData.pv">BitSetSerializable</A></B></TD>
<TD>Base interface for partital serializaion.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/epics/pvData/pv/Convert.html" title="interface in org.epics.pvData.pv">Convert</A></B></TD>
<TD>Convert between numeric types,  convert any field to a string,
  or convert from a string to a scalar field.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/epics/pvData/pv/DeserializableControl.html" title="interface in org.epics.pvData.pv">DeserializableControl</A></B></TD>
<TD>Deserialization control interface.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/epics/pvData/pv/Field.html" title="interface in org.epics.pvData.pv">Field</A></B></TD>
<TD>Interface for field reflection.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/epics/pvData/pv/FieldCreate.html" title="interface in org.epics.pvData.pv">FieldCreate</A></B></TD>
<TD>Interface for creating introspection interfaces.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/epics/pvData/pv/PVArray.html" title="interface in org.epics.pvData.pv">PVArray</A></B></TD>
<TD>Base interface for array data.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/epics/pvData/pv/PVAuxInfo.html" title="interface in org.epics.pvData.pv">PVAuxInfo</A></B></TD>
<TD>Auxiliary information for a field.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/epics/pvData/pv/PVBoolean.html" title="interface in org.epics.pvData.pv">PVBoolean</A></B></TD>
<TD>get/put boolean data</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/epics/pvData/pv/PVBooleanArray.html" title="interface in org.epics.pvData.pv">PVBooleanArray</A></B></TD>
<TD>get/put a boolean array.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/epics/pvData/pv/PVByte.html" title="interface in org.epics.pvData.pv">PVByte</A></B></TD>
<TD>get/put byte data.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/epics/pvData/pv/PVByteArray.html" title="interface in org.epics.pvData.pv">PVByteArray</A></B></TD>
<TD>Get/put a byte array.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/epics/pvData/pv/PVDatabase.html" title="interface in org.epics.pvData.pv">PVDatabase</A></B></TD>
<TD>IOCDB (Input/Output Controller Database).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/epics/pvData/pv/PVDataCreate.html" title="interface in org.epics.pvData.pv">PVDataCreate</A></B></TD>
<TD>Create PVField field implementations.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/epics/pvData/pv/PVDouble.html" title="interface in org.epics.pvData.pv">PVDouble</A></B></TD>
<TD>Get/put double data</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/epics/pvData/pv/PVDoubleArray.html" title="interface in org.epics.pvData.pv">PVDoubleArray</A></B></TD>
<TD>Get/put a double array.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/epics/pvData/pv/PVField.html" title="interface in org.epics.pvData.pv">PVField</A></B></TD>
<TD>PVField is the base class for each PVData field.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/epics/pvData/pv/PVFloat.html" title="interface in org.epics.pvData.pv">PVFloat</A></B></TD>
<TD>Get/put float data.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/epics/pvData/pv/PVFloatArray.html" title="interface in org.epics.pvData.pv">PVFloatArray</A></B></TD>
<TD>Get/put a float array.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/epics/pvData/pv/PVInt.html" title="interface in org.epics.pvData.pv">PVInt</A></B></TD>
<TD>Get/put int data.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/epics/pvData/pv/PVIntArray.html" title="interface in org.epics.pvData.pv">PVIntArray</A></B></TD>
<TD>Get/put a int array.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/epics/pvData/pv/PVListener.html" title="interface in org.epics.pvData.pv">PVListener</A></B></TD>
<TD>DB listener interface.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/epics/pvData/pv/PVLong.html" title="interface in org.epics.pvData.pv">PVLong</A></B></TD>
<TD>Get/put long data.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/epics/pvData/pv/PVLongArray.html" title="interface in org.epics.pvData.pv">PVLongArray</A></B></TD>
<TD>Get/put a long array.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/epics/pvData/pv/PVRecord.html" title="interface in org.epics.pvData.pv">PVRecord</A></B></TD>
<TD>PVRecord interrace.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/epics/pvData/pv/PVRecordClient.html" title="interface in org.epics.pvData.pv">PVRecordClient</A></B></TD>
<TD>PVRecordClient is implemented by any code that attaches to a record.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/epics/pvData/pv/PVRecordField.html" title="interface in org.epics.pvData.pv">PVRecordField</A></B></TD>
<TD>PVRecordField is for PVField that are part of a PVRecord.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/epics/pvData/pv/PVScalar.html" title="interface in org.epics.pvData.pv">PVScalar</A></B></TD>
<TD>PVScalar extends PVField for a scalar field.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/epics/pvData/pv/PVShort.html" title="interface in org.epics.pvData.pv">PVShort</A></B></TD>
<TD>Get/put short data.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/epics/pvData/pv/PVShortArray.html" title="interface in org.epics.pvData.pv">PVShortArray</A></B></TD>
<TD>Get/put a short array.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/epics/pvData/pv/PVString.html" title="interface in org.epics.pvData.pv">PVString</A></B></TD>
<TD>Get/put string data.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/epics/pvData/pv/PVStringArray.html" title="interface in org.epics.pvData.pv">PVStringArray</A></B></TD>
<TD>Get/put a String array.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/epics/pvData/pv/PVStructure.html" title="interface in org.epics.pvData.pv">PVStructure</A></B></TD>
<TD>PVStructure interface.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/epics/pvData/pv/PVStructureArray.html" title="interface in org.epics.pvData.pv">PVStructureArray</A></B></TD>
<TD>Get/put a double array.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/epics/pvData/pv/PVStructureScalar.html" title="interface in org.epics.pvData.pv">PVStructureScalar</A></B></TD>
<TD>PVStructure interface.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/epics/pvData/pv/Requester.html" title="interface in org.epics.pvData.pv">Requester</A></B></TD>
<TD>Base interface for requesters.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/epics/pvData/pv/Scalar.html" title="interface in org.epics.pvData.pv">Scalar</A></B></TD>
<TD>Reflection interface for a scalar field.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/epics/pvData/pv/Serializable.html" title="interface in org.epics.pvData.pv">Serializable</A></B></TD>
<TD>Base interface for serializaion.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/epics/pvData/pv/SerializableArray.html" title="interface in org.epics.pvData.pv">SerializableArray</A></B></TD>
<TD>Base interface for array serializaion.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/epics/pvData/pv/SerializableControl.html" title="interface in org.epics.pvData.pv">SerializableControl</A></B></TD>
<TD>Flush control interface.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/epics/pvData/pv/Status.html" title="interface in org.epics.pvData.pv">Status</A></B></TD>
<TD>Status interface.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/epics/pvData/pv/StatusCreate.html" title="interface in org.epics.pvData.pv">StatusCreate</A></B></TD>
<TD>Interface for creating status.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/epics/pvData/pv/Structure.html" title="interface in org.epics.pvData.pv">Structure</A></B></TD>
<TD>Reflection interface for structure field.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/epics/pvData/pv/StructureArray.html" title="interface in org.epics.pvData.pv">StructureArray</A></B></TD>
<TD>Base interface for array field reflection.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/epics/pvData/pv/StructureScalar.html" title="interface in org.epics.pvData.pv">StructureScalar</A></B></TD>
<TD>Reflection interface for a scalar field.</TD>
</TR>
</TABLE>
&nbsp;

<P>

<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Class Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/epics/pvData/pv/BooleanArrayData.html" title="class in org.epics.pvData.pv">BooleanArrayData</A></B></TD>
<TD>Class required by get/put PVBooleanArray methods.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/epics/pvData/pv/ByteArrayData.html" title="class in org.epics.pvData.pv">ByteArrayData</A></B></TD>
<TD>Class required by get/put PVByteArray methods.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/epics/pvData/pv/DoubleArrayData.html" title="class in org.epics.pvData.pv">DoubleArrayData</A></B></TD>
<TD>Class required by get/put PVDoubleArray methods.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/epics/pvData/pv/FloatArrayData.html" title="class in org.epics.pvData.pv">FloatArrayData</A></B></TD>
<TD>Class required by get/put PVFloatArray methods.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/epics/pvData/pv/IntArrayData.html" title="class in org.epics.pvData.pv">IntArrayData</A></B></TD>
<TD>Class required by get/put PVIntArray methods.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/epics/pvData/pv/LongArrayData.html" title="class in org.epics.pvData.pv">LongArrayData</A></B></TD>
<TD>Class required by get/put PVLongArray methods.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/epics/pvData/pv/ShortArrayData.html" title="class in org.epics.pvData.pv">ShortArrayData</A></B></TD>
<TD>Class required by get/put PVShortArray methods.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/epics/pvData/pv/StringArrayData.html" title="class in org.epics.pvData.pv">StringArrayData</A></B></TD>
<TD>Class required by get/put PVStringArray methods.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/epics/pvData/pv/StructureArrayData.html" title="class in org.epics.pvData.pv">StructureArrayData</A></B></TD>
<TD>Class required by get/put PVDoubleArray methods.</TD>
</TR>
</TABLE>
&nbsp;

<P>

<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Enum Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/epics/pvData/pv/MessageType.html" title="enum in org.epics.pvData.pv">MessageType</A></B></TD>
<TD>Types for messages.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/epics/pvData/pv/ScalarType.html" title="enum in org.epics.pvData.pv">ScalarType</A></B></TD>
<TD>Process Variable Scalar Data Type.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/epics/pvData/pv/Status.StatusType.html" title="enum in org.epics.pvData.pv">Status.StatusType</A></B></TD>
<TD>Status type enum.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/epics/pvData/pv/Type.html" title="enum in org.epics.pvData.pv">Type</A></B></TD>
<TD>Process Variable Data Type.</TD>
</TR>
</TABLE>
&nbsp;

<P>
<A NAME="package_description"><!-- --></A><H2>
Package org.epics.pvData.pv Description
</H2>

<P>
<h1 style="text-align: center">EPICS PVData: pv<br />
package: org.epics.pvData.pv<br />
2010.06.16</h1>
CONTENTS 

<div class="toc">
<ul>
  <li><a href="#Overview">Overview</a></li>
  <li><a href="#Process">Process Variable Reflection</a> 
    <ul>
      <li><a href="#Type">Type</a></li>
      <li><a href="#Serializab">Serializable</a></li>
      <li><a href="#Reflection">Reflection</a></li>
    </ul>
  </li>
  <li><a href="#Status">Status</a></li>
  <li><a href="#PVField">PVField - Data Interfaces</a> 
    <ul>
      <li><a href="#PVField1">PVField</a></li>
      <li><a href="#PVRecordFi">PVRecordField</a></li>
      <li><a href="#Requester">Requester</a></li>
      <li><a href="#PVAuxInfo">PVAuxInfo</a></li>
      <li><a href="#PVListener">PVListener</a></li>
      <li><a href="#PVRecordCl">PVRecordClient</a></li>
      <li><a href="#PVScalar">PVScalar and extensions</a></li>
      <li><a href="#Primitive">Primitive PVField types</a></li>
      <li><a href="#PVString">PVString</a></li>
      <li><a href="#PVStructur">PVStructureScalar</a></li>
      <li><a href="#PVArray">PVArray and Extensions</a> 
        <ul>
          <li><a href="#PVArray1">PVArray</a></li>
          <li><a href="#PVArray2">PVArray Extensions</a></li>
          <li><a href="#Complete">Complete set of PVArray Extensions</a></li>
        </ul>
      </li>
      <li><a href="#PVStructur1">PVStructure</a></li>
      <li><a href="#PVRecord">PVRecord</a> 
        <ul>
          <li><a href="#Record">Record Locking</a></li>
        </ul>
      </li>
      <li><a href="#PVDataCrea">PVDataCreate</a></li>
      <li><a href="#PVDatabase">PVDatabase</a></li>
    </ul>
  </li>
  <li><a href="#Convert">Convert</a></li>
  <li><a href="#Examples">Examples</a> 
    <ul>
      <li><a href="#Accessing">Accessing PVData</a></li>
      <li><a href="#Creating">Creating PVData</a></li>
    </ul>
  </li>
</ul>
</div>
<hr />

<h2 style="text-align: center" id="Overview">Overview</h2>
<hr />

<p>This package has the complete set of enum, interface, and class
definitions that describe PVData. The implementation is provided in package
org.epics.pvData.factory.</p>

<p>A PVDatabase consists of :</p>
<ol>
  <li>A set of structures. Each has a unique name and is implemented as a top
    level PVStructure. The primary use of these structures is as "templates"
    for creating structure fields within a PVRecord.</li>
  <li>A set of record instances. Each has a unique name and is implemented as
    a PVRecord.</li>
</ol>

<p>Each PVRecord has a unique record name and has top level PVStructure,
which is a structured set of PVFields. A PVRecord can be:</p>
<dl>
  <dt>locked</dt>
    <dd>Whenever a record is accessed it can be locked. The JavaIOC requires
      that a record be locked whenever it is accessed.</dd>
  <dt>monitored</dt>
    <dd>Any code can register to be called whenever the data for a field is
      modified. If the code listens for changes to a structure field it is
      notified whenever any scalar or array field in the structure is
      modified. PVField provides a method postPut, which must be called by
      the code that calls the put method of the PVField. Note the caller must
      call postPut because for array fields the array might be written in
      chunks. Only the caller knows when it is done.</dd>
  <dt>a message source</dt>
    <dd>Every PVField has a method message, which can be called by any code
      that has access to the PVField. Code can register to be called whenever
      a message is generated.</dd>
</dl>

<p>A PVStructure is a field that contains an array of subfields. Each field
has code for accessing the field. The interface for each field is PVField or
an interface that extends PVField. Each field also has an introspection
interface, which is Field or an extension of Field. If a PVField is in a
record then it also has an associated PVRecordField. This package overview
describes the complete set of data and introspection interfaces for
pvData.</p>

<p>This package also describes an interface Convert, which provides a rich
set of methods for converting and copying data between field.</p>

<p>The interface FieldCreate creates the introspection interfaces. The
interface PVDataCreate creates the PVField interfaces. Between them they
provide the ability to create every type of Field and PVField, i.e. they
provide a complete implemenation of pvData. It is also possible for other
code to provide implementations.</p>

<p>PVDatabase is an interface that provides access to a named set of top
level PVStructures and to a set of PVRecords. The named top level
PVStructures are mostly used to provide an initial set of fields for a
PVStructure field within a PVRecord.</p>

<p>The rest of this package overview describes all the interfaces provided by
this package. Again this package provides no implementations except for
enums. The implementation for all the interfaces is provided by package
org.epics.pvData.factory.</p>
<hr />

<h2 style="text-align: center" id="Process">Process Variable Reflection</h2>
<hr />

<p>Given a pvname, which consists of a record name and field name, it is
possible to introspect the field without requiring access to data. The
reflection and data interfaces are separate because the data may not be
available. For example when a client connects to a PV, the client library can
obtain the reflection information without obtaining any data. Only when a
client issues an I/O request will data be available. This separation is
especially important for arrays and structures so that a client can discover
the type without requiring that a large array or structure be transported
over the network.</p>

<h3 id="Type">Type</h3>

<p>The types are defined by the Java definitions:</p>
<pre>    enum Type {
        scalar,
        scalarArray,
        structure
    }

    enum ScalarType {
        pvBoolean,
        pvByte, pvShort, pvInt, pvLong,
        pvFloat,pvDouble,
        pvString,
        pvStructure;

        //Convenience methods
        public boolean isInteger();   // pvByte,...,pvLong
        public boolean isNumeric();    // pvByte,...pvDouble
        public boolean isPrimitive();  // pvBoolean,...pvDouble
        public static ScalarType getScalarType(String type);
    }</pre>

<h3 id="Serializab">Serializable</h3>

<p>The following interfaces are called by pvAccess for transporting data over
the network. The abstract and base classes ensure that these methods are
properly implemented. </p>
<pre>    interface Serializable {
        void serialize(ByteBuffer buffer);
        void deserialize(ByteBuffer buffer);
    }

    interface SerializableControl {
        void flushSerializeBuffer();
        void ensureBuffer(int size);
    }

    interface SerializableArray extends Serializable {
        void serialize(ByteBuffer buffer, SerializableControl flusher, int offset, int count);
    }       

    interface BitSetSerializable {
       void serialize(ByteBuffer buffer, SerializableControl flusher, BitSet bitSet);
       void deserialize(ByteBuffer buffer, DeserializableControl control, BitSet bitSet);
    }</pre>

<h3 id="Reflection">Reflection</h3>

<p>This section defines the complete set of Java PV reflection interfaces.</p>
<pre>    
    interface Field {
        String getFieldName();
        Type getType();
        String toString();
        String toString(int indentLevel);
    } 

    interface Scalar extends Field {
        ScalarType getScalarType();
    }
 
    interface StructureScalar extends Scalar{
        Structure getStructure();
    }

    interface Array extends Field{
        ScalarType getElementType();
    }

    interface StructureArray extends Array{
        Structure getStructure();
    }

    interface Structure extends Field{
        String[] getFieldNames();
        Field getField(String fieldName);
        int getFieldIndex(String fieldName);
        Field[] getFields();
    }

    interface FieldCreate {
        Field create(String fieldName,Field field);
        Scalar createScalar(String fieldName,ScalarType scalarType);
        StructureScalar createStructureScalar(String fieldName,Structure structure);
        Array createArray(String fieldName,ScalarType elementType);
        StructureArray createStructureArray(String fieldName,Structure elementStructure);
        Structure createStructure(String fieldName, Field[] field);
    }</pre>

<p>The above definitions support the following:</p>
<dl>
  <dt>Field</dt>
    <dd>A field: 
      <dl>
        <dt>Has a name.</dt>
        <dt>Has a Type.</dt>
        <dt>Can be converted to a string.</dt>
      </dl>
    </dd>
  <dt>Scalar</dt>
    <dd>A scalar has a scalarType</dd>
  <dt>StructureScalar</dt>
    <dd>The field holds a top level structure. A client can only get/put the
      entire structure NOT subfields of the structure. </dd>
  <dt>Array</dt>
    <dd>The element type is a scalarType</dd>
  <dt>StructureArray</dt>
    <dd>The field holds PVStructure[]. Each element has the same Structure
      interspection interface. A client can only get/put entire PVStructure
      elements NOT subfields of array elements.</dd>
  <dt>Structure</dt>
    <dd>Has fields that can be any of the supported types.</dd>
  <dt>FieldCreate</dt>
    <dd>This is an interface that provides methods to create introspection
      interfaces. A factory is provides to create FieldCreate.</dd>
</dl>
<hr />

<h2 style="text-align: center" id="Status">Status</h2>
<hr />

<p>Status provides a way to pass status back to client code. It is new and
not currently used by pvData but may be in the future. It is used by code
that uses pvData.</p>
<pre>    interface Status extends Serializable  {
        public enum StatusType {OK,WARNING,ERROR,FATAL};
        StatusType getType();
        String getMessage();
        String getStackDump();
        boolean isOK();
        boolean isSuccess();
    }
    
    interface StatusCreate {
        Status getStatusOK(); 
        Status createStatus(StatusType type, String message, Throwable cause);
        Status deserializeStatus(ByteBuffer buffer, DeserializableControl control);
    }</pre>

<p>The Status methods are:</p>
<dl>
  <dt>StatusType</dt>
    <dd>An enum for the status type.</dd>
  <dt>getType</dt>
    <dd>Get the statusType.</dd>
  <dt>getMessage</dt>
    <dd>Get a message explaining the error.</dd>
  <dt>getStackDump</dt>
    <dd>Get a stack dump.</dd>
</dl>

<p>The StatusCreate methods are:</p>
<dl>
  <dt>getStatusOK</dt>
    <dd>Get a singleton that returns StatusType.OK and a null message and
      stackDump.</dd>
  <dt>createStatus</dt>
    <dd>Create a new Status.</dd>
  <dt>deserializeStatus</dt>
    <dd>Use this method instead of Status.deserialize(), since this allows OK
      status optimization.</dd>
</dl>
<hr />

<h2 style="text-align: center" id="PVField">PVField - Data Interfaces</h2>
<hr />

<p>This section defines the Java Interfaces for accessing the data within a
PV record.</p>

<h3 id="PVField1">PVField</h3>

<p>PVField is the base interface for accessing data. Every field of every
structure of every record instance has a PVField associated with it. A
structure and a record also has an associated PVField.</p>
<pre>    interface PVField extends Serializable, Requester {
        int getFieldOffset();
        int getNextFieldOffset();
        int getNumberFields();
        PVAuxInfo getPVAuxInfo();
        boolean isImmutable();
        void setImmutable();
        String getFullFieldName();
        String getFullName();
        Field getField();
        PVStructure getParent();
        PVRecordField getPVRecordField();
        void replacePVField(PVField newPVField);
        void renameField(String newName);
        void postPut();
        String toString();
        String toString(int indentLevel);
    }</pre>

<p>where</p>
<dl>
  <dt>Requester</dt>
    <dd>PVField extends Requester which is described in the next
    sub-section.</dd>
  <dt>getFieldOffset</dt>
    <dd>Get offset of the PVField field within top level structure. Every
      field within the PVStructure has a unique offset. The top level
      structure has an offset of 0. The first field within the structure has
      offset equal to 1. The other offsets are determined by recursively
      traversing each structure of the tree. </dd>
  <dt>getNextFieldOffset</dt>
    <dd>Get the next offset. If the field is a scalar or array field then
      this is just offset + 1. If the field is a structure it is the offset
      of the next field after this structure. Thus (nextOffset - offset) is
      always equal to the total number of fields within the field. </dd>
  <dt>getNumberFields</dt>
    <dd>Get the total number of fields in this field. This is nextFieldOffset
      - fieldOffset. </dd>
  <dt>getPVAuxInfo</dt>
    <dd>Get the PVAuxInfo for this field. PVAuxInfo is described below.</dd>
  <dt>isImmutable</dt>
    <dd>Is the field immutable?</dd>
  <dt>setImmutable</dt>
    <dd>Make the field immutable. Once a field is immutable it can never be
      changed since there is no method to again make it mutable. This is an
      important design decision since it allows immutable array fields to
      share the internal primitive data array.</dd>
  <dt>getFullFieldName</dt>
    <dd>Get the full field name. This returns a name in the form "name.name
      ...". </dd>
  <dt>getFullName</dt>
    <dd>Get the full name. This returns a name in the form "recordName.name
      ...". If the fields is not part of a record it is the same as
      getFullFieldName.</dd>
  <dt>getField</dt>
    <dd>Get the reflection interface for the data.</dd>
  <dt>getParent</dt>
    <dd>Get the interface for the parent or null if this is the top level
      PVStructure.</dd>
  <dt>getPVRecordField</dt>
    <dd>Get the PVRecordField interface for field. This is null if this field
      is not part of a record.</dd>
  <dt>replacePVField</dt>
    <dd>Replace this PVField. This is called by support code that wants to
      replace the default implementation of a data field with it's own
      implementation.</dd>
  <dt>renameField</dt>
    <dd>Rename the field name.</dd>
  <dt>postPut</dt>
    <dd>If this field is a field of a record pvRecordField.postPut() is
      called. If not a field of a record nothing happens.</dd>
  <dt>toString</dt>
    <dd>Converts the field data to a string. This is mostly for debugging
      purposes.</dd>
</dl>

<h3 id="PVRecordFi">PVRecordField</h3>

<p>For each field within a PVRecord the PVField has an associated
PVRecordField:</p>
<pre>    interface PVRecordField{
        PVRecord getPVRecord();
        boolean addListener(PVListener pvListener);
        void removeListener(PVListener pvListener);
        void postPut();
    }</pre>

<p>where</p>
<dl>
  <dt>getPVRecord</dt>
    <dd>Returns the PVRecord to which this field belongs.</dd>
  <dt>addListener</dt>
    <dd>Add A PVListener to this field. Whenever this field or any subfield
      if this field is modified the listener will be notified. PVListener is
      described below. Before a listener can call addListener it must first
      call PVRecord.registerListener. </dd>
  <dt>removeListener</dt>
    <dd>Remove a PVListener.</dd>
  <dt>postPut</dt>
    <dd>This is called by the code that implements the data interface. It is
      called whenever the put method is called.</dd>
</dl>

<h3 id="Requester">Requester</h3>

<p>A PVField extends Requester. Requester is present so that when database
errors are found there is someplace to send a message. As will be seen below,
PVRecord provides methods to register message requesters. Also a PVDatabase
provides an identical method. Thus when a message is generated for a field it
is propagated up to the record with the full field name attached and then
propagated to the PVDatabase which sends the messages to the registered
requesters.</p>
<pre>    enum MessageType {info,warning,error,fatalError}

    interface Requester {
        String getRequesterName();
        void message(String message, MessageType messageType);
    }</pre>

<p>where</p>
<dl>
  <dt></dt>
  <dt>MessageType</dt>
    <dd>Type of message.</dd>
  <dt>Requester</dt>
    <dd>The default implementation is: 
      <ul>
        <li>getRequesterName<br />
          This is the full field name concatenated to the record name.</li>
        <li>message<br />
          For the default implementation, PVField prepends the full field
          name to the message and calls PVRecord.message. The default
          implementation for PVRecord either displays the message on stdout
          or stderr or gives the message to message requsters.</li>
      </ul>
    </dd>
</dl>

<h3 id="PVAuxInfo">PVAuxInfo</h3>

<p>AuxInfo (Auxillary Information) is information about a field that is
application specific. It will not be available outside the application that
implements the database. In particular it will not be made available to
Channel Access. It is used by the database itself to override the default
implementation of fields. The JavaIOC uses it for attaching support code.
Database Configuration and other tools can use it for configuration
information. Each Field and each PVField can have have an arbitrary number of
auxInfos. An auxInfo is a (key,PVScalar) pair where key is a string.</p>
<pre>    public interface PVAuxInfo {
        PVField getPVField();
        PVScalar createInfo(String key,ScalarType scalarType);
        Map&lt;String,PVScalar&gt; getInfos();
        PVScalar getInfo(String key);
        String toString();
        String toString(int indentLevel);
    }</pre>

<p>where</p>
<dl>
  <dt>getPVField</dt>
    <dd>Get the PVField to which this PVAuxInfo is attached.</dd>
  <dt>createInfo</dt>
    <dd>Create a new PVScalar of type scalarType.</dd>
  <dt>getInfos</dt>
    <dd>Get a map of all the auxInfos.</dd>
  <dt>getInfo</dt>
    <dd>Get the PVScalar with the specified key.</dd>
  <dt>toString</dt>
    <dd>Print all the auxInfos</dd>
</dl>

<h3 id="PVListener">PVListener</h3>

<p>A PVlistener can attach itself to any field or fields of a record. It will
be notified whenever a put is issued to the field, i.e. the field is
modified. If the field is a structure then the PVListener is notified
whenever that field or any subfield is modified. Please note that
PVStructureScalar and PVStructureArray fields are treated as leaf fields so
that the underlying fields can not have attached listeners.</p>
<pre>    public interface PVListener {
        void dataPut(PVField pvField);
        void dataPut(PVStructure requested,PVField pvField);
        void beginGroupPut(PVRecord pvRecord);
        void endGroupPut(PVRecord pvRecord);
        void unlisten(PVRecord pvRecord);
    }</pre>

<p>where</p>
<dl>
  <dt>dataPut(PVField pvField)</dt>
    <dd>pvField has been modified. This is called if the listener has called
      PVRecordField.addListener for pvField.</dd>
  <dt>dataPut(PVStructure requested,PVField pvField)</dt>
    <dd>pvField has been modified. Requested is the field to which the
      requester issued a pvField.addListener. This is called if the listener
      has called PVRecordField.addListener for requested.</dd>
  <dt>beginGroup</dt>
    <dd>A related set of changes is being started.</dd>
  <dt>endGroup</dt>
    <dd>A related set of changes is done.</dd>
  <dt>unlisten</dt>
    <dd>The PVLister is being removed from the record. This is called when
      the record is being destroyed or when the record structure (not the
      data values) is being changed.</dd>
</dl>

<h3 id="PVRecordCl">PVRecordClient</h3>

<p>Any client that accesses a PVRecord must call registerClient so that the
client can be notified when the record is being removed from the master
database. The client must imnplement the following interface:</p>
<pre>    public interface PVRecordClient {
        void detach(PVRecord pvRecord);
    }</pre>

<h3 id="PVScalar">PVScalar and extensions</h3>
<pre>    interface PVScalar extends PVField {
        Scalar getScalar();
    }</pre>

<h3 id="Primitive">Primitive PVField types</h3>

<p>The interfaces for primitive data types are:</p>
<pre>    interface PVBoolean extends PVScalar {
        boolean get();
        void put(boolean value);
    }

    interface PVByte extends PVScalar {
        byte get();
        void put(byte value);
    }

    interface PVShort extends PVScalar {
        short get();
        void put(short value);
    }

    interface PVInt extends PVScalar {
        int get();
        void put(int value);
    }

    interface PVLong extends PVScalar {
        long get();
        void put(long value);
    }

    interface PVFloat extends PVScalar {
        float get();
        void put(float value);
    }

    interface PVDouble extends PVScalar {
        double get();
        void put(double value);
    }</pre>

<h3 id="PVString">PVString</h3>

<p>The interface for string is:</p>
<pre>    interface PVString extends PVScalar {
        String get();
        void put(String value);
    }</pre>

<h3 id="PVStructur">PVStructureScalar</h3>

<p>The interface for a structure scalars:</p>
<pre>    interface PVStructureScalar extends PVScalar{
        StructureScalar getStructureScalar();
        PVStructure getPVStructure();
        void put();
    }</pre>

<p>A<span style="font-family: courier">PVStructureScalar</span> is treated as
a single field. The method PVStructureScalar.getNumberFields() returns 1, i.
e. the field is a leaf. The methods are:</p>
<dl>
  <dt>getStructureScalar</dt>
    <dd>A client can only access the the underlying PVStructure via the
      structure returned by getPVStructure. It is not possible to attach
      listeners to the underlying PVStructure.</dd>
  <dt>put</dt>
    <dd>If a client modifies the structure than this must be called. </dd>
</dl>

<h3 id="PVArray">PVArray and Extensions</h3>

<h4 id="PVArray1">PVArray</h4>

<p><span style="font-family: courier">PVArray</span> is the base interface
for all the other PV Array interfaces. It extends PVField and provides the
additional methods:</p>
<pre>    interface PVArray extends PVField, SerializableArray {
        Array getArray();
        int getLength();
        void setLength(int len);
        int getCapacity();
        void setCapacity(int len);
        boolean isCapacityMutable();
        void setCapacityMutable(boolean isMutable);
    }</pre>
<dl>
  <dt>getArray</dt>
    <dd>Return the Array introspection interface.</dd>
  <dt>getLength</dt>
    <dd>Get the current length. This is less that or equal to the
    capacity.</dd>
  <dt>setLength</dt>
    <dd>Set the length. If the PVField is not mutable then an exception is
      thrown. If this is greater than the capacity setCapacity is called.</dd>
  <dt>getCapacity</dt>
    <dd>Get the capacity, i.e. this is the sized of the underlying data
    array.</dd>
  <dt>setCapacity</dt>
    <dd>Set the capacity. The semantics are implementation dependent but
      typical semantics are as follows: If the capacity is not mutable an
      exception is thrown. A new data array is created and data is copied
      from the old array to the new array. </dd>
  <dt>isCapacityMutable</dt>
    <dd>Is the capacity mutable</dd>
  <dt>setCapacityMutable</dt>
    <dd>Specify if the capacity can be changed.</dd>
</dl>

<h4 id="PVArray2">PVArray Extensions</h4>

<p>The interface for each array type has get and put methods which have the
same arguments except for the data type. For example PVDoubleArray is:</p>
<pre>    public class DoubleArrayData {
        public double[] data;
        public int offset;
    }
    interface PVDoubleArray extends PVArray {
        int get(int offset, int len, DoubleArrayData data);
        int put(int offset, int len, double[]from, int fromOffset);
        void shareData(double[] from);
    }</pre>

<p>Get "exposes" it's internal array by setting data.data and data.offset.
The caller is responsible for copying the array elements. This violates the
principle that objects should not expose their internal data but is done for
efficency. For example it makes it possible to copy between arrays with
identical element types via a call to System.arraycopy without requiring an
intermediate array.</p>

<p>Both get and put return the number of elements actually transfered. The
arguments are:</p>
<dl>
  <dt>offset</dt>
    <dd>The offset in the PV array.</dd>
  <dt>len</dt>
    <dd>The maximum number of elements to transfer. The number actually
      transfered will be less than or equal to this value.</dd>
  <dt>data</dt>
    <dd>Get sets data.data to it's internal array and data.offset to the
      offset into the array. The caller is responsible for the actual data
      transfer.</dd>
  <dt>from</dt>
    <dd>The array from which the data is taken. This array is supplied by the
      caller</dd>
  <dt>fromOffset</dt>
    <dd>The offset in <span style="font-family: courier;">from</span></dd>
</dl>

<p>The caller must be prepared to make multiple calls to retrieve or put an
entire array. A caller should accept or put partial arrays. For example the
following reads an entire array:</p>
<pre>    double[] getArray(PVDoubleArray pv)
    {
        int len = pv.getLength();
        double[] storage = new double[len];
        DoubleArrayData data = new DoubleArrayData();
        int offset = 0;
        while(offset &lt; len) {
            int num = pv.get(offset,(len-offset),data);
            System.arraycopy(data.data,data.offset,storage,offset,num);
            offset += num;
        }
        return storage;
    } </pre>

<p>shareData results in the PVArray using the primitive array that is passed
to this method. This is most useful for immutable arrays. In this case the
caller must set the PVArray to be immutable. In the PVArray is not immutable
then it is the applications responsibility to coordinate access to the array.
Again this violates the principle that objects should not expose their
internal data but is important for immutable arrays. For example pvData and
the javaIOC define many enumerated structures where an enumerated structure
has three fields: index, choice, and choices. Choices is a PVStringArray that
holds the enumerated choices. Index is a PVInt that is the index of the
currently selected choice and choice is a PVString which is the currently
selected choice. For many enumerated structures the choices is immutable.
Allowing the choices internal String[] to be shared between all the instances
of an enumerated structure saves on storage. An example is alarmSeverity.
Another reason for allowing shared data is so that an application which
processes an array can be separated into multiple modules that directly
access the internal data array of a PVArray. This can be required for
minimizing CPU overhead. In this case it is the applications responsibility
to coordinate access to the array.</p>

<h4 id="Complete">Complete set of PVArray Extensions</h4>
<pre>    public class BooleanArrayData {
        public boolean[] data;
        public int offset;
    }
    interface PVBooleanArray extends PVArray {
        int get(int offset, int len, BooleanArrayData data);
        int put(int offset, int len, boolean[]from, int fromOffset);
        void shareData(boolean[] from);
    }

    public class ByteArrayData {
        public byte[] data;
        public int offset;
    }
    interface PVByteArray extends PVArray {
        int get(int offset, int len, ByteArrayData data);
        int put(int offset, int len, byte[]from, int fromOffset);
        void shareData(byte[] from);
    }

    public class ShortArrayData {
        public short[] data;
        public int offset;
    }
    interface PVShortArray extends PVArray {
        int get(int offset, int len, ShortArrayData data);
        int put(int offset, int len, short[]from, int fromOffset);
        void shareData(short[] from);
    }

    public class IntArrayData {
        public int[] data;
        public int offset;
    }
    interface PVIntArray extends PVArray {
        int get(int offset, int len, IntArrayData data);
        int put(int offset, int len, int[]from, int fromOffset);
        void shareData(int[] from);
    }

    public class LongArrayData {
        public long[] data;
        public int offset;
    }
    interface PVLongArray extends PVArray {
        int get(int offset, int len, LongArrayData data);
        int put(int offset, int len, long[]from, int fromOffset);
        void shareData(long[] from);
    }

    public class FloatArrayData {
        public float[] data;
        public int offset;
    }
    interface PVFloatArray extends PVArray {
        int get(int offset, int len, FloatArrayData data);
        int put(int offset, int len, float[]from, int fromOffset);
        void shareData(float[] from);
    }

    public class DoubleArrayData {
        public double[] data;
        public int offset;
    }
    interface PVDoubleArray extends PVArray {
        int get(int offset, int len, DoubleArrayData data);
        int put(int offset, int len, double[]from, int fromOffset);
        void shareData(double[] from);
    }

    public class StringArrayData {
        public String[] data;
        public int offset;
    }
    interface PVStringArray extends PVArray {
        int get(int offset, int len, StringArrayData data);
        int put(int offset, int len, String[]from, int fromOffset);
        void shareData(String[] from);
    }

    public class StructureArrayData {
        public PVStructure[] data;
        public int offset;
    }

    interface PVStructureArray extends PVArray {
        StructureArray getStructureArray();
        int get(int offset, int length, StructureArrayData data);
        int put(int offset,int length, PVStructure[] from, int fromOffset);
        void shareData(PVStructure[] from);
    }</pre>

<p>Notes about PVStructureArray: A client can only access the data in the
elements of the array via the get and put methods, i.e. it is not possible to
access subfields indirectly. PVStructureArray.getNumberFields() returns 1,
i.e. the field looks like a leaf field.</p>

<h3 id="PVStructur1">PVStructure</h3>

<p>The interface for a structure is:</p>
<pre>    interface PVStructure extends PVField, BitSetSerializable {
        Structure getStructure();
        PVField[] getPVFields();
        PVField getSubField(String fieldName);
        PVField getSubField(int fieldOffset);
        void appendPVField(PVField pvField);
        void appendPVFields(PVField[] pvFields);
        void removePVField(String fieldName);
        // the following are convenience methods
        PVBoolean getBooleanField(String fieldName);
        PVByte getByteField(String fieldName);
        PVShort getShortField(String fieldName);
        PVInt getIntField(String fieldName);
        PVLong getLongField(String fieldName);
        PVFloat getFloatField(String fieldName);
        PVDouble getDoubleField(String fieldName);
        PVString getStringField(String fieldName);
        PVStructureScalar getStructureScalarField(String fieldName);
        PVArray getArrayField(String fieldName,Type elementType);
        PVStructureArray getStructureArrayField(String fieldName);
        PVStructure getStructureField(String fieldName,String structureName);
        String getExtendsStructureName();
        boolean putExtendsStructureName(String extendsStructureName);
    }</pre>

<p>where</p>
<dl>
  <dt>getStructure</dt>
    <dd>Get the introspection interface for the structure.</dd>
  <dt>getPVFields</dt>
    <dd>Returns the array of subfields. The set of subfields must all have
      different field names.</dd>
  <dt>getSubField(String fieldName)</dt>
    <dd>Get a subField of a field. For a PVStructure a non-null result is
      returned if fieldName is a field of the PVStructure. The fieldName can
      be of the form name.name...</dd>
  <dt>getSubField(int fieldOffset)</dt>
    <dd>Get the field located a fieldOffset, where fieldOffset is relative to
      the top level structure. This returns null if the specified field is
      not located within this PVStructure.</dd>
  <dt>appendPVField</dt>
    <dd>Append pvField to the end of this PVStructure. This should NOT be
      called if any code is attached to any of the fields in the top level
      structure.</dd>
  <dt>appendPVFields</dt>
    <dd>Append an array of pvFields to the end of this structure. Note that
      if the original number of fields is 0 than pvFields replaces the
      original. Thus the caller must NOT reuse pvFields after calling this
      method. This should NOT be called if any code is attached to any of the
      fields in the top level structure</dd>
  <dt>removePVField</dt>
    <dd>Remove the specified field from this structure. This should NOT be
      called if any code is attached to any of the fields in the top level
      structure.</dd>
  <dt>getBooleanField</dt>
    <dd>Look for fieldName. If found and it has the correct type return the
      interface. This and the following methods are convenience methods that
      allow a user to get the interface to a subfield without requiring
      introspection. fieldName can be of the form name.name...</dd>
  <dt>getByteField</dt>
    <dd>Look for fieldName. If found and it has the correct type return the
      interface.</dd>
  <dt>getShortField</dt>
    <dd>Look for fieldName. If found and it has the correct type return the
      interface.</dd>
  <dt>getIntField</dt>
    <dd>Look for fieldName. If found and it has the correct type return the
      interface.</dd>
  <dt>getLongField</dt>
    <dd>Look for fieldName. If found and it has the correct type return the
      interface.</dd>
  <dt>getFloatField</dt>
    <dd>Look for fieldName. If found and it has the correct type return the
      interface.</dd>
  <dt>getDoubleField</dt>
    <dd>Look for fieldName. If found and it has the correct type return the
      interface.</dd>
  <dt>getStringField</dt>
    <dd>Look for fieldName. If found and it has the correct type return the
      interface.</dd>
  <dt>getStructureScalarField</dt>
    <dd>Look for fieldName. If found and it has the correct type return the
      interface.</dd>
  <dt>getArrayField</dt>
    <dd>Look for fieldName. If found and it has the correct type return the
      interface.</dd>
  <dt>getStructureArrayField</dt>
    <dd>Look for fieldName. If found and it has the correct type return the
      interface.</dd>
  <dt>getStructureField</dt>
    <dd>Look for fieldName. If found and it has the correct type return the
      interface.</dd>
</dl>

<h3 id="PVRecord">PVRecord</h3>

<p>A PVRecord has a top level PVStructure that provides the following
methods:</p>
<pre>    interface PVRecord {
        PVStructure getPVStructure();
        String getRecordName();
        void message(String message, MessageType messageType);
        void addRequester(Requester requester);
        void removeRequester(Requester requester);
        void lock();
        void unlock();
        void lockOtherRecord(PVRecord otherRecord);
        void beginGroupPut();
        void endGroupPut();
        void registerListener(PVListener pvListener);
        void unregisterListener(PVListener pvListener);
        boolean isRegisteredListener(PVListener pvListener);
        void removeEveryListener();
        void registerClient(PVRecordClient pvRecordClient);
        void unregisterClient(PVRecordClient pvRecordClient);
        void detachClients();
        int getNumberClients();
    }</pre>

<p>where</p>
<dl>
  <dt>getPVStructure</dt>
    <dd>Get the top level PVStructure for the record.</dd>
  <dt>getRecordName</dt>
    <dd>Returns the record name.</dd>
  <dt>message</dt>
    <dd>This is called by AbstractPVField if it has a RecordField. It can be
      called by other code but most code will not need it.</dd>
  <dt>addRequester</dt>
    <dd>Add a requester to receive messages.</dd>
  <dt>removeRequester</dt>
    <dd>Remove a message requester</dd>
  <dt>lock</dt>
    <dd>Lock the record. See next sub-section.</dd>
  <dt>unlock</dt>
    <dd>Unlock the record.</dd>
  <dt>lockOtherRecord</dt>
    <dd>While code has a record locked, It can also lock another record. If
      the other record is already locked than this record may be temporily
      unlocked and then relocked. The caller must call the unlock merthod of
      the other record when done with it. The implementation prevents
      deadlocks BUT code must not try to lock more than two records at the
      same time or deadlocks can occur.</dd>
  <dt>beginGroupPut</dt>
    <dd>Begin a group of puts. This results in all registered PVListeners
      being called.</dd>
  <dt>endGroupPut</dt>
    <dd>End a group of puts. This results in all registered PVListeners being
      called.</dd>
  <dt>registerListener</dt>
    <dd>Register a PVListener. This must be called before calling
      pvField.addListener.</dd>
  <dt>unregisterListener</dt>
    <dd>Unregister a listener. The listener will also be removed from all
      fields to which it is attached.</dd>
  <dt>isRegisteredListener</dt>
    <dd>Id the PVListener registered?</dd>
  <dt>removeEveryListener</dt>
    <dd>This must be called by any code that is deleting or changing the
      structure of a record.</dd>
  <dt>registerClient</dt>
    <dd>Every client that accesses the record must call this so that the
      client can be notified when the record is deleted.</dd>
  <dt>unregisterClient</dt>
    <dd>Client is no longer accessing the record.</dd>
  <dt>detachClients</dt>
    <dd>All client are asked to detach from the record.</dd>
  <dt>getNumberClients</dt>
    <dd>Get the number of registered clients.</dd>
</dl>

<h4 id="Record">Record Locking</h4>

<p>Whever code access a record it must be locked. The code for accessing a
record should use the following pattern:</p>
<pre>    pvRecord.lock();
    try {
       // access the record
    } finally {
        pvRecord.unlock();
    }</pre>

<p>Depending on the application, for example the JavaIOC, it may be required
that the thread does not block between lock and unlock.</p>

<h3 id="PVDataCrea">PVDataCreate</h3>

<p>PVDataCreate is an interface that provides methods that create PVField
interfaces. A factory is provided that creates PVDataCreate.</p>
<pre>interface PVDataCreate {
    PVField createPVField(PVStructure parent, Field field);
    PVField createPVField(PVStructure parent,String fieldName,PVField fieldToClone);
    PVScalar createPVScalar(PVStructure parent,Scalar scalar);
    PVScalar createPVScalar(PVStructure parent,String fieldName,ScalarType fieldType);
    PVScalar createPVScalar(PVStructure parent,String fieldName,PVScalar scalarToClone);
    PVStructureScalar createPVStructureScalar(PVStructure parent,StructureScalar structureScalar);
    PVStructureScalar createPVStructureScalar(PVStructure parent,String fieldName,PVStructure structureToClone);
    PVArray createPVArray(PVStructure parent,Array array);
    PVArray createPVArray(PVStructure parent,String fieldName,ScalarType elementType);
    PVArray createPVArray(PVStructure parent,String fieldName,PVArray arrayToClone);
    PVStructureArray createPVStructureArray(PVStructure parent,StructureArray structureArray);
    PVStructure createPVStructure(PVStructure parent,
        Structure structure);
    PVStructure createPVStructure(PVStructure parent,String fieldName,
        Field[] fields);
    PVStructure createPVStructure(PVStructure parent,String fieldName,
        PVStructure structToClone);
    PVStructure createPVStructure(PVStructure parent,String fieldName,
        PVDatabase pvDatabase,String structureName);
    PVRecord createPVRecord(String recordName,PVStructure pvStructure);
    PVField[] flattenPVStructure(PVStructure pvStructure);
}</pre>
where 
<dl>
  <dt style="font-family: courier;">createPVField</dt>
    <dd>The PVField is created reusing the Field interface. Two methods are
      provided. Each calls the corresponding createPVScalar, createPVArray,
      or createPVStructure depending in the type os the last argument.</dd>
  <dt style="font-family: courier;">createPVScalar</dt>
    <dd>Creates an instance of a PVScalar. Three versions are supplied. The
      first is passed an introspection interface. The second provides the
      field name and the scalarType. The last provides a field name and a
      PVScalar to clone. The newly created PVScalar will have the same
      auxInfos as the original.</dd>
  <dt style="font-family: courier;">createPVStructureScalar</dt>
    <dd>Creates an instance of a PVStructureScalar. Two versions are
      provided. The first is passed a structureScalar interface. The other
      provides a PVStructure from which a structureScalar is created. This
      second form also copies the data after the internal PVStructure is
      created.</dd>
  <dt style="font-family: courier;">createPVArray</dt>
    <dd>Create an instance of a PVArray. Three versions are supplied. The
      first is passed an introspection interface. The second provides the
      field name and the elementType. The last provides a field name and a
      PVArray to clone. The newly created PVArray will have the same auxInfos
      as the original.</dd>
  <dt style="font-family: courier;">createPVStructureArray</dt>
    <dd>Create a PVStructureArray. It must be passed a structureToClone. This
      will become the Structure interface for ALL elements of the
      PVStructureArray. It MUST be used to create any new array elements.</dd>
  <dt style="font-family: courier;">createPVStructure</dt>
    <dd>Create an instance of a PVStructure. Four methods are provided. The
      first method uses a previously created structure introspection
      interface. The second uses a Field array to initialize the sub-fields.
      The third initializes the subfields by cloning the fields contained in
      structToClone. The newly created sub-fields will have the same values
      and auxInfos as the original. If structToClone is null then the new
      structure is initialized to have 0 sub-fields. The last method clones
      the fields from a PVStructure obtained from a PVDatabase. </dd>
  <dt style="font-family: courier;">createPVRecord</dt>
    <dd>Create a record instance. pvStructure is the top level structure of
      the record.</dd>
  <dt style="font-family: courier;">flattenPVStructure</dt>
    <dd>Create an array of PVFields for the fields in the PVStructure. The
      order is according to fieldOffset.</dd>
</dl>

<h3 id="PVDatabase">PVDatabase</h3>

<p>PVDatabase is an interface for accessing a PVData database. </p>

<p>A PVDatabase contains structures and records. Structures provided an easy
way to create an initial set of subfields of a structure field of record
instances or other structures. When a structure field of a record is defined
as follows:</p>
<pre>    &lt;record name = ... /&gt;
        &lt;!-- other fields --&gt;
        &lt;structure name = "name" extends = "structName" /&gt;
        &lt;!-- ... --&gt;
    &lt;/record&gt;</pre>

<p>Then the fields in the structure are initialized with a copy of the fields
in structure "structName". </p>

<p>The interface is:</p>
<pre>    interface PVDatabase extends Requester{
        PVDatabase getMaster();
        String getName();
        void mergeIntoMaster();
        PVRecord findRecord(String name);
        boolean addRecord(PVRecord pvRecord);
        boolean removeRecord(PVRecord pvRecord);
        String[] getRecordNames();
        PVRecord[] getRecords();
        PVStructure findStructure(String name);
        boolean addStructure(PVStructure pvStructure);
        boolean removeStructure(PVStructure pvStructure);
        String[] getStructureNames();
        PVStructure getStructures();
        void message(String message, MessageType messageType);
        void addRequester(Requester requester);
        void removeRequester(Requester requester);
        String[] recordList(String regularExpression);
        String[] structureList(String regularExpression);
        String recordToString(String regularExpression);
        String structureToString(String regularExpression);
    }</pre>

<p>where</p>
<dl>
  <dt>getMaster</dt>
    <dd>Get the master database. This is just a convenience mthhod.</dd>
  <dt>getName</dt>
    <dd>Get the name of the database.</dd>
  <dt>mergeIntoMaster</dt>
    <dd>Merge this database into the master database.</dd>
  <dt>findRecord</dt>
    <dd>Find a record. Null is returned if the record is not in the
    database.</dd>
  <dt>addRecord</dt>
    <dd>Add a record to the database. If the record already exists it is not
      modified and false is returned.</dd>
  <dt>removeRecord</dt>
    <dd>Remove a record from the database. If the record was not in the
      database false is returned.</dd>
  <dt>getRecordNames</dt>
    <dd>Get an array of the record names.</dd>
  <dt>getRecords</dt>
    <dd>Get a array of all the records.</dd>
  <dt>findStructure</dt>
    <dd>Find a structure. Null is returned if the structure is not in the
      database.</dd>
  <dt>addStructure</dt>
    <dd>Add a structure to the database. If it already exists false is
      returned.</dd>
  <dt>removeStructure</dt>
    <dd>Remove a structure from the database. If it did not exist false is
      returned.</dd>
  <dt>getStructureNames</dt>
    <dd>Get an array of the structure names.</dd>
  <dt>getStructures</dt>
    <dd>Get a array of all the structures.</dd>
  <dt>message</dt>
    <dd>Report a message. If no listeners are registered the messages are
      sent to System.out (info) or System.err (all other message types). If
      at least one requester is present then the messages are given to the
      requesters without writing to System.out or System.err. If the database
      is the master, the message is put of a queue that is emptied by another
      thread. This messages sent to the master do not block.</dd>
  <dt>addRequester</dt>
    <dd>Add a requester to receive messages.</dd>
  <dt>removeRequester</dt>
    <dd>Remove a requester.</dd>
  <dt>recordList</dt>
    <dd>Get a list of all records with names that match a regular
    expression.</dd>
  <dt>structureList</dt>
    <dd>Get a list of all structures with names that match a regular
      expression.</dd>
  <dt>recordToString</dt>
    <dd>Get a dump of all records with names that match a regular
    expression.</dd>
  <dt>structureToString</dt>
    <dd>Get a dump of all structures with names that match a regular
      expression.</dd>
</dl>
<hr />

<h2 style="text-align: center" id="Convert">Convert</h2>
<hr />

<p>NOTE about copying immutable array fields. If an entire immutable array
field is copied to another array that has the same elementType, both offsets
are 0, and the length is the length of the source array, then the shareData
method of the target array is called and the target array is set immutable.
Thus the source and target share the same primitive array.</p>

<p>This section describes the supported conversions between data types.</p>
<ul>
  <li>All supported types can be converted to a string. If you ask for a 100
    megabyte array to be converted to a string expect a lot of output.</li>
  <li>Conversion from a string to a scalar type.</li>
  <li>Conversion from an array of strings to an array of scalar types.</li>
  <li>Copy between the following types of scalar PVs 
    <ul>
      <li>Numeric type to another numeric type</li>
      <li>Both have the same type.</li>
      <li>Either is a string</li>
    </ul>
  </li>
  <li>Copy between PVArrays that satisfy one of the following. 
    <ul>
      <li>Numeric to numeric</li>
      <li>Both have the same type.</li>
      <li>Either is a string.</li>
    </ul>
  </li>
  <li>Conversions between numeric scalar types.</li>
  <li>Conversions between arrays of numeric type.</li>
  <li>Conversion between compatible structures.</li>
</ul>
<pre>    interface Convert {
        String getString(PVField pv, int indentLevel);
        String getString(PVField pv);
        void fromString(PVScalar pv,String from);
        void fromString(PVArray pv,String from);
        int fromStringArray(PVField pv,
             int offset, int len, String[]from, int fromOffset);
        int toStringArray(PVArray pv,
             int offset, int len, String[]to, int toOffset);
        boolean isCopyCompatible(Field from, Field to);
        void copy(PVField from,PVField to);
        boolean isCopyScalarCompatible(Field from, Field to);
        void copyScalar(PVField from, PVField to);
        boolean isCopyArrayCompatible(Array from, Array to);
        int copyArray(PVArray from, int offset, int len, PVArray to, int toOffset);
        boolean isCopyStructureCompatible(Structure from, Structure to);
        void copyStructure(PVStructure from, PVStructure to);
        // For the following the pv Type must be PVByte, ...., PVDouble
        byte toByte(PVField pv);
        short toShort(PVField pv);
        int   toInt(PVField pv);
        long  toLong(PVField pv);
        float toFloat(PVField pv);
        double toDouble(PVField pv);
        void fromByte(PVField pv, byte from);
        void  fromShort(PVField pv, short from);
        void  fromInt(PVField pv, int from);
        void  fromLong(PVField pv, long from);
        void  fromFloat(PVField pv, float from);
        void  fromDouble(PVField pv, double from);
// For the following the element type must be pvByte, ...., pvDouble
        int toByteArray(PVArray pv,
            int offset, int len, byte[]to, int toOffset);
        int toShortArray(PVArray pv,
            int offset, int len, short[]to, int toOffset);
        int toIntArray(PVArray pv,
            int offset, int len, int[]to, int toOffset);
        int toLongArray(PVArray pv,
            int offset, int len, long[]to, int toOffset);
        int toFloatArray(PVArray pv,
            int offset, int len, float[]to, int toOffset);
        int toDoubleArray(PVArray pv,
            int offset, int len, double[]to, int toOffset);
        int fromByteArray(PVArray pv,
            int offset, int len, byte[]from, fromOffset);
        int fromShortArray(PVArray pv,
            int offset, int len, short[]from, fromOffset);
        int fromIntArray(PVArray pv,
            int offset, int len, int[]from, fromOffset);
        int fromLongArray(PVArray pv,
            int offset, int len, long[]from, fromOffset);
        int fromFloatArray(PVArray pv,
            int offset, int len, float[]from, fromOffset);
        int fromDoubleArray(PVArray pv,
            int offset, int len, double[]from, fromOffset);
        void newLine(StringBuilder builder, int indentLevel);
    }</pre>

<p>The array methods all return the number of elements copied or converted.
This can be less than <span style="font-family: courier;">len</span> if the
PVField array contains less than len elements.</p>

<p><span style="font-family: courier;">newLine</span> is a convenience method
for code that implements <span style="font-family: courier;">toString</span>
It generates a newline and inserts blanks at the beginning of the newline.</p>
<hr />

<h2 style="text-align: center" id="Examples">Examples</h2>
<hr />

<h3 id="Accessing">Accessing PVData</h3>

<p>Assume that code wants to access two fields from a PVRecord:</p>
<dl>
  <dt>value</dt>
    <dd>Must be a PVDouble.</dd>
  <dt>timeStamp</dt>
    <dd>Just look for field with this name.</dd>
</dl>

<p>The following code uses introspection to get the desired information.</p>
<pre>String getValueAndTimeStamp(String recordName) {
    PVDatabase master = PVDatabaseFactory.getMaster():
    PVRecord pvRecord = master.findRecord(recordName);
    if(pvRecord==null) {
       return "record not found";
   }
   PVStructure pvStructure = pvRecord.getPVStructure();
   PVField valuePV = pvStructure.getSubField("value");
   if(valuePV==null) {
       return "value field not found";
   }
   if(valuePV.getField.getType!=Type.scalar) {
       return "value field is not a scalar";
   }
   Scalar scalar = (Scalar)valuePV.getField();
   if(scalar.getScalarType!=ScalarType.pvDouble) {
       return "value field is not a double";
   }
   PVDouble pvDouble = (PVDouble)valuePV;
   PVField timeStampPV = pvStructure.getSubField("timeStamp");
   if(timeStampPV==null) {
       return "timeStamp field not found";
   }
   double value = valuePV.get();
   return value + " timeStamp " + timeStampPV.toString();
}</pre>

<h3 id="Creating">Creating PVData</h3>

<p>Example of creating a scalar field.</p>
<pre>    PVDataCreate pvDataCreate = PVDataFactory.getPVDataCreate();
    PVDouble pvValue = pvDataCreate.createPVScalar(null,"value",ScalarType.pvDouble);</pre>

<p>Create a structure and put it into the master database.</p>
<pre>    PVDatabase master = PVDatabaseFactory.getMaster():
    FieldCreate fieldCreate = FieldFactory.getFieldCreate();
    PVDataCreate pvDataCreate = PVDataFactory.getPVDataCreate();

    Field[] fields = new Field[2];
    fields[0] = fieldCreate.createScalar("secondsSinceEpoch",ScalarType.pvLong);
    fields[1] = fieldeCreate.createScalar("nanoSeconds",ScalarType.pvInt);
    PVStructure pvStructure = pvDataCreate.createPVStructure(
        null,"timeStamp",fields);
    master.addStructure(pvStructure);</pre>

<p>Create a PVRecord that has a value field and a timeStamp. Use the
structure created in the previous example.</p>
<pre>    Field[] fields = new Field[2];
    fields[0] = fieldCreate.createScalar("value",ScalarType.pvDouble);
    PVStructure pvStructure = master.findStructure("timeStamp");
    fields[1] = fieldCreate.createStructure("timeStamp",pvStructure.getStructure.getFields();
    PVRecord pvRecord = pvDataCreate.createPVRecord("example",fields);</pre>
<P>

<P>
<DL>
</DL>
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Package</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <FONT CLASS="NavBarFont1">Class</FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-use.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../../org/epics/pvData/property/package-summary.html"><B>PREV PACKAGE</B></A>&nbsp;
&nbsp;<A HREF="../../../../org/epics/pvData/pvCopy/package-summary.html"><B>NEXT PACKAGE</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../../index.html?org/epics/pvData/pv/package-summary.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="package-summary.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>

</BODY>
</HTML>
