<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.6.0_18) on Thu Sep 02 09:39:33 EDT 2010 -->
<TITLE>
org.epics.pvData.pv
</TITLE>

<META NAME="date" CONTENT="2010-09-02">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="org.epics.pvData.pv";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Package</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <FONT CLASS="NavBarFont1">Class</FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-use.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../../org/epics/pvData/property/package-summary.html"><B>PREV PACKAGE</B></A>&nbsp;
&nbsp;NEXT PACKAGE</FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../../index.html?org/epics/pvData/pv/package-summary.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="package-summary.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<H2>
Package org.epics.pvData.pv
</H2>
<h1 style="text-align: center">EPICS PVData: pv<br />
package: org.epics.pvData.pv<br />
2010.08.26
<P>
<B>See:</B>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#package_description"><B>Description</B></A>
<P>

<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Interface Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/epics/pvData/pv/BitSetSerializable.html" title="interface in org.epics.pvData.pv">BitSetSerializable</A></B></TD>
<TD>Base interface for partital serializaion.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/epics/pvData/pv/Convert.html" title="interface in org.epics.pvData.pv">Convert</A></B></TD>
<TD>Convert between numeric types,  convert any field to a string,
  or convert from a string to a scalar field.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/epics/pvData/pv/DeserializableControl.html" title="interface in org.epics.pvData.pv">DeserializableControl</A></B></TD>
<TD>Deserialization control interface.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/epics/pvData/pv/Field.html" title="interface in org.epics.pvData.pv">Field</A></B></TD>
<TD>Interface for field reflection.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/epics/pvData/pv/FieldCreate.html" title="interface in org.epics.pvData.pv">FieldCreate</A></B></TD>
<TD>Interface for creating introspection interfaces.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/epics/pvData/pv/PostHandler.html" title="interface in org.epics.pvData.pv">PostHandler</A></B></TD>
<TD>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/epics/pvData/pv/PVArray.html" title="interface in org.epics.pvData.pv">PVArray</A></B></TD>
<TD>Base interface for array data.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/epics/pvData/pv/PVAuxInfo.html" title="interface in org.epics.pvData.pv">PVAuxInfo</A></B></TD>
<TD>Auxiliary information for a field.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/epics/pvData/pv/PVBoolean.html" title="interface in org.epics.pvData.pv">PVBoolean</A></B></TD>
<TD>get/put boolean data</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/epics/pvData/pv/PVBooleanArray.html" title="interface in org.epics.pvData.pv">PVBooleanArray</A></B></TD>
<TD>get/put a boolean array.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/epics/pvData/pv/PVByte.html" title="interface in org.epics.pvData.pv">PVByte</A></B></TD>
<TD>get/put byte data.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/epics/pvData/pv/PVByteArray.html" title="interface in org.epics.pvData.pv">PVByteArray</A></B></TD>
<TD>Get/put a byte array.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/epics/pvData/pv/PVDataCreate.html" title="interface in org.epics.pvData.pv">PVDataCreate</A></B></TD>
<TD>Create PVField field implementations.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/epics/pvData/pv/PVDouble.html" title="interface in org.epics.pvData.pv">PVDouble</A></B></TD>
<TD>Get/put double data</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/epics/pvData/pv/PVDoubleArray.html" title="interface in org.epics.pvData.pv">PVDoubleArray</A></B></TD>
<TD>Get/put a double array.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/epics/pvData/pv/PVField.html" title="interface in org.epics.pvData.pv">PVField</A></B></TD>
<TD>PVField is the base class for each PVData field.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/epics/pvData/pv/PVFloat.html" title="interface in org.epics.pvData.pv">PVFloat</A></B></TD>
<TD>Get/put float data.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/epics/pvData/pv/PVFloatArray.html" title="interface in org.epics.pvData.pv">PVFloatArray</A></B></TD>
<TD>Get/put a float array.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/epics/pvData/pv/PVInt.html" title="interface in org.epics.pvData.pv">PVInt</A></B></TD>
<TD>Get/put int data.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/epics/pvData/pv/PVIntArray.html" title="interface in org.epics.pvData.pv">PVIntArray</A></B></TD>
<TD>Get/put a int array.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/epics/pvData/pv/PVLong.html" title="interface in org.epics.pvData.pv">PVLong</A></B></TD>
<TD>Get/put long data.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/epics/pvData/pv/PVLongArray.html" title="interface in org.epics.pvData.pv">PVLongArray</A></B></TD>
<TD>Get/put a long array.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/epics/pvData/pv/PVScalar.html" title="interface in org.epics.pvData.pv">PVScalar</A></B></TD>
<TD>PVScalar extends PVField for a scalar field.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/epics/pvData/pv/PVScalarArray.html" title="interface in org.epics.pvData.pv">PVScalarArray</A></B></TD>
<TD>Base interface for array data.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/epics/pvData/pv/PVShort.html" title="interface in org.epics.pvData.pv">PVShort</A></B></TD>
<TD>Get/put short data.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/epics/pvData/pv/PVShortArray.html" title="interface in org.epics.pvData.pv">PVShortArray</A></B></TD>
<TD>Get/put a short array.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/epics/pvData/pv/PVString.html" title="interface in org.epics.pvData.pv">PVString</A></B></TD>
<TD>Get/put string data.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/epics/pvData/pv/PVStringArray.html" title="interface in org.epics.pvData.pv">PVStringArray</A></B></TD>
<TD>Get/put a String array.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/epics/pvData/pv/PVStructure.html" title="interface in org.epics.pvData.pv">PVStructure</A></B></TD>
<TD>PVStructure interface.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/epics/pvData/pv/PVStructureArray.html" title="interface in org.epics.pvData.pv">PVStructureArray</A></B></TD>
<TD>Get/put a structure array.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/epics/pvData/pv/Requester.html" title="interface in org.epics.pvData.pv">Requester</A></B></TD>
<TD>Base interface for requesters.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/epics/pvData/pv/Scalar.html" title="interface in org.epics.pvData.pv">Scalar</A></B></TD>
<TD>Reflection interface for a scalar field.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/epics/pvData/pv/ScalarArray.html" title="interface in org.epics.pvData.pv">ScalarArray</A></B></TD>
<TD>Base interface for array field reflection.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/epics/pvData/pv/Serializable.html" title="interface in org.epics.pvData.pv">Serializable</A></B></TD>
<TD>Base interface for serializaion.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/epics/pvData/pv/SerializableArray.html" title="interface in org.epics.pvData.pv">SerializableArray</A></B></TD>
<TD>Base interface for array serializaion.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/epics/pvData/pv/SerializableControl.html" title="interface in org.epics.pvData.pv">SerializableControl</A></B></TD>
<TD>Flush control interface.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/epics/pvData/pv/Status.html" title="interface in org.epics.pvData.pv">Status</A></B></TD>
<TD>Status interface.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/epics/pvData/pv/StatusCreate.html" title="interface in org.epics.pvData.pv">StatusCreate</A></B></TD>
<TD>Interface for creating status.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/epics/pvData/pv/Structure.html" title="interface in org.epics.pvData.pv">Structure</A></B></TD>
<TD>Reflection interface for structure field.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/epics/pvData/pv/StructureArray.html" title="interface in org.epics.pvData.pv">StructureArray</A></B></TD>
<TD>Base interface for array field reflection.</TD>
</TR>
</TABLE>
&nbsp;

<P>

<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Class Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/epics/pvData/pv/BooleanArrayData.html" title="class in org.epics.pvData.pv">BooleanArrayData</A></B></TD>
<TD>Class required by get/put PVBooleanArray methods.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/epics/pvData/pv/ByteArrayData.html" title="class in org.epics.pvData.pv">ByteArrayData</A></B></TD>
<TD>Class required by get/put PVByteArray methods.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/epics/pvData/pv/DoubleArrayData.html" title="class in org.epics.pvData.pv">DoubleArrayData</A></B></TD>
<TD>Class required by get/put PVDoubleArray methods.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/epics/pvData/pv/FloatArrayData.html" title="class in org.epics.pvData.pv">FloatArrayData</A></B></TD>
<TD>Class required by get/put PVFloatArray methods.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/epics/pvData/pv/IntArrayData.html" title="class in org.epics.pvData.pv">IntArrayData</A></B></TD>
<TD>Class required by get/put PVIntArray methods.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/epics/pvData/pv/LongArrayData.html" title="class in org.epics.pvData.pv">LongArrayData</A></B></TD>
<TD>Class required by get/put PVLongArray methods.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/epics/pvData/pv/ShortArrayData.html" title="class in org.epics.pvData.pv">ShortArrayData</A></B></TD>
<TD>Class required by get/put PVShortArray methods.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/epics/pvData/pv/StringArrayData.html" title="class in org.epics.pvData.pv">StringArrayData</A></B></TD>
<TD>Class required by get/put PVStringArray methods.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/epics/pvData/pv/StructureArrayData.html" title="class in org.epics.pvData.pv">StructureArrayData</A></B></TD>
<TD>Class required by get/put PVDoubleArray methods.</TD>
</TR>
</TABLE>
&nbsp;

<P>

<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Enum Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/epics/pvData/pv/MessageType.html" title="enum in org.epics.pvData.pv">MessageType</A></B></TD>
<TD>Types for messages.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/epics/pvData/pv/ScalarType.html" title="enum in org.epics.pvData.pv">ScalarType</A></B></TD>
<TD>Process Variable Scalar Data Type.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/epics/pvData/pv/Status.StatusType.html" title="enum in org.epics.pvData.pv">Status.StatusType</A></B></TD>
<TD>Status type enum.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/epics/pvData/pv/Type.html" title="enum in org.epics.pvData.pv">Type</A></B></TD>
<TD>Process Variable Data Type.</TD>
</TR>
</TABLE>
&nbsp;

<P>
<A NAME="package_description"><!-- --></A><H2>
Package org.epics.pvData.pv Description
</H2>

<P>
<h1 style="text-align: center">EPICS PVData: pv<br />
package: org.epics.pvData.pv<br />
2010.08.26</h1>
CONTENTS 

<div class="toc">
<ul>
  <li><a href="#Overview">Overview</a></li>
  <li><a href="#Process">Process Variable Reflection</a>
    <ul>
      <li><a href="#Type">Type</a></li>
      <li><a href="#Serializab">Serializable</a></li>
      <li><a href="#Reflection">Reflection</a></li>
    </ul>
  </li>
  <li><a href="#Status">Status</a></li>
  <li><a href="#PVField">PVField - Data Interfaces</a>
    <ul>
      <li><a href="#PVField1">PVField</a></li>
      <li><a href="#Requester">Requester</a></li>
      <li><a href="#PVAuxInfo">PVAuxInfo</a></li>
      <li><a href="#PVScalar">PVScalar and extensions</a>
        <ul>
          <li><a href="#Primitive">Primitive PVField types</a></li>
          <li><a href="#PVString">PVString</a></li>
        </ul>
      </li>
      <li><a href="#PVArray">PVArray and Extensions</a>
        <ul>
          <li><a href="#PVArray1">PVArray Extensions</a></li>
          <li><a href="#Complete">Complete set of PVArray Extensions</a></li>
        </ul>
      </li>
      <li><a href="#PVStructur">PVStructure</a></li>
      <li><a href="#PVDataCrea">PVDataCreate</a></li>
    </ul>
  </li>
  <li><a href="#Convert">Convert</a></li>
  <li><a href="#Examples">Examples</a>
    <ul>
      <li><a href="#Accessing">Accessing PVData</a></li>
      <li><a href="#Creating">Creating PVData</a></li>
    </ul>
  </li>
</ul>
</div>
<hr />

<h2 style="text-align: center" id="Overview">Overview</h2>
<hr />

<p>This package has the complete set of enum, interface, and class
definitions that describe PVData. The implementation is provided in package
org.epics.pvData.factory.</p>

<p>This package provides all theinterfaces required for creating and
accessing data used by projects pvAccess and javaIOC.</p>

<p>A PVStructure is a field that contains an array of subfields. Each field
has code for accessing the field. The interface for each field is PVField or
an interface that extends PVField. Each field also has an introspection
interface, which is Field or an extension of Field. If a PVField is in a
record then it also has an associated PVRecordField. This package overview
describes the complete set of data and introspection interfaces for
pvData.</p>

<p>This package also describes an interface Convert, which provides a rich
set of methods for converting and copying data between field.</p>

<p>The interface FieldCreate creates the introspection interfaces. The
interface PVDataCreate creates the PVField interfaces. Between them they
provide the ability to create every type of Field and PVField, i.e. they
provide a complete implemenation of pvData. It is also possible for other
code to provide implementations.</p>

<p>The javaIOC provides a database of PVRecords where each PVRecord has a top
level PVStructure. pvAccess presents data from a javaIOC record to a client
as a top level PVStructure.</p>

<p>The rest of this package overview describes all the interfaces provided by
this package. Again this package provides no implementations except for
enums. The implementation for all the interfaces is provided by package
org.epics.pvData.factory.</p>
<hr />

<h2 style="text-align: center" id="Process">Process Variable Reflection</h2>
<hr />

<p>Given a pvname, which consists of a record name and field name, it is
possible to introspect the field without requiring access to data. The
reflection and data interfaces are separate because the data may not be
available. For example when a client connects to a PV, the client library can
obtain the reflection information without obtaining any data. Only when a
client issues an I/O request will data be available. This separation is
especially important for arrays and structures so that a client can discover
the type without requiring that a large array or structure be transported
over the network.</p>

<h3 id="Type">Type</h3>

<p>The types are defined by the Java definitions:</p>
<pre>    enum Type {
        scalar,
        scalarArray,
        structure,
        structureArray;
    }

    enum ScalarType {
        pvBoolean,
        pvByte, pvShort, pvInt, pvLong,
        pvFloat,pvDouble,
        pvString;

        //Convenience methods
        public boolean isInteger();   // pvByte,...,pvLong
        public boolean isNumeric();    // pvByte,...pvDouble
        public boolean isPrimitive();  // pvBoolean,...pvDouble
        public static ScalarType getScalarType(String type);
    }</pre>

<h3 id="Serializab">Serializable</h3>

<p>The following interfaces are called by pvAccess for transporting data over
the network. The abstract and base classes ensure that these methods are
properly implemented. </p>
<pre>    interface Serializable {
        void serialize(ByteBuffer buffer,SerializableControl flusher);
        void deserialize(ByteBuffer buffer,DeserializableControl control);
    }

    interface SerializableControl {
        void flushSerializeBuffer();
        void ensureBuffer(int size);
    }

    interface DeserializableControl {
        void ensureData(int size);
    }

    interface SerializableArray extends Serializable {
        void serialize(ByteBuffer buffer, SerializableControl flusher, int offset, int count);
    }       

    interface BitSetSerializable {
       void serialize(ByteBuffer buffer, SerializableControl flusher, BitSet bitSet);
       void deserialize(ByteBuffer buffer, DeserializableControl control, BitSet bitSet);
    }</pre>

<h3 id="Reflection">Reflection</h3>

<p>This section defines the complete set of Java PV reflection interfaces.</p>
<pre>    
    interface Field {
        String getFieldName();
        Type getType();
        String toString();
        String toString(int indentLevel);
    } 

    interface Scalar extends Field {
        ScalarType getScalarType();
    }

    interface ScalarArray extends Field{
        ScalarType getElementType();
    }

    interface Structure extends Field{
        String[] getFieldNames();
        Field getField(String fieldName);
        int getFieldIndex(String fieldName);
        Field[] getFields();
    }

    interface StructureArray extends Field{
        Structure getStructure();
    }

    interface FieldCreate {
        Field create(String fieldName,Field field);
        Scalar createScalar(String fieldName,ScalarType scalarType);
        ScalarArray createScalarArray(String fieldName,ScalarType elementType);
        StructureArray createStructureArray(String fieldName,Structure elementStructure);
        Structure createStructure(String fieldName, Field[] fields);
    }</pre>

<p>The above definitions support the following:</p>
<dl>
  <dt>Field</dt>
    <dd>A field: 
      <dl>
        <dt>Has a name.</dt>
        <dt>Has a Type.</dt>
        <dt>Can be converted to a string.</dt>
      </dl>
    </dd>
  <dt>Scalar</dt>
    <dd>A scalar has a scalarType</dd>
  <dt>ScalarArray</dt>
    <dd>The element type is a scalarType</dd>
  <dt>StructureArray</dt>
    <dd>The field holds PVStructure[]. Each element has the same Structure
      interspection interface. A client can only get/put entire PVStructure
      elements NOT subfields of array elements.</dd>
  <dt>Structure</dt>
    <dd>Has fields that can be any of the supported types.</dd>
  <dt>FieldCreate</dt>
    <dd>This is an interface that provides methods to create introspection
      interfaces. A factory is provides to create FieldCreate.</dd>
</dl>
<hr />

<h2 style="text-align: center" id="Status">Status</h2>
<hr />

<p>Status provides a way to pass status back to client code. It is new and
not currently used by pvData but may be in the future. It is used by code
that uses pvData.</p>
<pre>    interface Status extends Serializable  {
        public enum StatusType {OK,WARNING,ERROR,FATAL};
        StatusType getType();
        String getMessage();
        String getStackDump();
        boolean isOK();
        boolean isSuccess();
    }
    
    interface StatusCreate {
        Status getStatusOK(); 
        Status createStatus(StatusType type, String message, Throwable cause);
        Status deserializeStatus(ByteBuffer buffer, DeserializableControl control);
    }</pre>

<p>The Status methods are:</p>
<dl>
  <dt>StatusType</dt>
    <dd>An enum for the status type.</dd>
  <dt>getType</dt>
    <dd>Get the statusType.</dd>
  <dt>getMessage</dt>
    <dd>Get a message explaining the error.</dd>
  <dt>getStackDump</dt>
    <dd>Get a stack dump.</dd>
</dl>

<p>The StatusCreate methods are:</p>
<dl>
  <dt>getStatusOK</dt>
    <dd>Get a singleton that returns StatusType.OK and a null message and
      stackDump.</dd>
  <dt>createStatus</dt>
    <dd>Create a new Status.</dd>
  <dt>deserializeStatus</dt>
    <dd>Use this method instead of Status.deserialize(), since this allows OK
      status optimization.</dd>
</dl>
<hr />

<h2 style="text-align: center" id="PVField">PVField - Data Interfaces</h2>
<hr />

<p>This section defines the Java Interfaces for accessing the data within a
PV record.</p>

<h3 id="PVField1">PVField</h3>

<p>PVField is the base interface for accessing data. Every field of every
structure of every record instance has a PVField associated with it. A
structure and a record also has an associated PVField.</p>
<pre>    interface PVField extends Serializable, Requester {
        int getFieldOffset();
        int getNextFieldOffset();
        int getNumberFields();
        PVAuxInfo getPVAuxInfo();
        boolean isImmutable();
        void setImmutable();
        Field getField();
        PVStructure getParent();
        void replacePVField(PVField newPVField);
        void renameField(String newName);
        void postPut();
        void setPostHandler(PostHandler postHandler);
        String toString();
        String toString(int indentLevel);
    }</pre>

<p>where</p>
<dl>
  <dt>Requester</dt>
    <dd>PVField extends Requester which is described in the next
    sub-section.</dd>
  <dt>getFieldOffset</dt>
    <dd>Get offset of the PVField field within top level structure. Every
      field within the PVStructure has a unique offset. The top level
      structure has an offset of 0. The first field within the structure has
      offset equal to 1. The other offsets are determined by recursively
      traversing each structure of the tree. </dd>
  <dt>getNextFieldOffset</dt>
    <dd>Get the next offset. If the field is a scalar or array field then
      this is just offset + 1. If the field is a structure it is the offset
      of the next field after this structure. Thus (nextOffset - offset) is
      always equal to the total number of fields within the field. </dd>
  <dt>getNumberFields</dt>
    <dd>Get the total number of fields in this field. This is nextFieldOffset
      - fieldOffset. </dd>
  <dt>getPVAuxInfo</dt>
    <dd>Get the PVAuxInfo for this field. PVAuxInfo is described below.</dd>
  <dt>isImmutable</dt>
    <dd>Is the field immutable?</dd>
  <dt>setImmutable</dt>
    <dd>Make the field immutable. Once a field is immutable it can never be
      changed since there is no method to again make it mutable. This is an
      important design decision since it allows immutable array fields to
      share the internal primitive data array.</dd>
  <dt>getFullFieldName</dt>
    <dd>Get the full field name. This returns a name in the form "name.name
      ...". </dd>
  <dt>getFullName</dt>
    <dd>Get the full name. This returns a name in the form "recordName.name
      ...". If the fields is not part of a record it is the same as
      getFullFieldName.</dd>
  <dt>getField</dt>
    <dd>Get the reflection interface for the data.</dd>
  <dt>getParent</dt>
    <dd>Get the interface for the parent or null if this is the top level
      PVStructure.</dd>
  <dt>replacePVField</dt>
    <dd>Replace this PVField. This is called by support code that wants to
      replace the default implementation of a data field with it's own
      implementation.</dd>
  <dt>renameField</dt>
    <dd>Rename the field name.</dd>
  <dt>postPut</dt>
    <dd>If this field is a field of a record pvRecordField.postPut() is
      called. If not a field of a record nothing happens.</dd>
  <dt>toString</dt>
    <dd>Converts the field data to a string. This is mostly for debugging
      purposes.</dd>
</dl>

<h3 id="Requester">Requester</h3>

<p>A PVField extends Requester. Requester is present so that when database
errors are found there is someplace to send a message. As will be seen below,
PVRecord provides methods to register message requesters. Also a PVDatabase
provides an identical method. Thus when a message is generated for a field it
is propagated up to the record with the full field name attached and then
propagated to the PVDatabase which sends the messages to the registered
requesters.</p>
<pre>    enum MessageType {info,warning,error,fatalError}

    interface Requester {
        String getRequesterName();
        void message(String message, MessageType messageType);
    }</pre>

<p>where</p>
<dl>
  <dt></dt>
  <dt>MessageType</dt>
    <dd>Type of message.</dd>
  <dt>Requester</dt>
    <dd>The default implementation is: 
      <ul>
        <li>getRequesterName<br />
          This is the full field name concatenated to the record name.</li>
        <li>message<br />
          For the default implementation, PVField prepends the full field
          name to the message and calls PVRecord.message. The default
          implementation for PVRecord either displays the message on stdout
          or stderr or gives the message to message requsters.</li>
      </ul>
    </dd>
</dl>

<h3 id="PVAuxInfo">PVAuxInfo</h3>

<p>AuxInfo (Auxillary Information) is information about a field that is
application specific. It will not be available outside the application that
implements the database. In particular it will not be made available to
Channel Access. It is used by the database itself to override the default
implementation of fields. The JavaIOC uses it for attaching support code.
Database Configuration and other tools can use it for configuration
information. Each Field and each PVField can have have an arbitrary number of
auxInfos. An auxInfo is a (key,PVScalar) pair where key is a string.</p>
<pre>    public interface PVAuxInfo {
        PVField getPVField();
        PVScalar createInfo(String key,ScalarType scalarType);
        Map&lt;String,PVScalar&gt; getInfos();
        PVScalar getInfo(String key);
        String toString();
        String toString(int indentLevel);
    }</pre>

<p>where</p>
<dl>
  <dt>getPVField</dt>
    <dd>Get the PVField to which this PVAuxInfo is attached.</dd>
  <dt>createInfo</dt>
    <dd>Create a new PVScalar of type scalarType.</dd>
  <dt>getInfos</dt>
    <dd>Get a map of all the auxInfos.</dd>
  <dt>getInfo</dt>
    <dd>Get the PVScalar with the specified key.</dd>
  <dt>toString</dt>
    <dd>Print all the auxInfos</dd>
</dl>

<h3 id="PVScalar">PVScalar and extensions</h3>
<pre>    interface PVScalar extends PVField {
        Scalar getScalar();
    }</pre>

<h4 id="Primitive">Primitive PVField types</h4>

<p>The interfaces for primitive data types are:</p>
<pre>    interface PVBoolean extends PVScalar {
        boolean get();
        void put(boolean value);
    }

    interface PVByte extends PVScalar {
        byte get();
        void put(byte value);
    }

    interface PVShort extends PVScalar {
        short get();
        void put(short value);
    }

    interface PVInt extends PVScalar {
        int get();
        void put(int value);
    }

    interface PVLong extends PVScalar {
        long get();
        void put(long value);
    }

    interface PVFloat extends PVScalar {
        float get();
        void put(float value);
    }

    interface PVDouble extends PVScalar {
        double get();
        void put(double value);
    }</pre>

<h4 id="PVString">PVString</h4>

<p>The interface for string is:</p>
<pre>    interface PVString extends PVScalar, SerializableArray {
        String get();
        void put(String value);
    }</pre>

<h3 id="PVArray">PVArray and Extensions</h3>

<p><span style="font-family: courier">PVArray</span> is the base interface
for all the other PV Array interfaces. It extends PVField and provides the
additional methods:</p>
<pre>    interface PVArray extends PVField, SerializableArray {
        int getLength();
        void setLength(int len);
        int getCapacity();
        void setCapacity(int len);
        boolean isCapacityMutable();
        void setCapacityMutable(boolean isMutable);
    }</pre>
<dl>
  <dt>getLength</dt>
    <dd>Get the current length. This is less that or equal to the
    capacity.</dd>
  <dt>setLength</dt>
    <dd>Set the length. If the PVField is not mutable then an exception is
      thrown. If this is greater than the capacity setCapacity is called.</dd>
  <dt>getCapacity</dt>
    <dd>Get the capacity, i.e. this is the sized of the underlying data
    array.</dd>
  <dt>setCapacity</dt>
    <dd>Set the capacity. The semantics are implementation dependent but
      typical semantics are as follows: If the capacity is not mutable an
      exception is thrown. A new data array is created and data is copied
      from the old array to the new array. </dd>
  <dt>isCapacityMutable</dt>
    <dd>Is the capacity mutable</dd>
  <dt>setCapacityMutable</dt>
    <dd>Specify if the capacity can be changed.</dd>
</dl>

<h4 id="PVArray1">PVArray Extensions</h4>

<p>The interface for each array type has get and put methods which have the
same arguments except for the data type. For example PVDoubleArray is:</p>
<pre>    public class DoubleArrayData {
        public double[] data;
        public int offset;
    }
    interface PVDoubleArray extends PVScalarArray {
        int get(int offset, int len, DoubleArrayData data);
        int put(int offset, int len, double[]from, int fromOffset);
        void shareData(double[] from);
    }</pre>

<p>Get "exposes" it's internal array by setting data.data and data.offset.
The caller is responsible for copying the array elements. This violates the
principle that objects should not expose their internal data but is done for
efficency. For example it makes it possible to copy between arrays with
identical element types via a call to System.arraycopy without requiring an
intermediate array.</p>

<p>Both get and put return the number of elements actually transfered. The
arguments are:</p>
<dl>
  <dt>offset</dt>
    <dd>The offset in the PV array.</dd>
  <dt>len</dt>
    <dd>The maximum number of elements to transfer. The number actually
      transfered will be less than or equal to this value.</dd>
  <dt>data</dt>
    <dd>Get sets data.data to it's internal array and data.offset to the
      offset into the array. The caller is responsible for the actual data
      transfer.</dd>
  <dt>from</dt>
    <dd>The array from which the data is taken. This array is supplied by the
      caller</dd>
  <dt>fromOffset</dt>
    <dd>The offset in <span style="font-family: courier;">from</span></dd>
</dl>

<p>The caller must be prepared to make multiple calls to retrieve or put an
entire array. A caller should accept or put partial arrays. For example the
following reads an entire array:</p>
<pre>    double[] getArray(PVDoubleArray pv)
    {
        int len = pv.getLength();
        double[] storage = new double[len];
        DoubleArrayData data = new DoubleArrayData();
        int offset = 0;
        while(offset &lt; len) {
            int num = pv.get(offset,(len-offset),data);
            System.arraycopy(data.data,data.offset,storage,offset,num);
            offset += num;
        }
        return storage;
    } </pre>

<p>shareData results in the PVArray using the primitive array that is passed
to this method. This is most useful for immutable arrays. In this case the
caller must set the PVArray to be immutable. In the PVArray is not immutable
then it is the applications responsibility to coordinate access to the array.
Again this violates the principle that objects should not expose their
internal data but is important for immutable arrays. For example pvData and
the javaIOC define many enumerated structures where an enumerated structure
has three fields: index, choice, and choices. Choices is a PVStringArray that
holds the enumerated choices. Index is a PVInt that is the index of the
currently selected choice and choice is a PVString which is the currently
selected choice. For many enumerated structures the choices is immutable.
Allowing the choices internal String[] to be shared between all the instances
of an enumerated structure saves on storage. An example is alarmSeverity.
Another reason for allowing shared data is so that an application which
processes an array can be separated into multiple modules that directly
access the internal data array of a PVArray. This can be required for
minimizing CPU overhead. In this case it is the applications responsibility
to coordinate access to the array.</p>

<h4 id="Complete">Complete set of PVArray Extensions</h4>
<pre>    interface PVScalarArray extends PVArray {
        ScalarArray getScalarArray();
    }

    public class BooleanArrayData {
        public boolean[] data;
        public int offset;
    }
    interface PVBooleanArray extends PVScalarArray {
        int get(int offset, int len, BooleanArrayData data);
        int put(int offset, int len, boolean[]from, int fromOffset);
        void shareData(boolean[] from);
    }

    public class ByteArrayData {
        public byte[] data;
        public int offset;
    }
    interface PVByteArray extends PVScalarArray {
        int get(int offset, int len, ByteArrayData data);
        int put(int offset, int len, byte[]from, int fromOffset);
        void shareData(byte[] from);
    }

    public class ShortArrayData {
        public short[] data;
        public int offset;
    }
    interface PVShortArray extends PVScalarArray {
        int get(int offset, int len, ShortArrayData data);
        int put(int offset, int len, short[]from, int fromOffset);
        void shareData(short[] from);
    }

    public class IntArrayData {
        public int[] data;
        public int offset;
    }
    interface PVIntArray extends PVScalarArray {
        int get(int offset, int len, IntArrayData data);
        int put(int offset, int len, int[]from, int fromOffset);
        void shareData(int[] from);
    }

    public class LongArrayData {
        public long[] data;
        public int offset;
    }
    interface PVLongArray extends PVScalarArray {
        int get(int offset, int len, LongArrayData data);
        int put(int offset, int len, long[]from, int fromOffset);
        void shareData(long[] from);
    }

    public class FloatArrayData {
        public float[] data;
        public int offset;
    }
    interface PVFloatArray extends PVScalarArray {
        int get(int offset, int len, FloatArrayData data);
        int put(int offset, int len, float[]from, int fromOffset);
        void shareData(float[] from);
    }

    public class DoubleArrayData {
        public double[] data;
        public int offset;
    }
    interface PVDoubleArray extends PVScalarArray {
        int get(int offset, int len, DoubleArrayData data);
        int put(int offset, int len, double[]from, int fromOffset);
        void shareData(double[] from);
    }

    public class StringArrayData {
        public String[] data;
        public int offset;
    }
    interface PVStringArray extends PVScalarArray {
        int get(int offset, int len, StringArrayData data);
        int put(int offset, int len, String[]from, int fromOffset);
        void shareData(String[] from);
    }

    public class StructureArrayData {
        public PVStructure[] data;
        public int offset;
    }

    interface PVStructureArray extends PVArray {
        StructureArray getStructureArray();
        int get(int offset, int length, StructureArrayData data);
        int put(int offset,int length, PVStructure[] from, int fromOffset);
        void shareData(PVStructure[] from);
    }</pre>

<p>Notes about PVStructureArray: A client can only access the data in the
elements of the array via the get and put methods, i.e. it is not possible to
access subfields indirectly. PVStructureArray.getNumberFields() returns 1,
i.e. the field looks like a leaf field.</p>

<h3 id="PVStructur">PVStructure</h3>

<p>The interface for a structure is:</p>
<pre>    interface PVStructure extends PVField, BitSetSerializable {
        Structure getStructure();
        PVField[] getPVFields();
        PVField getSubField(String fieldName);
        PVField getSubField(int fieldOffset);
        void appendPVField(PVField pvField);
        void appendPVFields(PVField[] pvFields);
        void removePVField(String fieldName);
        // the following are convenience methods
        PVBoolean getBooleanField(String fieldName);
        PVByte getByteField(String fieldName);
        PVShort getShortField(String fieldName);
        PVInt getIntField(String fieldName);
        PVLong getLongField(String fieldName);
        PVFloat getFloatField(String fieldName);
        PVDouble getDoubleField(String fieldName);
        PVString getStringField(String fieldName);
        PVStructure getStructureField(String fieldName);
        PVScalarArray getScalarArrayField(String fieldName,ScalarType elementType);
        PVStructureArray getStructureArrayField(String fieldName);
        String getExtendsStructureName();
        boolean putExtendsStructureName(String extendsStructureName);
    }</pre>

<p>where</p>
<dl>
  <dt>getStructure</dt>
    <dd>Get the introspection interface for the structure.</dd>
  <dt>getPVFields</dt>
    <dd>Returns the array of subfields. The set of subfields must all have
      different field names.</dd>
  <dt>getSubField(String fieldName)</dt>
    <dd>Get a subField of a field. For a PVStructure a non-null result is
      returned if fieldName is a field of the PVStructure. The fieldName can
      be of the form name.name...</dd>
  <dt>getSubField(int fieldOffset)</dt>
    <dd>Get the field located a fieldOffset, where fieldOffset is relative to
      the top level structure. This returns null if the specified field is
      not located within this PVStructure.</dd>
  <dt>appendPVField</dt>
    <dd>Append pvField to the end of this PVStructure. This should NOT be
      called if any code is attached to any of the fields in the top level
      structure.</dd>
  <dt>appendPVFields</dt>
    <dd>Append an array of pvFields to the end of this structure. Note that
      if the original number of fields is 0 than pvFields replaces the
      original. Thus the caller must NOT reuse pvFields after calling this
      method. This should NOT be called if any code is attached to any of the
      fields in the top level structure</dd>
  <dt>removePVField</dt>
    <dd>Remove the specified field from this structure. This should NOT be
      called if any code is attached to any of the fields in the top level
      structure.</dd>
  <dt>getBooleanField</dt>
    <dd>Look for fieldName. If found and it has the correct type return the
      interface. This and the following methods are convenience methods that
      allow a user to get the interface to a subfield without requiring
      introspection. fieldName can be of the form name.name...</dd>
  <dt>getByteField</dt>
    <dd>Look for fieldName. If found and it has the correct type return the
      interface.</dd>
  <dt>getShortField</dt>
    <dd>Look for fieldName. If found and it has the correct type return the
      interface.</dd>
  <dt>getIntField</dt>
    <dd>Look for fieldName. If found and it has the correct type return the
      interface.</dd>
  <dt>getLongField</dt>
    <dd>Look for fieldName. If found and it has the correct type return the
      interface.</dd>
  <dt>getFloatField</dt>
    <dd>Look for fieldName. If found and it has the correct type return the
      interface.</dd>
  <dt>getDoubleField</dt>
    <dd>Look for fieldName. If found and it has the correct type return the
      interface.</dd>
  <dt>getStringField</dt>
    <dd>Look for fieldName. If found and it has the correct type return the
      interface.</dd>
  <dt>getScalarArrayField</dt>
    <dd>Look for fieldName. If found and it has the correct type return the
      interface.</dd>
  <dt>getStructureArrayField</dt>
    <dd>Look for fieldName. If found and it has the correct type return the
      interface.</dd>
  <dt>getExtendsStructureName</dt>
    <dd>Get the name of structure that this structure extends.</dd>
  <dt>putExtendsStructureName</dt>
    <dd>Specify the structure that this structure extends.</dd>
</dl>

<h3 id="PVDataCrea">PVDataCreate</h3>

<p>PVDataCreate is an interface that provides methods that create PVField
interfaces. A factory is provided that creates PVDataCreate.</p>
<pre>interface PVDataCreate {
    PVField createPVField(PVStructure parent, Field field);
    PVField createPVField(PVStructure parent,String fieldName,PVField fieldToClone);
    PVScalar createPVScalar(PVStructure parent,Scalar scalar);
    PVScalar createPVScalar(PVStructure parent,String fieldName,ScalarType fieldType);
    PVScalar createPVScalar(PVStructure parent,String fieldName,PVScalar scalarToClone);
    PVScalarArray createPVScalarArray(PVStructure parent,ScalarArray array);
    PVScalarArray createPVScalarArray(PVStructure parent,String fieldName,ScalarType elementType);
    PVScalarArray createPVScalarArray(PVStructure parent,String fieldName,PVScalarArray arrayToClone);
    PVStructureArray createPVStructureArray(PVStructure parent,StructureArray structureArray);
    PVStructure createPVStructure(PVStructure parent,
        Structure structure);
    PVStructure createPVStructure(PVStructure parent,String fieldName,
        Field[] fields);
    PVStructure createPVStructure(PVStructure parent,String fieldName,
        PVStructure structToClone);
    PVField[] flattenPVStructure(PVStructure pvStructure);
}</pre>
where 
<dl>
  <dt style="font-family: courier;">createPVField</dt>
    <dd>The PVField is created reusing the Field interface. Two methods are
      provided. Each calls the corresponding createPVScalar, createPVArray,
      or createPVStructure depending in the type os the last argument.</dd>
  <dt style="font-family: courier;">createPVScalar</dt>
    <dd>Creates an instance of a PVScalar. Three versions are supplied. The
      first is passed an introspection interface. The second provides the
      field name and the scalarType. The last provides a field name and a
      PVScalar to clone. The newly created PVScalar will have the same
      auxInfos as the original.</dd>
  <dt style="font-family: courier;">createPVScalarArray</dt>
    <dd>Create an instance of a PVArray. Three versions are supplied. The
      first is passed an introspection interface. The second provides the
      field name and the elementType. The last provides a field name and a
      PVArray to clone. The newly created PVArray will have the same auxInfos
      as the original.</dd>
  <dt style="font-family: courier;">createPVStructureArray</dt>
    <dd>Create a PVStructureArray. It must be passed a structureToClone. This
      will become the Structure interface for ALL elements of the
      PVStructureArray. It MUST be used to create any new array elements.</dd>
  <dt style="font-family: courier;">createPVStructure</dt>
    <dd>Create an instance of a PVStructure. Four methods are provided. The
      first method uses a previously created structure introspection
      interface. The second uses a Field array to initialize the sub-fields.
      The third initializes the subfields by cloning the fields contained in
      structToClone. The newly created sub-fields will have the same values
      and auxInfos as the original. If structToClone is null then the new
      structure is initialized to have 0 sub-fields.</dd>
  <dt style="font-family: courier;">flattenPVStructure</dt>
    <dd>Create an array of PVFields for the fields in the PVStructure. The
      order is according to fieldOffset.</dd>
</dl>
<hr />

<h2 style="text-align: center" id="Convert">Convert</h2>
<hr />

<p>NOTE about copying immutable array fields. If an entire immutable array
field is copied to another array that has the same elementType, both offsets
are 0, and the length is the length of the source array, then the shareData
method of the target array is called and the target array is set immutable.
Thus the source and target share the same primitive array.</p>

<p>This section describes the supported conversions between data types.</p>
<ul>
  <li>All supported types can be converted to a string. If you ask for a 100
    megabyte array to be converted to a string expect a lot of output.</li>
  <li>Conversion from a string to a scalar type.</li>
  <li>Conversion from an array of strings to an array of scalar types.</li>
  <li>Copy between the following types of scalar PVs 
    <ul>
      <li>Numeric type to another numeric type</li>
      <li>Both have the same type.</li>
      <li>Either is a string</li>
    </ul>
  </li>
  <li>Copy between PVArrays that satisfy one of the following. 
    <ul>
      <li>Numeric to numeric</li>
      <li>Both have the same type.</li>
      <li>Either is a string.</li>
    </ul>
  </li>
  <li>Conversions between numeric scalar types.</li>
  <li>Conversions between arrays of numeric type.</li>
  <li>Conversion between compatible structures.</li>
  <li>A utility method the returns the full field name of a field.</li>
</ul>
<pre>    interface Convert {
        String getFullFieldName(PVField pvField)
        String getString(PVField pv, int indentLevel);
        String getString(PVField pv);
        void fromString(PVScalar pv,String from);
        void fromString(PVScalarArray pv,String from);
        int fromStringArray(PVScalarArray pv,
             int offset, int len, String[]from, int fromOffset);
        int toStringArray(PVScalarArray pv,
             int offset, int len, String[]to, int toOffset);
        boolean isCopyCompatible(Field from, Field to);
        void copy(PVField from,PVField to);
        boolean isCopyScalarCompatible(Field from, Field to);
        void copyScalar(PVField from, PVField to);
        boolean isCopyScalarArrayCompatible(ScalarArray from, ScalarArray to);
        int copyScalarArray(PVScalarArray from, int offset,
             PVScalarArray to, int toOffset, int len);
        boolean isCopyStructureCompatible(Structure from, Structure to);
        void copyStructure(PVStructure from, PVStructure to);
        boolean isCopyStructureArrayCompatible(StructureArray from, StructureArray to);
        void copyStructureArray(PVStructureArray from, PVStructureArray to);
        // For the following the pv Type must be PVByte, ...., PVDouble
        byte toByte(PVField pv);
        short toShort(PVField pv);
        int   toInt(PVField pv);
        long  toLong(PVField pv);
        float toFloat(PVField pv);
        double toDouble(PVField pv);
        void fromByte(PVField pv, byte from);
        void  fromShort(PVField pv, short from);
        void  fromInt(PVField pv, int from);
        void  fromLong(PVField pv, long from);
        void  fromFloat(PVField pv, float from);
        void  fromDouble(PVField pv, double from);
// For the following the element type must be pvByte, ...., pvDouble
        int toByteArray(PVScalarArray pv,
            int offset, int len, byte[]to, int toOffset);
        int toShortArray(PVScalarArray pv,
            int offset, int len, short[]to, int toOffset);
        int toIntArray(PVScalarArray pv,
            int offset, int len, int[]to, int toOffset);
        int toLongArray(PVScalarArray pv,
            int offset, int len, long[]to, int toOffset);
        int toFloatArray(PVScalarArray pv,
            int offset, int len, float[]to, int toOffset);
        int toDoubleArray(PVScalarArray pv,
            int offset, int len, double[]to, int toOffset);
        int fromByteArray(PVScalarArray pv,
            int offset, int len, byte[]from, fromOffset);
        int fromShortArray(PVScalarArray pv,
            int offset, int len, short[]from, fromOffset);
        int fromIntArray(PVScalarArray pv,
            int offset, int len, int[]from, fromOffset);
        int fromLongArray(PVScalarArray pv,
            int offset, int len, long[]from, fromOffset);
        int fromFloatArray(PVScalarArray pv,
            int offset, int len, float[]from, fromOffset);
        int fromDoubleArray(PVScalarArray pv,
            int offset, int len, double[]from, fromOffset);
        void newLine(StringBuilder builder, int indentLevel);
    }</pre>

<p>The array methods all return the number of elements copied or converted.
This can be less than <span style="font-family: courier;">len</span> if the
PVField array contains less than len elements.</p>

<p><span style="font-family: courier;">newLine</span> is a convenience method
for code that implements <span style="font-family: courier;">toString</span>
It generates a newline and inserts blanks at the beginning of the newline.</p>
<hr />

<h2 style="text-align: center" id="Examples">Examples</h2>
<hr />

<h3 id="Accessing">Accessing PVData</h3>

<p>Assume that code wants to access two fields from a PVStructure:</p>
<dl>
  <dt>value</dt>
    <dd>Must be a PVDouble.</dd>
  <dt>timeStamp</dt>
    <dd>Just look for field with this name.</dd>
</dl>

<p>The following code uses introspection to get the desired information.</p>
<pre>String getValueAndTimeStamp(PVStructure pvStructure) {
   PVField valuePV = pvStructure.getSubField("value");
   if(valuePV==null) {
       return "value field not found";
   }
   if(valuePV.getField.getType!=Type.scalar) {
       return "value field is not a scalar";
   }
   Scalar scalar = (Scalar)valuePV.getField();
   if(scalar.getScalarType!=ScalarType.pvDouble) {
       return "value field is not a double";
   }
   PVDouble pvDouble = (PVDouble)valuePV;
   PVField timeStampPV = pvStructure.getSubField("timeStamp");
   if(timeStampPV==null) {
       return "timeStamp field not found";
   }
   double value = valuePV.get();
   return value + " timeStamp " + timeStampPV.toString();
}</pre>

<h3 id="Creating">Creating PVData</h3>

<p>Example of creating a scalar field.</p>
<pre>    PVDataCreate pvDataCreate = PVDataFactory.getPVDataCreate();
    PVDouble pvValue = pvDataCreate.createPVScalar(null,"value",ScalarType.pvDouble);</pre>

<p>Create a structure.</p>
<pre>    
    FieldCreate fieldCreate = FieldFactory.getFieldCreate();
    PVDataCreate pvDataCreate = PVDataFactory.getPVDataCreate();

    PVStructure create() {
        Field[] fields = new Field[2];
        fields[0] = fieldCreate.createScalar("secondsSinceEpoch",ScalarType.pvLong);
        fields[1] = fieldeCreate.createScalar("nanoSeconds",ScalarType.pvInt);
        PVStructure pvStructure = pvDataCreate.createPVStructure(
            null,"timeStamp",fields);
        return(pvStructure);
    }</pre>

<p>Create a PVStructure that has a value field and a timeStamp. Use the
structure created in the previous example.</p>
<pre>    Field[] fields = new Field[2];
    fields[0] = fieldCreate.createScalar("value",ScalarType.pvDouble);
    PVStructure pvStructure = create();
    fields[1] = fieldCreate.createStructure("timeStamp",pvStructure.getStructure.getFields();
    PVStructure pvStruct = pvDataCreate.createPVStructure(null,"myStructure",fields);</pre>
<P>

<P>
<DL>
</DL>
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Package</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <FONT CLASS="NavBarFont1">Class</FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-use.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../../org/epics/pvData/property/package-summary.html"><B>PREV PACKAGE</B></A>&nbsp;
&nbsp;NEXT PACKAGE</FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../../index.html?org/epics/pvData/pv/package-summary.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="package-summary.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>

</BODY>
</HTML>
