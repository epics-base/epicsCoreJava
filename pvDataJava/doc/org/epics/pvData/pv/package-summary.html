<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.5.0_05) on Mon Mar 02 14:03:57 GMT-05:00 2009 -->
<TITLE>
org.epics.pvData.pv
</TITLE>

<META NAME="keywords" CONTENT="org.epics.pvData.pv package">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    parent.document.title="org.epics.pvData.pv";
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Package</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <FONT CLASS="NavBarFont1">Class</FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-use.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../../org/epics/pvData/property/package-summary.html"><B>PREV PACKAGE</B></A>&nbsp;
&nbsp;<A HREF="../../../../org/epics/pvData/test/package-summary.html"><B>NEXT PACKAGE</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../../index.html?org/epics/pvData/pv/package-summary.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="package-summary.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<H2>
Package org.epics.pvData.pv
</H2>
<h1 style="text-align: center">EPICS PVData: pv<br />
package: org.epics.pvData.pv<br />
2009.02.13
<P>
<B>See:</B>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#package_description"><B>Description</B></A>
<P>

<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Interface Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/epics/pvData/pv/Array.html" title="interface in org.epics.pvData.pv">Array</A></B></TD>
<TD>Base interface for array field reflection.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/epics/pvData/pv/Convert.html" title="interface in org.epics.pvData.pv">Convert</A></B></TD>
<TD>Convert between numeric types,  convert any field to a string,
  or convert from a string to a scalar field.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/epics/pvData/pv/Field.html" title="interface in org.epics.pvData.pv">Field</A></B></TD>
<TD>Interface for field reflection.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/epics/pvData/pv/FieldCreate.html" title="interface in org.epics.pvData.pv">FieldCreate</A></B></TD>
<TD>Interface for creating introspection interfaces.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/epics/pvData/pv/PVArray.html" title="interface in org.epics.pvData.pv">PVArray</A></B></TD>
<TD>Base interface for array data.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/epics/pvData/pv/PVAuxInfo.html" title="interface in org.epics.pvData.pv">PVAuxInfo</A></B></TD>
<TD>Auxiliary information for a field.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/epics/pvData/pv/PVBoolean.html" title="interface in org.epics.pvData.pv">PVBoolean</A></B></TD>
<TD>get/put boolean data</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/epics/pvData/pv/PVBooleanArray.html" title="interface in org.epics.pvData.pv">PVBooleanArray</A></B></TD>
<TD>get/put a boolean array.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/epics/pvData/pv/PVByte.html" title="interface in org.epics.pvData.pv">PVByte</A></B></TD>
<TD>get/put byte data.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/epics/pvData/pv/PVByteArray.html" title="interface in org.epics.pvData.pv">PVByteArray</A></B></TD>
<TD>Get/put a byte array.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/epics/pvData/pv/PVDatabase.html" title="interface in org.epics.pvData.pv">PVDatabase</A></B></TD>
<TD>IOCDB (Input/Output Controller Database).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/epics/pvData/pv/PVDataCreate.html" title="interface in org.epics.pvData.pv">PVDataCreate</A></B></TD>
<TD>Create PVField field implementations.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/epics/pvData/pv/PVDouble.html" title="interface in org.epics.pvData.pv">PVDouble</A></B></TD>
<TD>Get/put double data</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/epics/pvData/pv/PVDoubleArray.html" title="interface in org.epics.pvData.pv">PVDoubleArray</A></B></TD>
<TD>Get/put a double array.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/epics/pvData/pv/PVField.html" title="interface in org.epics.pvData.pv">PVField</A></B></TD>
<TD>PVField is the base class for each PVData field.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/epics/pvData/pv/PVFloat.html" title="interface in org.epics.pvData.pv">PVFloat</A></B></TD>
<TD>Get/put float data.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/epics/pvData/pv/PVFloatArray.html" title="interface in org.epics.pvData.pv">PVFloatArray</A></B></TD>
<TD>Get/put a float array.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/epics/pvData/pv/PVInt.html" title="interface in org.epics.pvData.pv">PVInt</A></B></TD>
<TD>Get/put int data.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/epics/pvData/pv/PVIntArray.html" title="interface in org.epics.pvData.pv">PVIntArray</A></B></TD>
<TD>Get/put a int array.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/epics/pvData/pv/PVListener.html" title="interface in org.epics.pvData.pv">PVListener</A></B></TD>
<TD>DB listener interface.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/epics/pvData/pv/PVLong.html" title="interface in org.epics.pvData.pv">PVLong</A></B></TD>
<TD>Get/put long data.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/epics/pvData/pv/PVLongArray.html" title="interface in org.epics.pvData.pv">PVLongArray</A></B></TD>
<TD>Get/put a long array.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/epics/pvData/pv/PVRecord.html" title="interface in org.epics.pvData.pv">PVRecord</A></B></TD>
<TD>PVRecord interrace.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/epics/pvData/pv/PVScalar.html" title="interface in org.epics.pvData.pv">PVScalar</A></B></TD>
<TD>PVScalar extends PVField for a scalar field.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/epics/pvData/pv/PVShort.html" title="interface in org.epics.pvData.pv">PVShort</A></B></TD>
<TD>Get/put short data.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/epics/pvData/pv/PVShortArray.html" title="interface in org.epics.pvData.pv">PVShortArray</A></B></TD>
<TD>Get/put a short array.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/epics/pvData/pv/PVString.html" title="interface in org.epics.pvData.pv">PVString</A></B></TD>
<TD>Get/put string data.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/epics/pvData/pv/PVStringArray.html" title="interface in org.epics.pvData.pv">PVStringArray</A></B></TD>
<TD>Get/put a String array.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/epics/pvData/pv/PVStructure.html" title="interface in org.epics.pvData.pv">PVStructure</A></B></TD>
<TD>PVStructure interface.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/epics/pvData/pv/Requester.html" title="interface in org.epics.pvData.pv">Requester</A></B></TD>
<TD>Base interface for requesters.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/epics/pvData/pv/Scalar.html" title="interface in org.epics.pvData.pv">Scalar</A></B></TD>
<TD>Reflection interface for a scalar field.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/epics/pvData/pv/Serializable.html" title="interface in org.epics.pvData.pv">Serializable</A></B></TD>
<TD>Base interface for serializaion.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/epics/pvData/pv/Structure.html" title="interface in org.epics.pvData.pv">Structure</A></B></TD>
<TD>Reflection interface for structure field.</TD>
</TR>
</TABLE>
&nbsp;

<P>

<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Class Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/epics/pvData/pv/BooleanArrayData.html" title="class in org.epics.pvData.pv">BooleanArrayData</A></B></TD>
<TD>Class required by get/put PVBooleanArray methods.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/epics/pvData/pv/ByteArrayData.html" title="class in org.epics.pvData.pv">ByteArrayData</A></B></TD>
<TD>Class required by get/put PVByteArray methods.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/epics/pvData/pv/DoubleArrayData.html" title="class in org.epics.pvData.pv">DoubleArrayData</A></B></TD>
<TD>Class required by get/put PVDoubleArray methods.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/epics/pvData/pv/FloatArrayData.html" title="class in org.epics.pvData.pv">FloatArrayData</A></B></TD>
<TD>Class required by get/put PVFloatArray methods.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/epics/pvData/pv/IntArrayData.html" title="class in org.epics.pvData.pv">IntArrayData</A></B></TD>
<TD>Class required by get/put PVIntArray methods.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/epics/pvData/pv/LongArrayData.html" title="class in org.epics.pvData.pv">LongArrayData</A></B></TD>
<TD>Class required by get/put PVLongArray methods.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/epics/pvData/pv/ShortArrayData.html" title="class in org.epics.pvData.pv">ShortArrayData</A></B></TD>
<TD>Class required by get/put PVShortArray methods.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/epics/pvData/pv/StringArrayData.html" title="class in org.epics.pvData.pv">StringArrayData</A></B></TD>
<TD>Class required by get/put PVStringArray methods.</TD>
</TR>
</TABLE>
&nbsp;

<P>

<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Enum Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/epics/pvData/pv/MessageType.html" title="enum in org.epics.pvData.pv">MessageType</A></B></TD>
<TD>Types for messages.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/epics/pvData/pv/ScalarType.html" title="enum in org.epics.pvData.pv">ScalarType</A></B></TD>
<TD>Process Variable Scalar Data Type.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/epics/pvData/pv/Type.html" title="enum in org.epics.pvData.pv">Type</A></B></TD>
<TD>Process Variable Data Type.</TD>
</TR>
</TABLE>
&nbsp;

<P>
<A NAME="package_description"><!-- --></A><H2>
Package org.epics.pvData.pv Description
</H2>

<P>
<h1 style="text-align: center">EPICS PVData: pv<br />
package: org.epics.pvData.pv<br />
2009.02.13</h1>
CONTENTS 

<div class="toc">
<ul>
  <li><a href="#Overview">Overview</a></li>
  <li><a href="#Process">Process Variable Reflection</a> 
    <ul>
      <li><a href="#Type">Type</a></li>
      <li><a href="#Reflection">Reflection</a></li>
    </ul>
  </li>
  <li><a href="#PVField">PVField - Data Interfaces</a> 
    <ul>
      <li><a href="#PVField1">PVField</a></li>
      <li><a href="#Requester">Requester</a></li>
      <li><a href="#PVAuxInfo">PVAuxInfo</a></li>
      <li><a href="#PVListener">PVListener</a></li>
      <li><a href="#PVScalar">PVScalar and extensions</a></li>
      <li><a href="#Primitive">Primitive PVField types</a></li>
      <li><a href="#PVString">PVString</a></li>
      <li><a href="#PVArray">PVArray and Extensions</a> 
        <ul>
          <li><a href="#PVArray1">PVArray</a></li>
          <li><a href="#PVArray2">PVArray Extensions</a></li>
          <li><a href="#Complete">Complete set of PVArray Extensions</a></li>
        </ul>
      </li>
      <li><a href="#PVStructur">PVStructure</a></li>
      <li><a href="#PVRecord">PVRecord</a> 
        <ul>
          <li><a href="#Record">Record Locking</a></li>
        </ul>
      </li>
      <li><a href="#PVDataCrea">PVDataCreate</a></li>
      <li><a href="#PVDatabase">PVDatabase</a></li>
    </ul>
  </li>
  <li><a href="#Convert">Convert</a></li>
  <li><a href="#Examples">Examples</a> 
    <ul>
      <li><a href="#Accessing">Accessing PVData</a></li>
      <li><a href="#Creating">Creating PVData</a></li>
    </ul>
  </li>
</ul>
</div>
<hr />

<h2 style="text-align: center" id="Overview">Overview</h2>
<hr />

<p>This package has the complete set of enum, interface, and class
definitions that describe PVData. The implementation is provided in package
org.epics.pvData.factory.</p>

<p>A PVDatabase consists of a set of PVRecords. Each PVRecord has a unique
record name and is the top level PVStructure, which is a structured set of
PVFields. A PVRecord can be:</p>
<dl>
  <dt>locked</dt>
    <dd>Whenever a record is accessed it can be locked. The JavaIOC requires
      that a record be locked whenever it is accessed.</dd>
  <dt>monitored</dt>
    <dd>Any code can register to be called whenever the data for a field is
      modified. If the code listens for changes to a structure field it is
      notified whenever any scalar or array field in the structure is
      modified. PVField provides a method postPut, which must be called by
      the code that calls the put method of the PVField. Note the caller must
      call postPut because for array fields the array might be written in
      chunks. Only the caller knows when it is done.</dd>
  <dt>a message source</dt>
    <dd>Every PVField has a method message, which can be called by any code
      that has access to the PVField. Code can register to be called whenever
      a message is generated.</dd>
</dl>
<hr />

<h2 style="text-align: center" id="Process">Process Variable Reflection</h2>
<hr />

<p>Given a pvname, which consists of a record name and field name, it is
possible to introspect the field without requiring access to data. The
reflection and data interfaces are separate because the data may not be
available. For example when a client connects to a PV, the client library can
obtain the reflection information without obtaining any data. Only when a
client issues an I/O request will data be available. This separation is
especially important for arrays and structures so that a client can discover
the type without requiring that a large array or structure be transported
over the network.</p>

<h3 id="Type">Type</h3>

<p>The types are defined by the Java definitions:</p>
<pre>    enum Type {
        scalar,
        scalarArray,
        structure
    }

    enum ScalarType {
        pvBoolean,
        pvByte, pvShort, pvInt, pvLong,
        pvFloat,pvDouble,
        pvString;

        //Convenience methods
        public boolean isInteger();   // pvByte,...,pvLong
        public boolean isNumeric();    // pvByte,...pvDouble
        public boolean isPrimitive();  // pvBoolean,...pvDouble
        public static ScalarType getScalarType(String type);
    }</pre>

<h3 id="Reflection">Reflection</h3>

<p>This section defines the complete set of Java PV reflection interfaces.</p>
<pre>    
    interface Serializable {
        void serialize(ByteBuffer buffer);
        int getSerializationSize();
        void deserialize(ByteBuffer buffer);
    }

    interface Field extends Serializable{
        String getFieldName();
        Type getType();
        String toString();
        String toString(int indentLevel);
    } 

    interface Scalar extends Field {
        ScalarType getScalarType();
    }

    interface Array extends Field{
        ScalarType getElementType();
    }

    interface Structure extends Field{
        String[] getFieldNames();
        Field getField(String fieldName);
        int getFieldIndex(String fieldName);
        Field[] getFields();
    }

    interface FieldCreate {
        Scalar createScalar(String fieldName,ScalarType scalarType);
        Array createArray(String fieldName,ScalarType elementType);
        Structure createStructure(String fieldName, Field[] field);
    }</pre>

<p>The above definitions support the following:</p>
<dl>
  <dt>Serializable</dt>
    <dd>A Field can be serialized.</dd>
  <dt>Field</dt>
    <dd>A field: 
      <dl>
        <dt>Has a name.</dt>
        <dt>Has a Type.</dt>
        <dt>Can be converted to a string.</dt>
      </dl>
    </dd>
  <dt>Scalar</dt>
    <dd>A scalar has a scalarType</dd>
  <dt>Array</dt>
    <dd>The element type is a scalarType</dd>
  <dt>Structure</dt>
    <dd>Has fields that can be any of the supported types.</dd>
  <dt>FieldCreate</dt>
    <dd>This is an interface that provides methods to create introspection
      interfaces. A factory is provides to create FieldCreate.</dd>
</dl>
<hr />

<h2 style="text-align: center" id="PVField">PVField - Data Interfaces</h2>
<hr />

<p>This section defines the Java Interfaces for accessing the data within a
PV record.</p>

<h3 id="PVField1">PVField</h3>

<p>PVField is the base interface for accessing data. Every field of every
structure of every record instance has a PVField associated with it. A
structure and a record also has an associated PVField.</p>
<pre>    interface PVField extends Serializable, Requester {
        PVAuxInfo getPVAuxInfo();
        boolean isMutable();
        void setMutable(boolean value);
        String getFullFieldName();
        String getFullName();
        Field getField();
        PVStructure getParent();
        PVRecord getPVRecord();
        void replacePVField(PVField newPVField);
        boolean addListener(PVListener pvListener);
        void removeListener(PVListener pvListener);
        void postPut();
        String toString();
        String toString(int indentLevel);
    }</pre>

<p>where</p>
<dl>
  <dt>Requester</dt>
    <dd>PVField extends Requester which is described in the next
    sub-section.</dd>
  <dt>getPVAuxInfo</dt>
    <dd>Get the PVAuxInfo for this field. PVAuxInfo is described below.</dd>
  <dt>isMutable</dt>
    <dd>Can the field be changed.</dd>
  <dt>setMutable</dt>
    <dd>Specify if the field be changed.</dd>
  <dt>getFullFieldName</dt>
    <dd>Get the full field name. This returns a name in the form "name.name
      ...". </dd>
  <dt>getFullName</dt>
    <dd>Get the full name. This returns a name in the form "recordName.name
      ...".</dd>
  <dt>getField</dt>
    <dd>Get the reflection interface for the data.</dd>
  <dt>getParent</dt>
    <dd>Get the interface for the parent or null if this is the PVRecord
      itself.</dd>
  <dt>getPVRecord</dt>
    <dd>Get the interface for the record that contains this field. This can
      be null.</dd>
  <dt>replacePVField</dt>
    <dd>Replace this PVField. This is called support code that wants to
      replace the default implementation of a data field with it's own
      implementation.</dd>
  <dt>addListener</dt>
    <dd>Add A PVListener to this field. Whenever this field or any subfield
      if this field is modified the listener will be notified. PVListener is
      described below. Before a listener can call addListener it must first
      call PVRecord.registerListener. </dd>
  <dt>removeListener</dt>
    <dd>Remove a PVListener.</dd>
  <dt>postPut</dt>
    <dd>Post a change to a field. This must be called by any code that
      directly calls the put method of a field. In particular the
      ConvertFactory calls this.</dd>
  <dt>toString</dt>
    <dd>Converts the field data to a string. This is mostly for debugging
      purposes.</dd>
</dl>

<h3 id="Requester">Requester</h3>

<p>A PVField extends Requester. Requester is present so that when database
errors are found there is someplace to send a message. As will be seen below,
PVRecord provides methods to register message requesters.</p>
<pre>    enum MessageType {info,warning,error,fatalError}

    interface Requester {
        String getRequesterName();
        void message(String message, MessageType messageType);
    }</pre>

<p>where</p>
<dl>
  <dt></dt>
  <dt>MessageType</dt>
    <dd>Type of message.</dd>
  <dt>Requester</dt>
    <dd>The default implementation is: 
      <ul>
        <li>getRequesterName<br />
          This is the full field name concatenated to the record name.</li>
        <li>message<br />
          For the default implementation, PVField prepends the full field
          name to the message and calls PVRecord.message. The default
          implementation for PVRecord either displays the message on stdout
          or stderr or gives the message to message requsters.</li>
      </ul>
    </dd>
</dl>

<h3 id="PVAuxInfo">PVAuxInfo</h3>

<p>AuxInfo (Auxillary Information) is information about a field that is
application specific. It will not be available outside the application that
implements the database. In particular it will not be made available to
Channel Access. It is used by the database itself to override the default
implementation of fields. The JavaIOC uses it for attaching support code.
Database Configuration and other tools can use it for configuration
information. Each Field and each PVField can have have an arbitrary number of
auxInfos. An auxInfo is a (key,PVScalar) pair where key is a string.</p>
<pre>    public interface PVAuxInfo {
        PVField getPVField();
        PVScalar createInfo(String key,ScalarType scalarType);
        Map&lt;String,PVScalar&gt; getInfos();
        PVScalar getInfo(String key);
        String toString();
        String toString(int indentLevel);
    }</pre>

<p>where</p>
<dl>
  <dt>getPVField</dt>
    <dd>Get the PVField to which this PVAuxInfo is attached.</dd>
  <dt>createInfo</dt>
    <dd>Create a new PVScalar of type scalarType.</dd>
  <dt>getInfos</dt>
    <dd>Get a map of all the auxInfos.</dd>
  <dt>getInfo</dt>
    <dd>Get the PVScalar with the specified key.</dd>
  <dt>toString</dt>
    <dd>Print all the auxInfos</dd>
</dl>

<h3 id="PVListener">PVListener</h3>

<p>A PVlistener can attach itself to any field or fields of a record. It will
be notified whenever a put is issued to the field, i.e. the field is
modified. If the field is a structure then the PVListener is notified
whenever that field or any subfield is modified.</p>
<pre>    public interface PVListener {
        void dataPut(PVField pvField);
        void dataPut(PVStructure requested,PVField pvField);
        void beginGroupPut(PVRecord pvRecord);
        void endGroupPut(PVRecord pvRecord);
        void unlisten(PVRecord pvRecord);
    }</pre>

<p>where</p>
<dl>
  <dt>dataPut(PVField pvField)</dt>
    <dd>pvField has been modified.</dd>
  <dt>dataPut(PVStructure requested,PVField pvField)</dt>
    <dd>pvField has been modified. Requested is the field to which the
      requester issued a pvField.addListener.</dd>
  <dt>beginGroup</dt>
    <dd>A related set of changes is being started.</dd>
  <dt>endGroup</dt>
    <dd>A related set of changes is done.</dd>
  <dt>unlisten</dt>
    <dd>The PVLister is being removed from the record. This is called when
      the record is being destroyed or when the record structure (not the
      data values) is being changed.</dd>
</dl>

<h3 id="PVScalar">PVScalar and extensions</h3>
<pre>    interface PVScalar extends PVField {
        Scalar getScalar();
    }</pre>

<h3 id="Primitive">Primitive PVField types</h3>

<p>The interfaces for primitive data types are:</p>
<pre>    interface PVBoolean extends PVScalar {
        boolean get();
        void put(boolean value);
    }

    interface PVByte extends PVScalar {
        byte get();
        void put(byte value);
    }

    interface PVShort extends PVScalar {
        short get();
        void put(short value);
    }

    interface PVInt extends PVScalar {
        int get();
        void put(int value);
    }

    interface PVLong extends PVScalar {
        long get();
        void put(long value);
    }

    interface PVFloat extends PVScalar {
        float get();
        void put(float value);
    }

    interface PVDouble extends PVScalar {
        double get();
        void put(double value);
    }</pre>

<h3 id="PVString">PVString</h3>

<p>The interface for string is:</p>
<pre>    interface PVString extends PVScalar {
        String get();
        void put(String value);
    }</pre>

<h3 id="PVArray">PVArray and Extensions</h3>

<h4 id="PVArray1">PVArray</h4>

<p><span style="font-family: courier">PVArray</span> is the base interface
for all the other PV Array interfaces. It extends PVField and provides the
additional methods:</p>
<pre>    interface PVArray extends PVField {
        Array getArray();
        int getLength();
        void setLength(int len);
        int getCapacity();
        void setCapacity(int len);
        boolean isCapacityMutable();
        void setCapacityMutable(boolean isMutable);
    }</pre>
<dl>
  <dt>getArray</dt>
    <dd>Return the Array introspection interface.</dd>
  <dt>getLength</dt>
    <dd>Get the current length. This is less that or equal to the
    capacity.</dd>
  <dt>setLength</dt>
    <dd>Set the length. If the PVField is not mutable then an exception is
      thrown. If this is greater than the capacity setCapacity is called.</dd>
  <dt>getCapacity</dt>
    <dd>Get the capacity, i.e. this is the sized of the underlying data
    array.</dd>
  <dt>setCapacity</dt>
    <dd>Set the capacity. The semantics are implementation dependent but
      typical semantics are as follows: If the capacity is not mutable an
      exception is thrown. A new data array is created and data is copied
      from the old array to the new array. </dd>
  <dt>isCapacityMutable</dt>
    <dd>Is the capacity mutable</dd>
  <dt>setCapacityMutable</dt>
    <dd>Specify if the capacity can be changed.</dd>
</dl>

<h4 id="PVArray2">PVArray Extensions</h4>

<p>The interface for each array type has get and put methods which have the
same arguments except for the data type. For example PVDoubleArray is:</p>
<pre>    public class DoubleArrayData {
        public double[] data;
        public int offset;
    }
    interface PVDoubleArray extends PVArray {
        int get(int offset, int len, DoubleArrayData data);
        int put(int offset, int len, double[]from, int fromOffset);
    }</pre>

<p>Get "exposes" it's internal array by setting data.data and data.offset.
The caller is responsible for copying the array elements. This violates the
principle that objects should not expose their internal data but is done for
efficency. For example it makes it possible to copy between arrays with
identical element types via a call to System.arraycopy without requiring an
intermediate array.</p>

<p>Both get and put return the number of elements actually transfered. The
arguments are:</p>
<dl>
  <dt>offset</dt>
    <dd>The offset in the PV array.</dd>
  <dt>len</dt>
    <dd>The maximum number of elements to transfer. The number actually
      transfered will be less than or equal to this value.</dd>
  <dt>data</dt>
    <dd>Get sets data.data to it's internal array and data.offset to the
      offset into the array. The caller is responsible for the actual data
      transfer.</dd>
  <dt>from</dt>
    <dd>The array from which the data is taken. This array is supplied by the
      caller</dd>
  <dt>fromOffset</dt>
    <dd>The offset in <span style="font-family: courier;">from</span></dd>
</dl>

<p>The caller must be prepared to make multiple calls to retrieve or put an
entire array. A caller should accept or put partial arrays. For example the
following reads an entire array:</p>
<pre>    double[] getArray(PVDoubleArray pv)
    {
        int len = pv.getLength();
        double[] storage = new double[len];
        DoubleArrayData data = new DoubleArrayData();
        int offset = 0;
        while(offset &lt; len) {
            int num = pv.get(offset,(len-offset),data);
            System.arraycopy(data.data,data.offset,storage,offset,num);
            offset += num;
        }
        return storage;
    } </pre>

<h4 id="Complete">Complete set of PVArray Extensions</h4>
<pre>    public class BooleanArrayData {
        public boolean[] data;
        public int offset;
    }
    interface PVBooleanArray extends PVArray {
        int get(int offset, int len, BooleanArrayData data);
        int put(int offset, int len, boolean[]from, int fromOffset);
    }

    public class ByteArrayData {
        public byte[] data;
        public int offset;
    }
    interface PVByteArray extends PVArray {
        int get(int offset, int len, ByteArrayData data);
        int put(int offset, int len, byte[]from, int fromOffset);
    }

    public class ShortArrayData {
        public short[] data;
        public int offset;
    }
    interface PVShortArray extends PVArray {
        int get(int offset, int len, ShortArrayData data);
        int put(int offset, int len, short[]from, int fromOffset);
    }

    public class IntArrayData {
        public int[] data;
        public int offset;
    }
    interface PVIntArray extends PVArray {
        int get(int offset, int len, IntArrayData data);
        int put(int offset, int len, int[]from, int fromOffset);
    }

    public class LongArrayData {
        public long[] data;
        public int offset;
    }
    interface PVLongArray extends PVArray {
        int get(int offset, int len, LongArrayData data);
        int put(int offset, int len, long[]from, int fromOffset);
    }

    public class FloatArrayData {
        public float[] data;
        public int offset;
    }
    interface PVFloatArray extends PVArray {
        int get(int offset, int len, FloatArrayData data);
        int put(int offset, int len, float[]from, int fromOffset);
    }

    public class DoubleArrayData {
        public double[] data;
        public int offset;
    }
    interface PVDoubleArray extends PVArray {
        int get(int offset, int len, DoubleArrayData data);
        int put(int offset, int len, double[]from, int fromOffset);
    }

    public class StringArrayData {
        public String[] data;
        public int offset;
    }
    interface PVStringArray extends PVArray {
        int get(int offset, int len, StringArrayData data);
        int put(int offset, int len, String[]from, int fromOffset);
    }</pre>

<h3 id="PVStructur">PVStructure</h3>

<p>The interface for a structure is:</p>
<pre>    interface PVStructure extends PVField {
        Structure getStructure();
        PVField[] getPVFields();
        PVField getSubField(String fieldName);
        void replacePVField(String fieldName,PVField newPVField);
        void appendPVField(PVField pvField);
        void postPut(PVField pvSubField);
        // the following are convenience methods
        PVBoolean getBooleanField(String fieldName);
        PVByte getByteField(String fieldName);
        PVShort getShortField(String fieldName);
        PVInt getIntField(String fieldName);
        PVLong getLongField(String fieldName);
        PVFloat getFloatField(String fieldName);
        PVDouble getDoubleField(String fieldName);
        PVString getStringField(String fieldName);
        PVStructure getStructureField(String fieldName,String structureName);
        PVArray getArrayField(String fieldName,Type elementType);
    }</pre>

<p>where</p>
<dl>
  <dt>getStructure</dt>
    <dd>Get the introspection interface for the structure.</dd>
  <dt>getPVFields</dt>
    <dd>Returns the array of subfields. The set of subfields must all have
      different field names.</dd>
  <dt>getSubField</dt>
    <dd>Get a subField of a field. For a PVStructure a non-null result is
      returned if fieldName is a field of the PVStructure. The fieldName can
      be of the form name.name...</dd>
  <dt>replacePVField</dt>
    <dd>Replace a subfield of a PVStructure.</dd>
  <dt>appendPVField</dt>
    <dd>Append pvField to the end of this PVStructure.</dd>
  <dt>postPut</dt>
    <dd>post a put to a subfield of this structure. It does not have to be a
      direct subfield.</dd>
  <dt>getBooleanField</dt>
    <dd>Look for fieldName. If found and it has the correct type return the
      interface. This and the following methods are convenience methods that
      allow a user to get the interface to a subfield without requiring
      introspection. fieldName can be of the form name.name...</dd>
  <dt>getByteField</dt>
    <dd>Look for fieldName. If found and it has the correct type return the
      interface.</dd>
  <dt>getShortField</dt>
    <dd>Look for fieldName. If found and it has the correct type return the
      interface.</dd>
  <dt>getIntField</dt>
    <dd>Look for fieldName. If found and it has the correct type return the
      interface.</dd>
  <dt>getLongField</dt>
    <dd>Look for fieldName. If found and it has the correct type return the
      interface.</dd>
  <dt>getFloatField</dt>
    <dd>Look for fieldName. If found and it has the correct type return the
      interface.</dd>
  <dt>getDoubleField</dt>
    <dd>Look for fieldName. If found and it has the correct type return the
      interface.</dd>
  <dt>getStringField</dt>
    <dd>Look for fieldName. If found and it has the correct type return the
      interface.</dd>
  <dt>getStructureField</dt>
    <dd>Look for fieldName. If found and it has the correct type return the
      interface.</dd>
  <dt>getArrayField</dt>
    <dd>Look for fieldName. If found and it has the correct type return the
      interface.</dd>
</dl>

<h3 id="PVRecord">PVRecord</h3>

<p>Each PVField is a field within a PVRecord:</p>
<pre>    interface PVRecord extends PVStructure {
        PVStructure getPVStructure();
        String getRecordName();
        void message(String message, MessageType messageType);
        void addRequester(Requester requester);
        void removeRequester(Requester requester);
        void lock();
        void unlock();
        void lockOtherRecord(PVRecord otherRecord);
        void beginGroupPut();
        void endGroupPut();
        void registerListener(PVListener pvListener);
        void unregisterListener(PVListener pvListener);
        boolean isRegisteredListener(PVListener pvListener);
        void removeEveryListener();
    }</pre>

<p>where</p>
<dl>
  <dt>getPVStructure</dt>
    <dd>Get the top level PVStructure for the record.</dd>
  <dt>getRecordName</dt>
    <dd>Returns the record name.</dd>
  <dt>message</dt>
    <dd>This can be called any code that has access to the record
    instance.</dd>
  <dt>addRequester</dt>
    <dd>Add a requester to receive messages.</dd>
  <dt>removeRequester</dt>
    <dd>Remove a message requester</dd>
  <dt>lock</dt>
    <dd>Lock the record. See next sub-section.</dd>
  <dt>unlock</dt>
    <dd>Unlock the record.</dd>
  <dt>lockOtherRecord</dt>
    <dd>While code has a record locked, It can also lock another record. If
      the other record is already locked than this record may be temporily
      unlocked and then relocked. The caller must call the unlock merthod of
      the other record when done with it. The implementation prevents
      deadlocks BUT code must not try to lock more than two records at the
      same time or deadlocks can occur.</dd>
  <dt>beginGroupPut</dt>
    <dd>Begin a group of puts. This results in all registered PVListeners
      being called.</dd>
  <dt>endGroupPut</dt>
    <dd>End a group of puts. This results in all registered PVListeners being
      called.</dd>
  <dt>registerListener</dt>
    <dd>Register a PVListener. This must be called before calling
      pvField.addListener.</dd>
  <dt>unregisterListener</dt>
    <dd>Unregister a listener. The listener will also be removed from all
      fields to which it is attached.</dd>
  <dt>isRegisteredListener</dt>
    <dd>Id the PVListener registered?</dd>
  <dt>removeEveryListener</dt>
    <dd>This must be called by any code that is deleting or changing the
      structure of a record.</dd>
</dl>

<h4 id="Record">Record Locking</h4>

<p>Whever code access a record it must be locked. The code for accessing a
record should use the following pattern:</p>
<pre>    pvRecord.lock();
    try {
       // access the record
    } finally {
        pvRecord.unlock();
    }</pre>

<p>Depending on the application, for example the JavaIOC, it may be required
that the thread does not block between lock and unlock.</p>

<h3 id="PVDataCrea">PVDataCreate</h3>

<p>PVDataCreate is an interface that provides methods that create PVField
interfaces. A factory is provided that creates PVDataCreate.</p>
<pre>interface PVDataCreate {
    PVField createPVField(PVStructure parent, Field field);
    PVScalar createPVScalar(PVStructure parent,Scalar scalar);
    PVScalar createPVScalar(PVStructure parent,String fieldName,ScalarType fieldType);
    PVArray createPVArray(PVStructure parent,Array array);
    PVArray createPVArray(PVStructure parent,String fieldName,ScalarType elementType);
    PVStructure createPVStructure(PVStructure parent,String fieldName,
        Field[] fields);
    PVStructure createPVStructure(PVStructure parent,String fieldName,
        PVStructure structToClone);
    PVStructure createPVStructure(PVStructure parent,String fieldName,
        PVDatabase pvDatabase,String structureName);
    PVRecord createPVRecord(String recordName,
        Field[] fields);
    PVRecord createPVRecord(String recordName,
        PVStructure structToClone);
    PVRecord createPVRecord(String recordName,
        PVDatabase pvDatabase,String structureName);
}</pre>
where 
<dl>
  <dt style="font-family: courier;">createPVField</dt>
    <dd>The PVField is created reusing the Field interface.</dd>
  <dt style="font-family: courier;">createPVScalar</dt>
    <dd>Creates an instance of a PVScalar.</dd>
  <dt style="font-family: courier;">createPVArray</dt>
    <dd>Create an instance of a PVArray.</dd>
  <dt style="font-family: courier;">createPVStructure</dt>
    <dd>Create an instance of a PVStructure. Three methods are provided. The
      first uses a Field array to initialize the sub-fields. The second
      initializes the subfields by cloning the fields contained in
      structToClone. The newly created sub-fields will have the same values
      and auxInfos as the original. If structToClone is null then the new
      structure is initialized to have 0 sub-fields. The last method clones
      the fields from a PVStructure obtained from a PVDatabase. </dd>
  <dt style="font-family: courier;">createPVRecord</dt>
    <dd>Create a record instance. Like createPVStructure, three methods are
      provided with semantics just like createPVStructure.</dd>
</dl>

<h3 id="PVDatabase">PVDatabase</h3>

<p>PVDatabase is an interface for accessing a PVData database. </p>

<p>A PVDatabase contains structures and records. Structures provided an easy
way to create an initial set of subfields of a structure field of record
instances. When a structure field of a record is defined as follows:</p>
<pre>    &lt;record name = ... /&gt;
        &lt;!-- other fields --&gt;
        &lt;structure name = "name" type = "structName" /&gt;
        &lt;!-- ... --&gt;
    &lt;/record&gt;</pre>

<p>Then the fields in the structure are initialized with a copy of the fields
in structure "structName". </p>

<p>The interface is:</p>
<pre>    interface PVDatabase extends Requester{
        PVDatabase getMaster();
        String getName();
        void mergeIntoMaster();
        PVRecord findRecord(String name);
        boolean addRecord(PVRecord pvRecord);
        boolean removeRecord(PVRecord pvRecord);
        PVRecord[] getRecords();
        PVStructure findStructure(String name);
        boolean addStructure(PVStructure pvStructure);
        boolean removeStructure(PVStructure pvStructure);
        PVStructure getStructures();
        void message(String message, MessageType messageType);
        void addRequester(Requester requester);
        void removeRequester(Requester requester);
        String[] recordList(String regularExpression);
        String[] structureList(String regularExpression);
        String recordToString(String regularExpression);
        String structureToString(String regularExpression);
    }</pre>

<p>where</p>
<dl>
  <dt>getMaster</dt>
    <dd>Get the master database. This is just a convenience mthhod.</dd>
  <dt>getName</dt>
    <dd>Get the name of the database.</dd>
  <dt>mergeIntoMaster</dt>
    <dd>Merge this database into the master database.</dd>
  <dt>findRecord</dt>
    <dd>Find a record. Null is returned if the record is not in the
    database.</dd>
  <dt>addRecord</dt>
    <dd>Add a record to the database.</dd>
  <dt>removeRecord</dt>
    <dd>Remove a record from the database.</dd>
  <dt>getRecords</dt>
    <dd>Get a array of all the records.</dd>
  <dt>findStructure</dt>
    <dd>Find a structure. Null is returned if the structure is not in the
      database.</dd>
  <dt>addStructure</dt>
    <dd>Add a structure to the database.</dd>
  <dt>removeStructure</dt>
    <dd>Remove a structure from the database.</dd>
  <dt>getStructures</dt>
    <dd>Get a array of all the structures.</dd>
  <dt>message</dt>
    <dd>Report a message. If no listeners are registered the messages are
      sent to System.out (info) or System.err (all other message types). If
      at least one requester is present then the messages are given to the
      requesters without writing to System.out or System.err. If the database
      is the master, the message is put of a queue that is emptied by another
      thread. This messages sent to the master do not block.</dd>
  <dt>addRequester</dt>
    <dd>Add a requester to receive messages.</dd>
  <dt>removeRequester</dt>
    <dd>Remove a requester.</dd>
  <dt>recordList</dt>
    <dd>Get a list of all records with names that match a regular
    expression.</dd>
  <dt>structureList</dt>
    <dd>Get a list of all structures with names that match a regular
      expression.</dd>
  <dt>recordToString</dt>
    <dd>Get a dump of all records with names that match a regular
    expression.</dd>
  <dt>structureToString</dt>
    <dd>Get a dump of all structures with names that match a regular
      expression.</dd>
</dl>
<hr />

<h2 style="text-align: center" id="Convert">Convert</h2>
<hr />

<p>IMPORTANT: The from methods all call postPut after calling the appropriate
put method. </p>

<p>This section describes the supported conversions between data types.</p>
<ul>
  <li>All supported types can be converted to a string. If you ask for a 100
    megabyte array to be converted to a string expect a lot of output.</li>
  <li>Conversion from a string to a scalar type.</li>
  <li>Conversion from an array of strings to an array of scalar types.</li>
  <li>Copy between the following types of scalar PVs 
    <ul>
      <li>Numeric type to another numeric type</li>
      <li>Both have the same type.</li>
      <li>Either is a string</li>
    </ul>
  </li>
  <li>Copy between PVArrays that satisfy one of the following. 
    <ul>
      <li>Numeric to numeric</li>
      <li>Both have the same type.</li>
      <li>Either is a string.</li>
    </ul>
  </li>
  <li>Conversions between numeric scalar types.</li>
  <li>Conversions between arrays of numeric type.</li>
  <li>Conversion between compatible structures.</li>
</ul>
<pre>    interface Convert {
        String getString(PVField pv, int indentLevel);
        String getString(PVField pv);
        void fromString(PVField pv,String from);
        int fromStringArray(PVField pv,
             int offset, int len, String[]from, int fromOffset);
        int toStringArray(PVArray pv,
             int offset, int len, String[]to, int toOffset);
        boolean isCopyScalarCompatible(Field from, Field to);
        void copyScalar(PVField from, PVField to);
        boolean isCopyArrayCompatible(Array from, Array to);
        int copyArray(PVArray from, int offset, int len, PVArray to, int toOffset);
        boolean isCopyStructureCompatible(Structure from, Structure to);
        void copyStructure(PVStructure from, PVStructure to);
        // For the following the pv Type must be PVByte, ...., PVDouble
        byte toByte(PVField pv);
        short toShort(PVField pv);
        int   toInt(PVField pv);
        long  toLong(PVField pv);
        float toFloat(PVField pv);
        double toDouble(PVField pv);
        void fromByte(PVField pv, byte from);
        void  fromShort(PVField pv, short from);
        void  fromInt(PVField pv, int from);
        void  fromLong(PVField pv, long from);
        void  fromFloat(PVField pv, float from);
        void  fromDouble(PVField pv, double from);
// For the following the element type must be pvByte, ...., pvDouble
        int toByteArray(PVArray pv,
            int offset, int len, byte[]to, int toOffset);
        int toShortArray(PVArray pv,
            int offset, int len, short[]to, int toOffset);
        int toIntArray(PVArray pv,
            int offset, int len, int[]to, int toOffset);
        int toLongArray(PVArray pv,
            int offset, int len, long[]to, int toOffset);
        int toFloatArray(PVArray pv,
            int offset, int len, float[]to, int toOffset);
        int toDoubleArray(PVArray pv,
            int offset, int len, double[]to, int toOffset);
        int fromByteArray(PVArray pv,
            int offset, int len, byte[]from, fromOffset);
        int fromShortArray(PVArray pv,
            int offset, int len, short[]from, fromOffset);
        int fromIntArray(PVArray pv,
            int offset, int len, int[]from, fromOffset);
        int fromLongArray(PVArray pv,
            int offset, int len, long[]from, fromOffset);
        int fromFloatArray(PVArray pv,
            int offset, int len, float[]from, fromOffset);
        int fromDoubleArray(PVArray pv,
            int offset, int len, double[]from, fromOffset);
        void newLine(StringBuilder builder, int indentLevel);
    }</pre>

<p>The array methods all return the number of elements copied or converted.
This can be less than <span style="font-family: courier;">len</span> if the
PVField array contains less than len elements.</p>

<p><span style="font-family: courier;">newLine</span> is a convenience method
for code that implements <span style="font-family: courier;">toString</span>
It generates a newline and inserts blanks at the beginning of the newline.</p>
<hr />

<h2 style="text-align: center" id="Examples">Examples</h2>
<hr />

<h3 id="Accessing">Accessing PVData</h3>

<p>Assume that code wants to access two fields from a PVRecord:</p>
<dl>
  <dt>value</dt>
    <dd>Must be a PVDouble.</dd>
  <dt>timeStamp</dt>
    <dd>Just look for field with this name.</dd>
</dl>

<p>The following code uses introspection to get the desired information.</p>
<pre>String getValueAndTimeStamp(String recordName) {
    PVDatabase master = PVDatabaseFactory.getMaster():
    PVRecord pvRecord = master.findRecord(recordName);
    if(pvRecord==null) {
       return "record not found";
   }
   PVStructure pvStructure = pvRecord.getPVStructure();
   PVField valuePV = pvStructure.getSubField("value");
   if(valuePV==null) {
       return "value field not found";
   }
   if(valuePV.getField.getType!=Type.scalar) {
       return "value field is not a scalar";
   }
   Scalar scalar = (Scalar)valuePV.getField();
   if(scalar.getScalarType!=ScalarType.pvDouble) {
       return "value field is not a double";
   }
   PVDouble pvDouble = (PVDouble)valuePV;
   PVField timeStampPV = pvStructure.getSubField("timeStamp");
   if(timeStampPV==null) {
       return "timeStamp field not found";
   }
   double value = valuePV.get();
   return value + " timeStamp " + timeStampPV.toString();
}</pre>

<h3 id="Creating">Creating PVData</h3>

<p>Example of creating a scalar field.</p>
<pre>    PVDataCreate pvDataCreate = PVDataFactory.getPVDataCreate();
    PVDouble pvValue = pvDataCreate.createPVScalar(null,"value",ScalarType.pvDouble);</pre>

<p>Create a structure and put it into the master database.</p>
<pre>    PVDatabase master = PVDatabaseFactory.getMaster():
    FieldCreate fieldCreate = FieldFactory.getFieldCreate();
    PVDataCreate pvDataCreate = PVDataFactory.getPVDataCreate();

    Field[] fields = new Field[2];
    fields[0] = fieldCreate.createScalar("secondsSinceEpoch",ScalarType.pvLong);
    fields[1] = fieldeCreate.createScalar("nanoSeconds",ScalarType.pvInt);
    PVStructure pvStructure = pvDataCreate.createPVStructure(
        null,"timeStamp",fields);
    master.addStructure(pvStructure);</pre>

<p>Create a PVRecord that has a value field and a timeStamp. Use the
structure created in the previous example.</p>
<pre>    Field[] fields = new Field[2];
    fields[0] = fieldCreate.createScalar("value",ScalarType.pvDouble);
    PVStructure pvStructure = master.findStructure("timeStamp");
    fields[1] = fieldCreate.createStructure("timeStamp",pvStructure.getStructure.getFields();
    PVRecord pvRecord = pvDataCreate.createPVRecord("example",fields);</pre>
<P>

<P>
<DL>
</DL>
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Package</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <FONT CLASS="NavBarFont1">Class</FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-use.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../../org/epics/pvData/property/package-summary.html"><B>PREV PACKAGE</B></A>&nbsp;
&nbsp;<A HREF="../../../../org/epics/pvData/test/package-summary.html"><B>NEXT PACKAGE</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../../index.html?org/epics/pvData/pv/package-summary.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="package-summary.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>

</BODY>
</HTML>
