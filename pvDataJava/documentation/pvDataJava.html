<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
      "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="content-type" content="text/html; charset=iso-8859-1" />
  <title>EPICS pvDataJava</title>
    <link rel="stylesheet" type="text/css" href="http://epics-pvdata.sourceforge.net/base.css" />
  <link rel="stylesheet" type="text/css" href="http://epics-pvdata.sourceforge.net/epicsv4.css" />

  <style type="text/css">
  /*<![CDATA[*/
     .about { margin-left: 3em; margin-right: 3em; font-size: .83em}
     table { margin-left: auto; margin-right: auto }
     .diagram { text-align: center; margin: 2.5em 0 }
     span.opt { color: grey }
     span.nterm { font-style:italic }
     span.term { font-family:courier }
     span.user { font-family:courier }
     span.user:before { content:"<" }
     span.user:after { content:">" }
     .nonnorm { font-style:italic }
     p.ed.priv { display: inline; }
     span.ed.priv { display: inline; }
     hr { border: none; background-color: #ccc; color: #ccc; height: 1px }
  /*]]>*/</style>
  <!-- Script that generates the Table of Contents -->
  <script type="text/javascript" src="http://epics-pvdata.sourceforge.net/script/tocgen.js"></script>

</head>
<body>


<div class="head">
<h1>EPICS pvDataJava</h1>

<h2 class="nocount">Release 5.1-DEV - 2017.03.29</h2>

  <dl>
    <dt>Editors:</dt>
    <dd>Marty Kraimer, BNL</dd>
    <dd>Dave Hickin, Diamond</dd>
  </dl>

  <p class="copyright">This product is made available subject to acceptance of the <a
href="http://epics-pvdata.sourceforge.net/LICENSE.html">EPICS open source
license.</a></p>
<hr />  
</div>

<h2 class="nocount">Abstract</h2>

<p>pvDataJava is a computer software package for the efficient 
storage, access, and communication, of structured data. It is specifically the
Java implementation of pvData, which is one part of the set of related products in the EPICS
V4 control system programming environment:<br />
<a href="http://epics-pvdata.sourceforge.net/relatedDocumentsV4.html">relatedDocumentsV4.html</a>
</p>


<h2 class="nocount">Status of this Document</h2>


<p>This is the 29-March-2017 version of the Java implementation of pvData.
</p>
<p>RELEASE_NOTES.md provides changes since the last release.
TODO.md describes things to do before the next release.
</p>


<div id="toc">
<h2 class="nocount" style="page-break-before: always">Table of Contents</h2>
</div>
<div id="contents" class="contents">

<h2>Introduction</h2>

<p>pvData is one of a set of related projects. It describes and implements
data that the other projects support. Thus it is not useful by itself but
understanding pvData is required in order to understand the other projects. The
reader should also become familiar with project pvAccess, which is
located via the same sourceforge site as this project.</p>

<p>
<a href="http://epics-pvdata.sourceforge.net/informative/developerGuide/developerGuide.html">developerGuide</a>
briefly describes a set of application programming interfaces (APIs) for EPICS V4.
It should be read before reading this manual.
</p>


<p>The Java and C++ implementation of pvData implement the same data model but
differ in implementation because of the differences between Java and C++.</p>

<p>pvData is one of a set of related packages in the EPICS V4 core software. It
describes and implements the data management system to which the the other projects
interface.</p>

<p>pvData (Process Variable Data) defines and implements an efficient way to
store, access, and communicate memory resident data structures.</p>
<dl>
  <dt>definition</dt>
    <dd>Package org.epics.pvdata.pv has Java interface definitions that define
      pvData. Although defined with Java syntax they also document what is
      required for implementation in other languages such as C++.</dd>
  <dt>implementation</dt>
    <dd>The set of packages provided by this project provide a complete Java
      implementation of pvData. Project pvAccess is the network support for
      pvData, i.e. it provides a channel access client and server that fully
      support pvData.</dd>
  <dt>efficient</dt>
    <dd>Small memory footprint, low cpu overhead, and concise code base.</dd>
  <dt>data storage</dt>
    <dd>pvData defines separate introspection and data interfaces. The
      introspection interfaces provide access to immutable objects, which
      allows introspection instances to be freely shared. The introspection
      interface for a process variable can be accessed without requiring access
      to the data.</dd>
  <dt>data access</dt>
    <dd>Client code can access pvData via the introspection and data
      interfaces. For "well known" data, e.g. image data, specialized interfaces
      can be provided without requiring any changes to the core software.</dd>
  <dt>data transfer</dt>
    <dd>The separation of introspection and data interfaces allows for
      efficient network data transfer. At connection time introspection
      information can be passed from server to client. Each side can create a
      data instance. The data is transferred between these instances. The data
      in the network buffers does not have to be self describing since each
      side has the introspection information.</dd>
  <dt>memory resident</dt>
    <dd>pvData only defines memory resident data.</dd>
  <dt>structured data</dt>
    <dd>pvData defines data as structures with subfields
      where each each subfield has a name and type.
      The types are defined next.</dd>
</dl>


<h2 >Interface Definitions</h2>

<p>This section gives a <b>brief</b> description of the pvData introspection and data interfaces.
In this section the methods are shown but not described. See org.epics.pvdata.pv below for a
description of each method.</p>

<h3>Types</h3>

<p>The following are the type definitions:</p>
<pre>enum Type {
    scalar,
    scalarArray,
    structure,
    structureArray,
    union_t,
    unionArray;
}</pre>

<p>where</p>
<dl>
  <dt>scalar</dt>
    <dd>A field that has data with one of the <code>ScalarType</code>s.</dd>
  <dt>scalarArray</dt>
    <dd>A field that is an array where each element is the same <code>ScalarType</code>.</dd>
  <dt>structure</dt>
    <dd>A field which has named subfields.</dd>
  <dt>structureArray</dt>
    <dd>A field that is an array of structures where each element has the same
      introspection interface, i.e. each element has the same structure.</dd>
  <dt>union</dt>
    <dd>A union stores a single subfield with a variable type.
     A variant union allows the type to be any type.
     A regular union allows only a fixed set of types
    </dd>
   <dt>unionArray</dt>
    <dd>
    A union array is an array of union fields where each element
    has the same introspection interface.
    Different elements can have different types but each must have
    a type determined by the union interface.
    </dd>
</dl>
<pre>enum ScalarType {
    pvBoolean,
    pvByte,pvShort,pvInt,pvLong,
    pvUByte,pvUShort,pvUInt,pvULong,
    pvFloat,pvDouble,
    pvString;
    // The following are convenience methods
    public boolean isInteger();
    public boolean isUInteger();
    public boolean isNumeric();
    public boolean isPrimitive();
    public static ScalarType getScalarType(String type);
    public String toString();
}</pre>

<p>where</p>
<dl>
  <dt>boolean</dt>
    <dd>true or false</dd>
  <dt>byte</dt>
    <dd>An 8 bit signed byte</dd>
  <dt>short</dt>
    <dd>16 bit signed integer</dd>
  <dt>int</dt>
    <dd>32 bit signed integer</dd>
  <dt>long</dt>
    <dd>64 bit signed integer</dd>
  <dt>ubyte</dt>
    <dd>An 8 bit unsigned byte</dd>
  <dt>ushort</dt>
    <dd>16 bit unsigned integer</dd>
  <dt>uint</dt>
    <dd>32 bit unsigned integer</dd>
  <dt>ulong</dt>
    <dd>64 bit unsigned integer</dd>
  <dt>float</dt>
    <dd>32 bit IEEE float</dd>
  <dt>double</dt>
    <dd>64 bit IEEE float</dd>
  <dt>string</dt>
    <dd>An immutable string. The Java implementation is String. For other
      implementations the network representation must be the same as for Java.
      Note that a string is treated like it is a scaler.</dd>
</dl>
<p><b>NOTE:</b> Java does not support unsigned integers so the Java implementation
of each unsigned type is implemented as the corresponding signed type.
The only exception is the Convert facility. When it performs a widening
operation, e.g. from ubyte to short, it performs the correct conversion.</p>

<h3>Introspection Interfaces</h3>

<p><code>Field</code> is the base introspection interface. It has only an ID and a type.</p>
<pre>interface Field extends Serializable {
    String getId();
    Type getType();
    void toString(StringBuilder buf);
    void toString(StringBuilder buf,int indentLevel);
    String toString();
}

interface Scalar extends Field {
    ScalarType getScalarType();
}

interface ScalarArray extends Field {
    ScalarType getElementType();
}

interface Structure extends Field {
    Field getField(String fieldName);
    Field getField(int fieldIndex);
    &lt;T extends Field&gt; T getField(Class&lt;T&gt; c, String fieldName);
    &lt;T extends Field&gt; T getField(Class&lt;T&gt; c, int fieldIndex);
    Field[] getFields();
    String[] getFieldNames();
    int getFieldIndex(String fieldName);
    String getFieldName(int fieldIndex);
}

interface StructureArray extends Field {
    Structure getStructure();
}

public interface Union extends Field{
    public static final String DEFAULT_ID = "union";
    public static final String ANY_ID = "any";
    Field getField(String fieldName);
    Field getField(int fieldIndex);
    &lt;T extends Field&gt; T getField(Class&lt;T&gt; c, String fieldName);
    &lt;T extends Field&gt; T getField(Class&lt;T&gt; c, int fieldIndex);
    Field[] getFields();
    String[] getFieldNames();
    int getFieldIndex(String fieldName);
    String getFieldName(int fieldIndex);
    boolean isVariant();
}

public interface UnionArray extends Field{
    Union getUnion();
}
</pre>

<p>The introspection interfaces provide access to immutable objects. This
allows introspection interfaces to be freely shared between data objects. For
example the introspection interface for a timeStamp, which is a structure
containing two fields, can be shared by every record that has a time stamp.</p>

<h3>Data Interfaces</h3>

<p><code>PVField</code> is the base interface for a data field:</p>
<pre>interface PVField extends  Serializable {
    String getFieldName();
    String getFullName();
    int getFieldOffset();
    int getNextFieldOffset();
    int getNumberFields();
    boolean isImmutable();
    void setImmutable();
    Field getField();
    PVStructure getParent();
    void postPut();
    void setPostHandler(PostHandler postHandler);
    void toString(StringBuilder buf);
    void toString(StringBuilder buf,int indentLevel);
    String toString();
    // The following should go away.
    PVAuxInfo getPVAuxInfo();
}</pre>

<p>Each scalar type has an associated data interface: <code>PVBoolean</code>,
<code>PVByte</code>, <code>PVShort</code>, <code>PVInt</code>, <code>PVLong</code>,
<code>PVUByte</code>, <code>PVUShort</code>, <code>PVUInt</code>, <code>PVULong</code>,
<code>PVFloat</code>, <code>PVDouble</code> and <code>PVString</code>. Each has a <code>get</code> and a
<code>put</code> method. For example:</p>
<pre>interface PVDouble extends PVScalar{
    double get();
    void put(double value);
}</pre>

<p><code>PVArray</code> is the base class for arrays.</p>
<pre>interface PVArray extends PVField, SerializableArray {
    Array getArray();
    int getLength();
    void setLength(int length);
    int getCapacity();
    void setCapacity(int length);
    boolean isCapacityMutable();
    void setCapacityMutable(boolean isMutable);
}
</pre>

<p><code>PVScalarArray</code> is the base class for scalar arrays.</p>
<pre>interface PVScalarArray extends PVArray {
    ScalarArray getScalarArray();
}</pre>

<p>For each scalar type an associated array data interface is defined. Each has
a <code>get</code> and <code>put</code> method. For example: </p>
<pre>public class DoubleArrayData {
    public double[] data;
    public int offset;
}

interface PVDoubleArray extends PVArray {
    int get(int offset, int len, DoubleArrayData data);
    int put(int offset,int len, double[] from, int fromOffset);
    void shareData(double[] from);
}</pre>

<p><code>PVStructureArray</code> is the interface for an array of structures where each element
has the same introspection interface.</p>
<pre>public class StructureArrayData {
    public PVStructure[] data;
    public int offset;
}

interface PVStructureArray extends PVArray{
    StructureArray getStructureArray();
    int get(int offset, int length, StructureArrayData data);
    int put(int offset,int length, PVStructure[] from, int fromOffset);
    void shareData(PVStructure[] from);
}</pre>

<p><code>PVStructure</code> is the data interface for a structure.</p>
<pre>
interface PVStructure extends PVField , BitSetSerializable{
    Structure getStructure();
    PVField[] getPVFields();
    PVField getSubField(String fieldName);
    PVField getSubField(int fieldOffset);
    &lt;T extends PVField&gt; T getSubField(Class&lt;T&gt; c, String fieldName);
    &lt;T extends PVField&gt; T getSubField(Class&lt;T&gt; c, int fieldOffset);
    // The following are convenience methods
    // Note that they are no longer needed because of above generic methods
    PVBoolean getBooleanField(String fieldName);
    PVByte getByteField(String fieldName);
    PVShort getShortField(String fieldName);
    PVInt getIntField(String fieldName);
    PVLong getLongField(String fieldName);
    PVFloat getFloatField(String fieldName);
    PVDouble getDoubleField(String fieldName);
    PVString getStringField(String fieldName);
    PVScalarArray getScalarArrayField(String fieldName);
    PVStructureArray getStructureArrayField(String fieldName);
    PVStructure getStructureField(String fieldName);
    PVArray getArrayField(String fieldName,ScalarType elementType);
    PVUnion getUnionField(String fieldName);
    PVUnionArray getUnionArrayField(String fieldName);
    public boolean checkValid();
}</pre>

<h3>Introspection and Data creation</h3>

<p>The following interface creates introspection instances:</p>
<pre>public interface FieldCreate {
    FieldBuilder createFieldBuilder();
    Scalar createScalar(ScalarType scalarType);
    BoundedString createBoundedString(int maxLength);
    ScalarArray createScalarArray(ScalarType elementType);
    ScalarArray createFixedScalarArray(ScalarType elementType, int size);
    ScalarArray createBoundedScalarArray(ScalarType elementType, int bound);
    StructureArray createStructureArray(Structure elementStructure);
    UnionArray createUnionArray(Union elementUnion);
    UnionArray createVariantUnionArray();
    Structure createStructure(String[] fieldNames, Field[] field);
    Structure createStructure(String id,String[] fieldNames, Field[] field);
    Structure appendField(Structure structure,String fieldName, Field field);
    Structure appendFields(Structure structure,String[] fieldNames, Field[] fields);
    Structure createStructure(Structure structToClone);
    Union createVariantUnion();
    Union createUnion(String[] fieldNames, Field[] fields);
    Union createUnion(String id, String[] fieldNames, Field[] fields);
    Field deserialize(ByteBuffer buffer, DeserializableControl control);
}</pre>

<p>The following is a convenience class for creating introspection objects:</p>
<pre>
public interface FieldBuilder
{
    public FieldBuilder setId(String id);
    public FieldBuilder add(String name, ScalarType scalarType);
    public FieldBuilder addBoundedString(String name, int maxLength);
    public FieldBuilder add(String name, Field field);
    public FieldBuilder addArray(String name, ScalarType scalarType);
    public FieldBuilder addFixedArray(String name, ScalarType scalarType, int size);
    public FieldBuilder addBoundedArray(String name, ScalarType scalarType, int bound);
    public FieldBuilder addArray(String name, Field element);
    public Structure createStructure();
    public Union createUnion();
    FieldBuilder addNestedStructure(String name); 
    FieldBuilder addNestedUnion(String name);
    FieldBuilder addNestedStructureArray(String name); 
    FieldBuilder addNestedUnionArray(String name);
    FieldBuilder endNested();
}
</pre>
<p>The following interface creates data instances:</p>
<pre>public interface PVDataCreate {
    PVField createPVField(Field field);
    PVField createPVField(PVField fieldToClone);
    PVScalar createPVScalar(Scalar scalar);
    PVScalar createPVScalar(ScalarType fieldType);
    PVScalar createPVScalar(PVScalar scalarToClone);
    &lt;T extends PVScalar, TA extends PVScalarArray&gt; T createPVScalar(
        PVScalarType&lt;T, TA&gt; scalarType);
    PVScalarArray createPVScalarArray(ScalarArray array);
    PVScalarArray createPVScalarArray(ScalarType elementType);
    PVScalarArray createPVScalarArray(PVScalarArray arrayToClone;
    &lt;T extends PVScalar, TA extends PVScalarArray&gt; TA createPVScalarArray(
        PVScalarType&lt;T, TA&gt; elementType);
    PVStructureArray createPVStructureArray(StructureArray structureArray);
    PVUnionArray createPVUnionArray(UnionArray unionArray);
    PVUnionArray createPVVariantUnionArray();
    PVStructure createPVStructure(Structure structure);
    PVStructure createPVStructure(String[] fieldNames,Field[] fields);
    PVStructure createPVStructure(PVStructure structToClone);
    PVUnion createPVUnion(Union union);
    PVUnion createPVVariantUnion();
    PVUnion createPVUnion(PVUnion unionToClone);
	
    PVStructureArray createPVStructureArray(Structure structure);
    PVUnionArray createPVUnionArray(Union union);
    PVField[] flattenPVStructure(PVStructure pvStructure);
}</pre>

<h3>pvData Conversion</h3>

<p>An interface named <code>Convert</code> provides all reasonable conversions to/from
pvData.
The convert utility is also used to implement the <code>toString</code> methods of <code>PVField</code>.
See <code>org.epics.pvdata.pv.Convert</code> for details.</p>

<h2 >Package Summary</h2>

<p>This document describes everything via Java definitions. The initial
implementation is in Java but the functionality is also implemented in C++ (See pvDataCPP for details).</p>

<p>pvData is distributed as a sourceforge mercurial project named pvDataJava.
It consists of the following Java packages:</p>

<h3>org.epics.pvdata.pv</h3>

<p>The Java enum, interface, and class definitions that define pvData. This
section provides a complete definition of what pvData is.</p>

<h3>org.epics.pvdata.factory</h3>

<p>Provides everything required for creating pvData. It provides the following
factories:</p>
<dl>
  <dt>FieldFactory</dt>
    <dd>Creates introspection interfaces.</dd>
  <dt>PVDataFactory</dt>
    <dd>Creates data interfaces for all of the supported data types.</dd>
  <dt>ConvertFactory</dt>
    <dd>Converts between support data types.</dd>
  <dt>StatusFactory</dt>
     <dd>Status is a class for communication status between code modules.</dd>
  <dt>StandardFieldFactory</dt>
     <dd>Creates introspection objects for "well known" data.</dd>
  <dt>StandardPVFieldFactory</dt>
     <dd>Creates data objects for "well known" data.</dd>
</dl>

<p>Although pvDataFactory can provide the implementation for all supported data
types, often it is desirable to provide other implementations. To make it easy
to create alternate implementations a set of abstract and base classes are
supplied.</p>

<h3>org.epics.pvdata.property</h3>

<p>Provides a way to associated properties with a field. </p>

<p>The basic idea is to associate properties with any field named "value". All
the fields in the structure that contains the value field are considered
properties of value with the field name being the property name. See that
package overview for details.</p>

<p>This package also provides support for "well known" field definitions like
timeStamp, alarm, display,etc. Code that uses pvData can be simplified by using
this support.</p>

<h3>org.epics.pvdata.misc</h3>

<p>This package provides support that is used by pvData factories and might
also be useful to software that uses pvData.</p>

<h3>org.epics.pvdata.monitor</h3>

<p>Provides the ability to monitor changes to an arbitrary subset of the fields
in a record.</p>

<h2 >Package org.epics.pvdata.pv</h2>

<h3>Overview</h3>

<p>This package has the complete set of enum, interface, and class definitions
that describe pvData. The implementation is provided in package
org.epics.pvdata.factory.</p>

<p>A <code>PVStructure</code> is a field that contains an array of subfields. Each field has
code for accessing the field. The interface for each field is <code>PVField</code> or an
interface that extends <code>PVField</code>. Each field also has an introspection interface,
which is <code>Field</code> or an extension of <code>Field</code>. This package overview describes the
complete set of data and introspection interfaces for pvData.</p>

<p>This package also describes an interface Convert, which provides a rich set
of methods for converting and copying data between field.</p>

<p>The interface <code>FieldCreate</code> creates the introspection interfaces. The
interface <code>PVDataCreate</code> creates the <code>PVField</code> interfaces. Between them they
provide the ability to create every type of <code>Field</code> and <code>PVField</code>, i.e. they
provide a complete implementation of pvData. It is also possible for other code
to provide implementations.</p>

<p>The interface <code>StandardField</code> provides introspection objects for standard fields.
The interface <code>StandardPVField</code> provides data objects for standard fields.</p>
<p>The interface <code>StatusCreate</code> and class <code>Status</code> provide status objects to pass between source
modules.</p>

<h3>Process Variable Reflection</h3>

<p>Given the introspection object it is
possible to introspect a field without requiring access to data. The
reflection and data interfaces are separate because the data may not be
available. For example when a pvAccess client connects to a PV, the client
library can obtain the reflection information without obtaining any data. Only
when a client issues an I/O request will data be available. This separation is
especially important for arrays and structures so that a client can discover
the type without requiring that a large array or structure be transported over
the network.</p>

<h4>Type</h4>

<p>The types are defined by the Java definitions:</p>
<pre>
enum Type {
    scalar,
    scalarArray,
    structure,
    structureArray,
    union,
    unionArrray;
}

enum ScalarType {
    pvBoolean,
    pvByte, pvShort, pvInt, pvLong,
    pvUByte, pvUShort, pvUInt, pvULong,
    pvFloat,pvDouble,
    pvString;

    //Convenience methods
    public boolean isInteger();   // pvByte,...,pvULong
    public boolean isUInteger();   // pvUByte,...,pvULong
    public boolean isNumeric();    // pvByte,...pvDouble
    public boolean isPrimitive();  // pvBoolean,...pvDouble
    public static ScalarType getScalarType(String type);
    public String toString();
}</pre>

<h4>Serializable</h4>

<p>The following interfaces are called by pvAccess for transporting data over
the network. The abstract and base classes ensure that these methods are
properly implemented. </p>
<pre>
interface Serializable {
    void serialize(ByteBuffer buffer,SerializableControl flusher);
    void deserialize(ByteBuffer buffer,DeserializableControl control);
}
</pre>
where
<dl>
  <dt>serialize</dt>
    <dd>Serialize into buffer. flusher is called when buffer is full.</dd>
  <dt>deserialize</dt>
    <dd>deserialize from byte buffer. control is called when more data is required.</dd>
</dl>
<pre>
interface SerializableControl {
    void flushSerializeBuffer();
    void ensureBuffer(int size);
    void alignBuffer(int alignment);
    void cachedSerialize(Field field, ByteBuffer buffer)
}
</pre>
where
<dl>
   <dt>flushSerializeBuffer</dt>
      <dd>Code that called serialize must empty the buffer.
       The call can block until the buffer is flushed.</dd>
   <dt>ensureBuffer</dt>
      <dd>Helper method. Ensures specified size of bytes, flushes if necessary.</dd>
   <dt>alignBuffer</dt>
      <dd>Align buffer.Note that this takes care only current buffer alignment. If streaming protocol is used,
        care must be taken that entire stream is aligned.</dd>
   <dt>cachedSerialize</dt>
      <dd>Serialize <code>Field</code> instance via cache.</dd> 
</dl>
<pre>
interface DeserializableControl {
    void ensureData(int size);
    void alignData(int alignment);
    Field cachedDeserialize(ByteBuffer buffer)
}
</pre>
where
<dl>
   <dt>ensureData</dt>
     <dd>Helper method. Ensures specified size of bytes, provides it if necessary.</dd>
   <dt>alignData</dt>
      <dd>Align buffer.Note that this takes care only current buffer alignment. If streaming protocol is used,
        care must be taken that entire stream is aligned.</dd>
   <dt>cachedDeserialize</dt>
      <dd>Deserialize <code>Field</code> instance via cache.</dd> 
</dl>
<pre>
interface SerializableArray extends Serializable {
    void serialize(ByteBuffer buffer, SerializableControl flusher, int offset, int count);
}       
</pre>
where
<dl>
   <dt>serialize</dt>
     <dd>Serialize field into given buffer.</dd>
</dl>
<pre>
interface BitSetSerializable {
   void serialize(ByteBuffer buffer, SerializableControl flusher, BitSet bitSet);
   void deserialize(ByteBuffer buffer, DeserializableControl control, BitSet bitSet);
}
</pre>
where
<dl>
   <dt>serialize</dt>
     <dd>Serialize field into given buffer. The <code>BitSet</code> shows the fields to serialize.</dd>
   <dt>deserialize</dt>
     <dd>Deserialize field into given buffer. The <code>BitSet</code> shows the fields to serialize.</dd>
</dl>

<h4>Reflection</h4>

<p>This section defines the complete set of Java PV reflection interfaces.
Reflection consists of the following:</p>
<dl>
  <dt>Field</dt>
    <dd>A <code>Field</code> has an ID and a type. It can be converted to a string. 
        The format is the metadata format
        described in the overview.</dd>
  <dt>Scalar</dt>
    <dd>A <code>Scalar</code> has a <code>ScalarType</code></dd>
  <dt>ScalarArray</dt>
    <dd>A <code>ScalarArray</code> has a <code>ScalarType</code> corresponding to the element type</dd>
  <dt>Structure</dt>
    <dd>Has fields that can be any of the supported types.
      In addition it has a name for each field.</dd>
  <dt>StructureArray</dt>
    <dd>The field holds <code>Structure[]</code>. Each element has the same <code>Structure</code>
      introspection interface. A client can only <code>get</code>/<code>put</code> entire <code>PVStructure</code>
      elements NOT subfields of array elements.</dd>
  <dt>Union</dt>
    <dd>A union field stores a single field. A given union field can either store a
       field of any type (variant union) or any of a specified set of types
      (regular union). <code>Union</code> describes which of these
      applies and the set of types in the case of a regular union. </dd>
   <dt>UnionArray</dt>
     <dd>The field holds <code>Union[]</code>. Each element has the same
      <code>Union</code> introspection interface.</dd>
  <dt>FieldCreate</dt>
    <dd>This is an interface that provides methods to create introspection
      interfaces. A factory is provided to create a <code>FieldCreate</code>.</dd>
</dl>
<h5>Field</h5>
<pre>    
interface Field extends Serializable {
    String getID();
    Type getType();
    void toString(StringBuilder buf));
    void toString(StringBuilder buf,int indentLevel);
    String toString();
} 
</pre>
where
<dl>
   <dt>getID</dt>
     <dd>Get the identification string.
      It can be empty.
      For scalar fields the ID is the metadata type, i.e. boolean, byte, etc.
      For scalarArray fields the ID is the metadata type, i.e. boolean[],
      byte[], etc.
      For structure fields the ID is determined by the argument specified
      when fieldCreate.createStructure is called.
      For structureArray fields the ID is XX[] where XX is the ID of the element structure.
     </dd>
   <dt>getType</dt>
     <dd>Get the field type.</dd>
   <dt>toString</dt>
     <dd>Create a String that shows the type.
      The format is the metadata syntax defined in the overview.</dd>
</dl>
<h5>Scalar</h5>
<pre>
interface Scalar extends Field {
    ScalarType getScalarType();
}
</pre>
where
<dl>
   <dt>getScalarType</dt>
     <dd>Return the ScalarType.</dd>
</dl>
<h5>ScalarArray</h5>
<pre>
interface ScalarArray extends Field{
    ScalarType getElementType();
}
</pre>
where
<dl>
   <dt>getElementType</dt>
     <dd>Return the <code>ScalarType</code> for each array element.</dd>
</dl>
<h5>Structure</h5>
<pre>
interface Structure extends Field{
    Field getField(String fieldName);
    Field getField(int fieldIndex);
    &lt;T extends Field&gt; T getField(Class&lt;T&gt; c, String fieldName);
    &lt;T extends Field&gt; T getField(Class&lt;T&gt; c, int fieldIndex);
    Field[] getFields();
    String[] getFieldNames();
    int getFieldIndex(String fieldName);
    String getFieldName(int fieldIndex);
}
</pre>
where
<dl>
   <dt>getField</dt>
     <dd>Return a field of the structure.
     The field can be requested by name or by index.</dd>
   <dt>getField - generic versions</dt>
     <dd>These are the methods that get a field of the structure and convert it to the proper type.</dd>
   <dt>getFields</dt>
     <dd>Return the array of sub fields.</dd>
   <dt>getFieldNames</dt>
     <dd>Return the fieldNames for the fields.</dd>
   <dt>getFieldName</dt>
     <dd>Return the <code>Field</code> for the index.</dd>
   <dt>getFieldIndex</dt>
     <dd>Return the index of the field with the specified fieldName.</dd>
</dl>
<h5>StructureArray</h5>
<pre>
interface StructureArray extends Field{
    Structure getStructure();
}
</pre>
where
<dl>
   <dt>getStructure</dt>
     <dd>Return the introspection interface for the array elements.</dd>
</dl>
<h5>Union</h5>
<pre>
public interface Union extends Field{
    public static final String DEFAULT_ID = "union";
    public static final String ANY_ID = "any";
    Field getField(String fieldName);
    Field getField(int fieldIndex);
    &lt;T extends Field&gt; T getField(Class&lt;T&gt; c, String fieldName);
    &lt;T extends Field&gt; T getField(Class&lt;T&gt; c, int fieldIndex);
    Field[] getFields();
    String[] getFieldNames();
    int getFieldIndex(String fieldName);
    String getFieldName(int fieldIndex);
    boolean isVariant();
}
</pre>
where
<dl>
   <dt>getField</dt>
     <dd>Given a name or an index the type is returned.
      <b>null</b> is returned if not found.
     </dd>
   <dt>getFields</dt>
       <dd>Get the array of types.</dd>
   <dt>getFieldNames</dt>
       <dd>Get the array of names.</dd>
   <dt>getFieldIndex</dt>
      <dd>Get the index for name. -1 is returned if not found.</dd>
   <dt>getFieldName</dt>
       <dd>Get the name for the specified index.</dd>
   <dt>isVariant</dt>
      <dd>returns <b>true</b> if this is variant array and <b>false</b> otherwise.</dd>
</dl>
<h5>UnionArray</h5>
<pre>
public interface UnionArray extends Field{
    Union getUnion();
}
</pre>
where
<dl>
   <dt>getUnion</dt>
     <dd>Get the union interface for each element.</dd>
</dl>
<h5>FieldCreate</h5>
<p><b>Syntax for fieldName and ID.</b>
</p>
<p>
A <b>fieldName</b> must begin with a letter and must be a sequence of letters
and digits.
A letter is defined as 'A'-'Z', 'a'-'z','_', or any Unicode character
that denotes a letter in a language. Similarly digits are '0'-'9' and any
Unicode character that denotes a digit in a language.
Note that this is the same as the Java syntax for variable names.
</p>
<p>The syntax for <b>ID</b> is the same except the '.' is also allowed
after the initial letter.</p>
<pre>public interface FieldCreate {
    FieldBuilder createFieldBuilder();
    Scalar createScalar(ScalarType scalarType);
    BoundedString createBoundedString(int maxLength);
    ScalarArray createScalarArray(ScalarType elementType);
    ScalarArray createFixedScalarArray(ScalarType elementType, int size);
    ScalarArray createBoundedScalarArray(ScalarType elementType, int bound);
    StructureArray createStructureArray(Structure elementStructure);
    UnionArray createUnionArray(Union elementUnion);
    UnionArray createVariantUnionArray();
    Structure createStructure(String[] fieldNames, Field[] field);
    Structure createStructure(String id,String[] fieldNames, Field[] field);
    Structure appendField(Structure structure,String fieldName, Field field);
    Structure appendFields(Structure structure,String[] fieldNames, Field[] fields);
    Structure createStructure(Structure structToClone);
    Union createVariantUnion();
    Union createUnion(String[] fieldNames, Field[] fields);
    Union createUnion(String id, String[] fieldNames, Field[] fields);
    Field deserialize(ByteBuffer buffer, DeserializableControl control);
}</pre>
where
<dl>
   <dt>createFieldBuilder</dt>
    <dd>Create an instance of <code>FieldBuilder</code>, which is described next.</dd>
   <dt>createScalar</dt>
     <dd>Return the <code>Scalar</code> with the specified <code>ScalarType</code>.
       Note that the implementation creates a single instance for
      each <code>ScalarType</code>.</dd>
   <dt>createBoundedString</dt>
      <dd>Return a scalar of type <code>pvString</code> that has a bounded size for a string.</dd>
   <dt>createScalarArray</dt>
     <dd>Return the <code>ScalarArray</code> with the specified <code>elementType</code>.
       Note that the implementation creates a single instance for
      each <code>elementType</code>.</dd>
   <dt>createFixedScalarArray</dt>
      <dd>Return the <code>ScalarArray</code> with the specified <code>elementType</code> and specifies that size of
        element size of any object that has this introspection interface.</dd>
   <dt>createBoundedScalarArray</dt>
      <dd>Return the <code>ScalarArray</code> with the specified <code> elementType</code> and specifies that maximum
        element size of any object that has this introspection interface.</dd>
   <dt>createStructureArray</dt>
     <dd>Return a <code>StructureArray</code> with the specified introspection
     interface for each array element.</dd>
   <dt>createUnionArray</dt>
      <dd>Return a <code>UnionArray</code> with the specified introspection interface.</dd>
   <dt>createVariantUnionArray</dt> 
       <dd>Return a <code>UnionArray</code> of variant union elements.</dd>
   <dt>createStructure</dt>
     <dd>Return a <code>Structure</code>. There are two methods.
     The first creates a structure with an empty ID which results in an ID of <b>structure</b>.
     </dd>
   <dt>appendField</dt>
     <dd>Append a field to a structure.</dd>
   <dt>appendFields</dt>
     <dd>Append an array of fields to a structure.</dd>
   <dt>createVariantUnion</dt>
      <dd>Create a variant union, i.e. a union where the subfield can be any valid type.</dd>
   <dt>createUnion</dt>
      <dd>Create a union where the subfield can have any of the types an names defined
      by the arguments and the associated names.
      The default ID is <b>union</b> for regular unions and <b>any</b> for variant unions.
     </dd>
   <dt>deserialize</dt>
     <dd>Deserialize a field from the the buffer.</dd>
</dl>
<h5>FieldBuilder</h5>
<p><code>FieldBuilder</code> is a convenience class for creating introspection interfaces.
An example is:</p>
<pre>
FieldCreate fieldCreate = FieldFactory.getFieldCreate();
Structure s = fieldCreate.createFieldBuilder().
    add("double", ScalarType.pvDouble).
    addNestedStructure("nested").
        add("short", ScalarType.pvShort).
        add("long", ScalarType.pvLong).
        endNested().
    addArray("intArray", ScalarType.pvInt).
    createStructure();
System.out.println(s);
</pre>
This produces:
<pre>
structure
    double double
    structure nested
        short short
        long long
    int[] intArray
</pre>

<p>The Java interface is:</p>
<pre>
public interface FieldBuilder
{
    public FieldBuilder setId(String id);
    public FieldBuilder add(String name, ScalarType scalarType);
    public FieldBuilder addBoundedString(String name, int maxLength);
    public FieldBuilder add(String name, Field field);
    public FieldBuilder addArray(String name, ScalarType scalarType);
    public FieldBuilder addFixedArray(String name, ScalarType scalarType, int size);
    public FieldBuilder addBoundedArray(String name, ScalarType scalarType, int bound);
    public FieldBuilder addArray(String name, Field element);
    public Structure createStructure();
    public Union createUnion();
    FieldBuilder addNestedStructure(String name); 
    FieldBuilder addNestedUnion(String name);
    FieldBuilder addNestedStructureArray(String name); 
    FieldBuilder addNestedUnionArray(String name);
    FieldBuilder endNested();
}
</pre>
<dl>
  <dt>setId</dt>
     <dd>
      Specify the ID for the next <code>createStructure</code> or <code>createUnion call</code>.
     </dd>
  <dt>add</dt>
     <dd>
     Add a name and field for then next call to <code>createStructure</code> or <code>createUnion</code>.
     There are two forms: one for an existing field and the other for a scalar field.
     </dd>
   <dt>addBoundedString</dt>
     <dd>Add a bounded string field.</dd>
  <dt>addArray</dt>
     <dd>
     Add a name and array field for then next call to <code>createStructure</code> or <code>createUnion</code>.
     There are two forms: one for an existing field and the other for a scalar field.
      Note that for an existing field this specifies the element type.
     </dd>
   <dt>addFixedArray</dt>
     <dd>Add a scalar fixed array field.</dd>
   <dt>addBoundedArray</dt>
     <dd>Add a scalar bounded array field.</dd>
  <dt>createStructure</dt>
     <dd>
       Create a <code>Structure</code> from the previous <code>add</code> and <code>addArray</code> methods.
     </dd>
  <dt>createUnion</dt>
     <dd>
       Create a <code>Union</code> from the previous <code>add</code> and <code>addArray</code> methods.
     </dd>
  <dt>addNestedStructure</dt>
     <dd>
      Start a nested structure.
      This is followed by calls to other methods and ended by a call to <code>endNested</code>.
     </dd>
  <dt>addNestedUnion</dt>
     <dd>
      Start a nested union.
      This is followed by calls to other methods and ended by a call to <code>endNested</code>.
     </dd>
  <dt>addNestedStructureArray</dt>
     <dd>
      Start a nested structure array.
      This is followed by calls to other methods and ended by a call to <code>endNested</code>.
     </dd>
  <dt>addNestedUnionArray</dt>
     <dd>
      Start a nested union array.
      This is followed by calls to other methods and ended by a call to <code>endNested</code>.
     </dd>
  <dt>endNested</dt>
     <dd>
     </dd>
</dl>


<h3>Status</h3>

<p><code>Status</code> provides a way to pass status back to client code. It is new and not
currently used by pvData but may be in the future. It is used by code that uses
pvData.</p>
<h4>Status</h4>
<pre>
interface Status extends Serializable  {
    public enum StatusType {OK,WARNING,ERROR,FATAL};
    StatusType getType();
    String getMessage();
    String getStackDump();
    boolean isOK();
    boolean isSuccess();
}
</pre>
where
<dl>
  <dt>StatusType</dt>
    <dd>An enum for the status type.</dd>
  <dt>getType</dt>
    <dd>Get the <code>StatusType</code>.</dd>
  <dt>getMessage</dt>
    <dd>Get a message explaining the error.</dd>
  <dt>getStackDump</dt>
    <dd>Get a stack dump.</dd>
  <dt>isOK</dt>
     <dd>Is the status the singleton object for <code>StatusType.OK</code>?</dd>
  <dt>isSuccess</dt>
     <dd>Is the <code>StatusType</code> either OK or WARNING?</dd>
</dl>
<h4>StatusCreate</h4>
<pre>
interface StatusCreate {
    Status getStatusOK(); 
    Status createStatus(StatusType type, String message, Throwable cause);
    Status deserializeStatus(ByteBuffer buffer, DeserializableControl control);
}
</pre>
where
<dl>
  <dt>getStatusOK</dt>
    <dd>Get a singleton that returns StatusType.OK and a null message and
      stackDump.</dd>
  <dt>createStatus</dt>
    <dd>Create a new Status.</dd>
  <dt>deserializeStatus</dt>
    <dd>Use this method instead of Status.deserialize(), since this allows OK
      status optimization.</dd>
</dl>

<h3>Requester</h3>

<p>Requester is an interface that allows messages to be given to client code.
An instance of <code>Requester</code> must be implemented by the client.
The definition is:
</p>
<pre>
enum MessageType {info,warning,error,fatalError}

interface Requester {
    String getRequesterName();
    void message(String message, MessageType messageType);
}
</pre>

<p>where</p>
<dl>
  <dt></dt>
  <dt>MessageType</dt>
    <dd>Type of message.</dd>
  <dt>Requester</dt>
    <dd>The default implementation is: 
      <ul>
        <li>getRequesterName<br />
          This is the full field name concatenated to the record name.</li>
        <li>message<br />
          For the default implementation, <code>PVField</code> prepends the full field name
          to the message and calls <code>PVRecord.message</code>. The default implementation
          for <code>PVRecord</code> either displays the message on stdout or stderr or gives
          the message to message requesters.</li>
      </ul>
    </dd>
</dl>

<h3>PVField - Data Interfaces</h3>

<p>This section defines the Java Interfaces for accessing the data within
a top-level <code>PVStructure</code>.</p>

<h4>PVField</h4>

<p><code>PVField</code> is the base interface for accessing data. Every field of a
top-level <code>PVStructure</code> has a <code>PVField</code> associated with it.
This includes the top-level structure itself.
</p>
<pre>interface PVField Serializable {
    String getFieldName();
    String getFullName();
    int getFieldOffset();
    int getNextFieldOffset();
    int getNumberFields();
    boolean isImmutable();
    void setImmutable();
    Field getField();
    PVStructure getParent();
    void postPut();
    void setPostHandler(PostHandler postHandler);
    void toString(StringBuilder buf);
    void toString(StringBuilder buf,int indentLevel);
    String toString();
    // The following should go away.
    PVAuxInfo getPVAuxInfo();
}</pre>

<p>where</p>
<dl>
  <dt>getFieldName</dt>
     <dd>Get the field name for this field. This will be a empty string for
     the top-level structure.</dd>
  <dt>getFullName</dt>
     <dd>Return the path name and field name for this field.</dd>
  <dt>getFieldOffset</dt>
    <dd>Get offset of the <code>PVField</code> field within top-level structure. Every field
      within the <code>PVStructure</code> has a unique offset. The top-level structure has
      an offset of 0. The first field within the structure has offset equal to
      1. The other offsets are determined by recursively traversing each
      structure of the tree. </dd>
  <dt>getNextFieldOffset</dt>
    <dd>Get the next offset. If the field is a scalar or array field then this
      is just offset + 1. If the field is a structure it is the offset of the
      next field after this structure. Thus (nextOffset - offset) is always
      equal to the total number of fields within the field. </dd>
  <dt>getNumberFields</dt>
    <dd>Get the total number of fields in this field. This is nextFieldOffset -
      fieldOffset. </dd>
  <dt>isImmutable</dt>
    <dd>Is the field immutable?</dd>
  <dt>setImmutable</dt>
    <dd>Make the field immutable. Once a field is immutable it can never be
      changed since there is no method to again make it mutable. This is an
      important design decision because it allows immutable array fields to
      share the internal primitive data array.</dd>
  <dt>getField</dt>
    <dd>Get the reflection interface.</dd>
  <dt>getParent</dt>
    <dd>Get the interface for the parent or null if this is the top-level
      <code>PVStructure</code>.</dd>
  <dt>postPut</dt>
    <dd>If a <code>PostHandler</code> is registered it is called otherwise no action is
      taken.<br />
     <b>NOTE: </b>The implementation  of the various data interfaces automatically
      call <code>postPut</code> when a field is changed. However this is not true
      for a subField of a <code>PVUnion</code>, <code>PVUnionArray</code>, or <code>PVStructureArray</code>.
     If a subField of any of these is changed then the code that is making
     the modification must call <code>postPut</code> for the <code>PVUnion</code>, <code>PVUnionArray</code>, or <code>PVStructureArray</code>
     field. Note also that it is not a good idea to modify a subfield of a <code>PVUnionArray</code>
     or a <code>PVStructureArray</code> since it violates the idea of Copy On Write for arrays.
    </dd>
  <dt>setPostHandler</dt>
     <dd>Set the handler for <code>postPut</code>. At most one handler can be set.</dd>
  <dt>toString</dt>
    <dd>Converts the field data to a string. This is mostly for debugging
      purposes. The format is the meta data format described in the pvData
      project overview.
      <b>Note:</b> The actual conversion is done by the Convert facility. </dd>
</dl>

<h4>PVAuxInfo</h4>
<p><b>NOTE:</b> PVAuxInfo should go away.</p>

<p>AuxInfo (Auxiliary Information) is information about a field that is
application specific. It will not be available outside the application that
implements the database. In particular it will not be made available to Channel
Access. It is used by the database itself to override the default
implementation of fields. The JavaIOC used it for attaching support code.
Database Configuration and other tools can use it for configuration
information. Each <code>Field</code> and each <code>PVField</code> can have have an arbitrary number of
auxInfos. An auxInfo is a (key,<code>PVScalar</code>) pair where key is a string.</p>
<pre>
public interface PVAuxInfo {
    PVField getPVField();
    PVScalar createInfo(String key,ScalarType scalarType);
    Map&lt;String,PVScalar&gt; getInfos();
    PVScalar getInfo(String key);
    void toString(StringBuilder buf);
    void toString(StringBuilder buf,int indentLevel);
}
</pre>

<p>where</p>
<dl>
  <dt>getPVField</dt>
    <dd>Get the <code>PVField</code> to which this <code>PVAuxInfo</code> is attached.</dd>
  <dt>createInfo</dt>
    <dd>Create a new <code>PVScalar</code> of type scalarType.</dd>
  <dt>getInfos</dt>
    <dd>Get a map of all the auxInfos.</dd>
  <dt>getInfo</dt>
    <dd>Get the <code>PVScalar</code> with the specified key.</dd>
  <dt>toString</dt>
    <dd>Print all the auxInfo data in metadata format.</dd>
</dl>

<h4>PVScalar and extensions</h4>
<pre>
interface PVScalar extends PVField {
    Scalar getScalar();
}
</pre>

<h5>Primitive <code>PVField</code> types</h5>

<p>The interfaces for primitive data types are:</p>
<pre>
interface PVBoolean extends PVScalar {
    boolean get();
    void put(boolean value);
}

interface PVByte extends PVScalar {
    byte get();
    void put(byte value);
}

interface PVShort extends PVScalar {
    short get();
    void put(short value);
}

interface PVInt extends PVScalar {
    int get();
    void put(int value);
}

interface PVLong extends PVScalar {
    long get();
    void put(long value);
}

interface PVUByte extends PVScalar {
    byte get();
    void put(byte value);
}

interface PVUShort extends PVScalar {
    short get();
    void put(short value);
}

interface PVUInt extends PVScalar {
    int get();
    void put(int value);
}

interface PVULong extends PVScalar {
    long get();
    void put(long value);
}

interface PVFloat extends PVScalar {
    float get();
    void put(float value);
}

interface PVDouble extends PVScalar {
    double get();
    void put(double value);
}
</pre>
<p><b>NOTE:</b> The interface for each unsigned integer is the same as for the same signed type.
This is because Java does not implement unsigned primitive types.</p>

<h5>PVString</h5>

<p>The interface for string is:</p>
<pre>
interface PVString extends PVScalar, SerializableArray {
    String get();
    void put(String value);
}
</pre>

<h4>PVArray and Extensions</h4>

<p><code>PVArray</code> is the base interface for
all the other array interfaces. It extends <code>PVField</code> and provides the
additional methods:</p>
<pre>
interface PVArray extends PVField, SerializableArray {
    Array getArray();
    int getLength();
    void setLength(int len);
    int getCapacity();
    void setCapacity(int len);
    boolean isCapacityMutable();
    void setCapacityMutable(boolean isMutable);
}
</pre>
<dl>
  <dt>getArray</dt>
    <dd>Get the Array introspection interface.</dd>
  <dt>getLength</dt>
<dd>Get the current length. This is less that or equal to the capacity.</dd>
  <dt>setLength</dt>
<dd>Set the length. If the <code>PVField</code> is not mutable then an exception is
  thrown. If this is greater than the capacity <code>setCapacity</code> is called.</dd>
  <dt>getCapacity</dt>
<dd>Get the capacity, i.e. this is the sized of the underlying data
array.</dd>
  <dt>setCapacity</dt>
<dd>Set the capacity. The semantics are implementation dependent but
  typical semantics are as follows: If the capacity is not mutable an
  exception is thrown. A new data array is created and data is copied from
  the old array to the new array. </dd>
  <dt>isCapacityMutable</dt>
<dd>Is the capacity mutable</dd>
  <dt>setCapacityMutable</dt>
<dd>Specify if the capacity can be changed.</dd>
</dl>

<h5>PVArray Extensions</h5>

<p>The interface for each array type has get and put methods which have the
same arguments except for the data type. For example for <code>PVDoubleArray</code> it is:</p>
<pre>
public class DoubleArrayData {
    public double[] data;
    public int offset;
}
interface PVDoubleArray extends PVScalarArray {
    int get(int offset, int len, DoubleArrayData data);
    int put(int offset, int len, double[]from, int fromOffset);
    void shareData(double[] from);
}
</pre>

<p>Get "exposes" it's internal array by setting data.data and data.offset. The
caller is responsible for copying the array elements. This violates the
principle that objects should not expose their internal data but is done for
efficiency. For example it makes it possible to copy between arrays with
identical element types via a call to <code>System.arraycopy</code> without requiring an
intermediate array.</p>

<p>Both <code>get</code> and <code>put</code> return the number of elements actually transferred. The
arguments are:</p>
<dl>
  <dt>offset</dt>
<dd>The offset in the <code>PVArray</code>.</dd>
  <dt>len</dt>
<dd>The maximum number of elements to transfer. The number actually
  transferred will be less than or equal to this value.</dd>
  <dt>data</dt>
<dd>Get sets <code>data.data</code> to it's internal array and <code>data.offset </code> to the offset
  into the array. The caller is responsible for the actual data
transfer.</dd>
  <dt>from</dt>
<dd>The array from which the data is taken. This array is supplied by the
  caller</dd>
  <dt>fromOffset</dt>
<dd>The offset in <code>from</code></dd>
</dl>

<p>The caller must be prepared to make multiple calls to retrieve or put an
entire array. A caller should accept or put partial arrays. For example the
following reads an entire array:</p>
<pre>
double[] getArray(PVDoubleArray pv)
{
    int len = pv.getLength();
    double[] storage = new double[len];
    DoubleArrayData data = new DoubleArrayData();
    int offset = 0;
    while(offset &lt; len) {
        int num = pv.get(offset,(len-offset),data);
        System.arraycopy(data.data,data.offset,storage,offset,num);
        offset += num;
    }
    return storage;
}
</pre>

<p><b>NOTE: </b> The pvDataCPP now enforces COW (Copy on Write) for arrays.
In the future pvDataJava should have similar rules but without the concept of <b>const</b>
it may not be possible to enforce COW.
<code>shareData</code> definitely violates COW if any code changes the shared data.
It should <b>not</b> used except for immutable arrays.
</p>
<p><code>shareData</code> results in the <code>PVArray</code> using the primitive array that is passed to
this method. This is most useful for immutable arrays. In this case the caller
must set the <code>PVArray</code> to be immutable. If the <code>PVArray</code> is not immutable then 
the application is responsibility for coordinating access to the array.
This violates the principle that objects should not expose their internal data but
is important for immutable arrays. For example pvData defines
many enumerated structures where an enumerated structure has two fields: index
and choices. Choices is a <code>PVStringArray</code> that holds the enumerated choices.
Index is a <code>PVInt</code> that is the index of the currently selected choice. The
choices can be immutable. Allowing the choices internal String[] to be shared
between all the instances of an enumerated structure saves on storage. Another
reason for allowing shared data is so that an application which processes an
array can be separated into multiple modules that directly access the internal
data array of a <code>PVArray</code>. This can be required for minimizing CPU overhead. In
this case it is the applications responsibility to coordinate access to the
array.</p>

<h5>Complete set of PVArray Extensions</h5>
<pre>
interface PVScalarArray extends PVArray {
    ScalarArray getScalarArray();
}

public class BooleanArrayData {
    public boolean[] data;
    public int offset;
}
interface PVBooleanArray extends PVScalarArray {
    int get(int offset, int len, BooleanArrayData data);
    int put(int offset, int len, boolean[]from, int fromOffset);
    void shareData(boolean[] from);
}

public class ByteArrayData {
    public byte[] data;
    public int offset;
}
interface PVByteArray extends PVScalarArray {
    int get(int offset, int len, ByteArrayData data);
    int put(int offset, int len, byte[]from, int fromOffset);
    void shareData(byte[] from);
}
interface PVUByteArray extends PVScalarArray {
    int get(int offset, int len, ByteArrayData data);
    int put(int offset, int len, byte[]from, int fromOffset);
    void shareData(byte[] from);
}

public class ShortArrayData {
    public short[] data;
    public int offset;
}
interface PVShortArray extends PVScalarArray {
    int get(int offset, int len, ShortArrayData data);
    int put(int offset, int len, short[]from, int fromOffset);
    void shareData(short[] from);
}
interface PVUShortArray extends PVScalarArray {
    int get(int offset, int len, ShortArrayData data);
    int put(int offset, int len, short[]from, int fromOffset);
    void shareData(short[] from);
}

public class IntArrayData {
    public int[] data;
    public int offset;
}
interface PVIntArray extends PVScalarArray {
    int get(int offset, int len, IntArrayData data);
    int put(int offset, int len, int[]from, int fromOffset);
    void shareData(int[] from);
}
interface PVUIntArray extends PVScalarArray {
    int get(int offset, int len, IntArrayData data);
    int put(int offset, int len, int[]from, int fromOffset);
    void shareData(int[] from);
}

public class LongArrayData {
    public long[] data;
    public int offset;
}
interface PVLongArray extends PVScalarArray {
    int get(int offset, int len, LongArrayData data);
    int put(int offset, int len, long[]from, int fromOffset);
    void shareData(long[] from);
}
interface PVULongArray extends PVScalarArray {
    int get(int offset, int len, LongArrayData data);
    int put(int offset, int len, long[]from, int fromOffset);
    void shareData(long[] from);
}

public class FloatArrayData {
    public float[] data;
    public int offset;
}
interface PVFloatArray extends PVScalarArray {
    int get(int offset, int len, FloatArrayData data);
    int put(int offset, int len, float[]from, int fromOffset);
    void shareData(float[] from);
}

public class DoubleArrayData {
    public double[] data;
    public int offset;
}
interface PVDoubleArray extends PVScalarArray {
    int get(int offset, int len, DoubleArrayData data);
    int put(int offset, int len, double[]from, int fromOffset);
    void shareData(double[] from);
}

public class StringArrayData {
    public String[] data;
    public int offset;
}
interface PVStringArray extends PVScalarArray {
    int get(int offset, int len, StringArrayData data);
    int put(int offset, int len, String[]from, int fromOffset);
    void shareData(String[] from);
}

public class StructureArrayData {
    public PVStructure[] data;
    public int offset;
}

interface PVStructureArray extends PVArray {
    StructureArray getStructureArray();
    int get(int offset, int length, StructureArrayData data);
    int put(int offset,int length, PVStructure[] from, int fromOffset);
    void shareData(PVStructure[] from);
}

public class UnionArrayData {
    public PVUnion[] data;
    public int offset;
}

interface PVUnionArray extends PVArray{
    UnionArray getUnionArray();
    int get(int offset, int length, UnionArrayData data);
    int put(int offset,int length, PVUnion[] from, int fromOffset);
    void shareData(PVUnion[] from);
}
</pre>
<p><b>NOTES:</b></p>
<dl>
   <dt>Unsigned types</dt>
     <dd>The implementation for each unsigned integer is the same as for the same signed type.
     This is because Java does not implement unsigned primitive types.</dd>
   <dt>PVStructureArray and PVUnionArray</dt>
     <dd>A client can only access the data in the
       elements of the array via the get and put methods, i.e. it is not possible to
       access subfields indirectly. <code>PVStructureArray.getNumberFields()</code> returns 1, i.e.
       the field looks like a leaf field.</dd>
</dl>

<h4>PVStructure</h4>

<p>The interface for a structure is:</p>
<pre>
interface PVStructure extends PVField , BitSetSerializable{
    Structure getStructure();
    PVField[] getPVFields();
    PVField getSubField(String fieldName);
    PVField getSubField(int fieldOffset);
    &lt;T extends PVField&gt; T getSubField(Class&lt;T&gt; c, String fieldName);
    &lt;T extends PVField&gt; T getSubField(Class&lt;T&gt; c, int fieldOffset);
    // The following are convenience methods
    // Note that they are no longer needed because of above generic methods
    PVBoolean getBooleanField(String fieldName);
    PVByte getByteField(String fieldName);
    PVShort getShortField(String fieldName);
    PVInt getIntField(String fieldName);
    PVLong getLongField(String fieldName);
    PVFloat getFloatField(String fieldName);
    PVDouble getDoubleField(String fieldName);
    PVString getStringField(String fieldName);
    PVScalarArray getScalarArrayField(String fieldName);
    PVStructureArray getStructureArrayField(String fieldName);
    PVStructure getStructureField(String fieldName);
    PVArray getArrayField(String fieldName,ScalarType elementType);
    PVUnion getUnionField(String fieldName);
    PVUnionArray getUnionArrayField(String fieldName);
    public boolean checkValid();
}</pre>

<p>where</p>
<dl>
  <dt>getStructure</dt>
    <dd>Get the introspection interface for the structure.</dd>
  <dt>getPVFields</dt>
    <dd>Returns the array of subfields. The set of subfields must all have
      different field names.</dd>
  <dt>getSubField(String fieldName)</dt>
    <dd>Get a subfield of the <code>PVStructure</code>. If the field does not exist null is
      returned. fieldName can be the name of an immediate subfield. More
      generally it can be the name of the field relative to the <code>PVStructure</code>.
      In other words it consists of one or more strings separated by periods (.s).
      The last of these strings is the name of the field. The other strings are
      the names of the structure subfields containing the requested field starting
      with the highest level subfield and descending to the leaf field, e.g.
      current.alarm.status.</dd>
  <dt>getSubField(int fieldOffset)</dt>
    <dd>Get the field located a <code>fieldOffset</code>, where <code>fieldOffset </code> is relative to
      the top-level structure. This returns null if the specified field is not
      located within this <code>PVStructure</code>.</dd>
   <dt>getSubField - generic versions</dt>
     <dd>These are the methods to that get a subfield and convert it to the proper type.
    These two methods replace all the type specific methods, which are no longer required
    and should not be used.</dd>
</dl>

<h4>PVDataCreate</h4>

<p><code>PVDataCreate</code> is an interface that provides methods that create <code>PVField</code>
interfaces. A factory is provided that creates <code>PVDataCreate</code>.</p>
<pre>interface PVDataCreate {
    PVField createPVField(Field field);
    PVField createPVField(PVField fieldToClone);
    PVScalar createPVScalar(Scalar scalar);
    PVScalar createPVScalar(ScalarType fieldType);
    PVScalar createPVScalar(PVScalar scalarToClone);
    &lt;T extends PVScalar, TA extends PVScalarArray&gt; T createPVScalar(
        PVScalarType&lt;T, TA&gt; scalarType);
    PVScalarArray createPVScalarArray(ScalarArray array);
    PVScalarArray createPVScalarArray(ScalarType elementType);
    PVScalarArray createPVScalarArray(PVScalarArray arrayToClone;
    &lt;T extends PVScalar, TA extends PVScalarArray&gt; TA createPVScalarArray(
        PVScalarType&lt;T, TA&gt; elementType);
    PVStructureArray createPVStructureArray(StructureArray structureArray);
    PVUnionArray createPVUnionArray(UnionArray unionArray);
    PVUnionArray createPVVariantUnionArray();
    PVStructure createPVStructure(Structure structure);
    PVStructure createPVStructure(String[] fieldNames,Field[] fields);
    PVStructure createPVStructure(PVStructure structToClone);
    PVUnion createPVUnion(Union union);
    PVUnion createPVVariantUnion();
    PVUnion createPVUnion(PVUnion unionToClone);
	
    PVStructureArray createPVStructureArray(Structure structure);
    PVUnionArray createPVUnionArray(Union union);
    PVField[] flattenPVStructure(PVStructure pvStructure);
}</pre>
where 
<dl>
  <dt>createPVField</dt>
    <dd>The <code>PVField</code> is created reusing the <code>Field</code> interface. Two methods are
      provided. Each calls the corresponding <code>createPVScalar</code>, createPVArray, or
      <code>createPVStructure</code> depending in the type of the argument.</dd>
  <dt>createPVScalar</dt>
    <dd>Creates an instance of a <code>PVScalar</code>. Three versions are supplied. The
      first is passed an introspection interface. The second provides the field
      name and the scalarType. The third provides a field name and a <code>PVScalar</code> to
      clone. The newly created <code>PVScalar</code> will have the same auxInfos as the
      original.
      The last is a generic version that casts to the appropriate type.
     An example is:
<pre>
PVDouble value  = pvDataCeate.createPVScalar(PVScalarType.pvDouble);
</pre>
      </dd>
  <dt>createPVScalarArray</dt>
    <dd>Create an instance of a <code>PVArray</code>. Three versions are supplied. The first
      is passed an introspection interface. The second provides and the elementType.
      The third provides an array to clone.
      The newly created <code>PVArray</code> will have the same values as the original.
      The last is a generic version that casts to the appropriate type.
     An example is:
<pre>
PVDoubleArray value  = pvDataCeate.createPVScalarArray(PVScalarType.pvDouble);
</pre>
      </dd>
  <dt>createPVStructureArray</dt>
    <dd>Create a <code>PVStructureArray</code>. It must be passed a structureToClone. This
      will become the <code>Structure</code> interface for ALL elements of the
      <code>PVStructureArray</code>. It MUST be used to create any new array elements.</dd>
   <dt>createPVUnionArray</dt>
    <dd>Create a <code>PVUnionArray</code>. It must be passed a union. This
      will become the union interface for ALL elements of the
      <code>PVUnionArray</code>. It MUST be used to create any new array elements.</dd>
   <dt>createPVVariantUnionArray</dt>
      <dd>Create a variant <code>PVUnionArray</code>.
       Each array element can have any type.
       </dd>
  <dt>createPVStructure</dt>
    <dd>Create an instance of a <code>PVStructure</code>. Three methods are provided. The
      first method uses a previously created structure introspection interface.
      The second called with fieldName array and a <code>Field</code> array.
      The third initializes the subfields by cloning the fields contained in
      <code>structToClone</code>. The newly created subfields will have the same values and
      AuxInfos as the original. If <code>structToClone</code> is null then the new structure
      is initialized to have 0 subfields.</dd>
   <dt>createPVUnion</dt>
    <dd>Create a <code>PVUnion</code>.
      Two versions are provided.
      The first is passed a <code>Union</code> interface the single subfield.
       The second is passed a <code>PVUnion</code> to clone.
      </dd>
   <dt>createPVVariantUnion</dt>
      <dd>Create a variant <code>PVUnion</code>.
       The subfield can have any type.
       </dd>
  <dt>flattenPVStructure</dt>
    <dd>Create an array of <code>PVField</code>s for the fields in the <code>PVStructure</code>. The
      order is according to <code>fieldOffset</code>.</dd>
</dl>

<h3>Convert</h3>

<p><b>NOTE:</b> copying immutable array fields. If an entire immutable array
field is copied to another array that has the same elementType, both offsets
are 0, and the length is the length of the source array, then the <code>shareData</code>
method of the target array is called and the target array is set immutable.
Thus the source and target share the same primitive array.</p>

<p>This section describes the supported conversions between data types.</p>
<ul>
  <li>All supported types can be converted to a string. If you ask for a 100
    megabyte array to be converted to a string expect a lot of output.</li>
  <li>Conversion from a string to a scalar type.</li>
  <li>Conversion from an array of strings to an array of scalar types.</li>
  <li>Copy between the following types of scalar PVs 
    <ul>
      <li>Numeric type to another numeric type</li>
      <li>Both have the same type.</li>
      <li>Either is a string</li>
    </ul>
  </li>
  <li>Copy between <code>PVArray</code>s that satisfy one of the following. 
    <ul>
      <li>Numeric to numeric</li>
      <li>Both have the same type.</li>
      <li>Either is a string.</li>
    </ul>
  </li>
  <li>Conversions between numeric scalar types.</li>
  <li>Conversions between arrays of numeric type.</li>
  <li>Conversion between compatible structures.</li>
  <li>Support for unsigned integers. Because Java does primitive unsigned
   integers the only support is in "widening" operations.
   For example if a <code>PVUByte</code> is converted to short then the proper conversion will
   be done.</li>
  <li>A utility method the returns the full field name of a field.</li>
</ul>
<pre>
interface Convert {
    void getFullFieldName(StringBuilder builder,PVField pvField)
    void getString(StringBuilder buf,PVField pv, int indentLevel);
    void getString(StringBuilder buf,PVField pv);
    void fromString(PVScalar pv,String from);
    void fromString(PVScalarArray pv,String from);
    int fromStringArray(PVScalarArray pv,
         int offset, int len, String[]from, int fromOffset);
    int toStringArray(PVScalarArray pv,
         int offset, int len, String[]to, int toOffset);
    boolean isCopyCompatible(Field from, Field to);
    void copy(PVField from,PVField to);
    boolean isCopyScalarCompatible(Field from, Field to);
    void copyScalar(PVField from, PVField to);
    boolean isCopyScalarArrayCompatible(ScalarArray from, ScalarArray to);
    int copyScalarArray(PVScalarArray from, int offset,
         PVScalarArray to, int toOffset, int len);
    boolean isCopyStructureCompatible(Structure from, Structure to);
    void copyStructure(PVStructure from, PVStructure to);
    boolean isCopyUnionCompatible(Union from, Union to);
    void copyUnion(PVUnion from, PVUnion to);
    boolean isCopyStructureArrayCompatible(StructureArray from, StructureArray to);
    void copyStructureArray(PVStructureArray from, PVStructureArray to);
    boolean isCopyUnionArrayCompatible(UnionArray from, UnionArray to);
    void copyUnionArray(PVUnionArray from, PVUnionArray to);
    // For the following the pv Type must be PVByte, ...., PVDouble
    byte toByte(PVField pv);
    short toShort(PVField pv);
    int   toInt(PVField pv);
    long  toLong(PVField pv);
    float toFloat(PVField pv);
    double toDouble(PVField pv);
    String toString(PVScalar pv);
    void  fromByte(PVField pv, byte from);
    void  fromShort(PVField pv, short from);
    void  fromInt(PVField pv, int from);
    void  fromLong(PVField pv, long from);
    void  fromUByte(PVField pv, byte from);
    void  fromUShort(PVField pv, short from);
    void  fromUInt(PVField pv, int from);
    void  fromULong(PVField pv, long from);
    void  fromFloat(PVField pv, float from);
    void  fromDouble(PVField pv, double from);
// For the following the element type must be pvByte, ...., pvDouble
    int toByteArray(PVScalarArray pv,
        int offset, int len, byte[]to, int toOffset);
    int toShortArray(PVScalarArray pv,
        int offset, int len, short[]to, int toOffset);
    int toIntArray(PVScalarArray pv,
        int offset, int len, int[]to, int toOffset);
    int toLongArray(PVScalarArray pv,
        int offset, int len, long[]to, int toOffset);
    int toFloatArray(PVScalarArray pv,
        int offset, int len, float[]to, int toOffset);
    int toDoubleArray(PVScalarArray pv,
        int offset, int len, double[]to, int toOffset);
    int fromByteArray(PVScalarArray pv,
        int offset, int len, byte[]from, fromOffset);
    int fromShortArray(PVScalarArray pv,
        int offset, int len, short[]from, fromOffset);
    int fromIntArray(PVScalarArray pv,
        int offset, int len, int[]from, fromOffset);
    int fromLongArray(PVScalarArray pv,
        int offset, int len, long[]from, fromOffset);
    int fromUByteArray(PVScalarArray pv,
        int offset, int len, byte[]from, fromOffset);
    int fromUShortArray(PVScalarArray pv,
        int offset, int len, short[]from, fromOffset);
    int fromUIntArray(PVScalarArray pv,
        int offset, int len, int[]from, fromOffset);
    int fromULongArray(PVScalarArray pv,
        int offset, int len, long[]from, fromOffset);
    int fromFloatArray(PVScalarArray pv,
        int offset, int len, float[]from, fromOffset);
    int fromDoubleArray(PVScalarArray pv,
        int offset, int len, double[]from, fromOffset);
    void newLine(StringBuilder builder, int indentLevel);
}
</pre>

<p>The array methods all return the number of elements copied or converted.
This can be less than <code>len</code> if the
<code>PVField</code> array contains less than len elements.</p>

<p><code>newLine</code> is a convenience method
for code that implements <code>toString</code> It
generates a newline and inserts blanks at the beginning of the newline.</p>

<p>The getString methods dump the data in the metadata syntax described in the
pvData project overview. Note that the <code>toString</code> methods of <code>PVField</code> are
implemented by calling these convert methods.</p>

<h3>StandardField and StandardPVField</h3>
<p><b>Warning:</b>
The concept of <code>StandardField</code> is closely related to property which is described below.
The section on property provides details about alarm,
timeStamp, display, control, and enumerated.
That section should be read in conjunction with this section.</p>
<p>A standard field is a field that tools know how to use.
pvData defines and provides support for the following standard fields.</p>
<dl>
  <dt>enumerated</dt>
    <dd>This is a structure that has two subfields: index, and choices</dd>
  <dt>value</dt>
   <dd>This is any field with the name "value".
    It can be any type.
    The other standard fields can provide "properties" for the value field.
   </dd>
  <dt>timeStamp</dt>
    <dd>Encodes a time stamp. It can be a standalone field or be a property
    if a value field, in which case it should be a subfield of the same structure
    as the value field.</dd>
  <dt>alarm</dt>
    <dd>Encodes an alarm. It is normally a property
    if a value field, in which case it should be a subfield of the same structure
    as the value field.</dd>
  <dt>display</dt>
    <dd>Encodes a set of information for displaying a scalar or scalarArray value.
     It is normally a property
    if a value field, in which case it should be a sub field of the same structure
    as the value field.</dd>
  <dt>control</dt>
    <dd>Encodes a set of information for limits for a scalar or scalarArray value.
     It is normally a property
    if a value field, in which case it should be a sub field of the same structure
    as the value field.</dd>
  <dt>valueAlarm</dt>
    <dd>Defines a set of values for setting alarm values for a scalar value.
     It has separate definitions for booleanAlarm, byteAlarm, shortAlarm,
     intAlarm, longAlarm, floatAlarm, and doubleAlarm.
     There is also an enumeratedAlarm for an enumerated value field.</dd>
</dl>
<h4>StandardField</h4>
<pre>
interface StandardField {
    Structure scalar(ScalarType scalarType,String properties);
    Structure scalarArray(ScalarType elementType, String properties);
    Structure structureArray(Structure structure,String properties);
    Structure enumerated();
    Structure enumerated(String properties);
    Structure alarm();
    Structure timeStamp();
    Structure display();
    Structure control();
    Structure booleanAlarm();
    Structure byteAlarm();
    Structure shortAlarm();
    Structure intAlarm();
    Structure longAlarm();
    Structure floatAlarm();
    Structure doubleAlarm();
    Structure enumeratedAlarm();
}
</pre>
where
<dl>
   <dt>scalar</dt>
     <dd>Create a <code>Structure</code> that has a scalar field named value and with the
      specified <code>ScalarType</code>.
     The structure can have additional fields that are properties of the value field.
     properties is some combination of
     alarm, timeStamp, display, control, and valueAlarm.</dd>
   <dt>scalarArray</dt>
     <dd>Create a <code>Structure</code> that has a scalarArray field named value and with the
      specified element type.
     The structure can have additional fields that are properties of the value field.
     properties is some combination of
     alarm, timeStamp, display, and control.</dd>
   <dt>structureArray</dt>
     <dd>Create a Structure that has a structureArray field named value and with the
      specified structure as the introspection interface for each array element.
     The structure can have additional fields that are properties of the value field.
     properties is some combination of alarm and timeStamp.</dd>
   <dt>enumerated()</dt>
      <dd>Create an enumerated <code>Structure</code></dd>
   <dt>enumerated(String properties)</dt>
     <dd>Create a Structure that has an enumerated structure field named value.
      The structure can have additional fields that are properties of the value field.
     properties is some combination of
     alarm, timeStamp, and enumeratedAlarm.</dd>
   <dt>alarm</dt>
     <dd>Create an alarm <code>Structure</code>.</dd>
   <dt>timeStamp</dt>
     <dd>Create a timeStamp <code>Structure</code>.</dd>
   <dt>display</dt>
     <dd>Create an display <code>Structure</code>.</dd>
   <dt>control</dt>
     <dd>Create a control <code>Structure</code>.</dd>
   <dt>booleanAlarm</dt>
     <dd>Create a booleanAlarm <code>Structure</code>.</dd>
   <dt>byteAlarm</dt>
     <dd>Create a byteAlarm <code>Structure</code>.</dd>
   <dt>shortAlarm</dt>
     <dd>Create a shortAlarm <code>Structure</code>.</dd>
   <dt>intAlarm</dt>
     <dd>Create a intAlarm <code>Structure</code>.</dd>
   <dt>longAlarm</dt>
     <dd>Create a longAlarm <code>Structure</code>.</dd>
   <dt>floatAlarm</dt>
     <dd>Create a floatAlarm <code>Structure</code>.</dd>
   <dt>doubleAlarm</dt>
     <dd>Create a doubleAlarm <code>Structure</code>.</dd>
   <dt>enumeratedAlarm</dt>
     <dd>Create a enumearatedAlarm <code>Structure</code>.</dd>
</dl>
<h4>StandardPVField</h4>
<pre>
interface StandardPVField {
    PVStructure scalar(ScalarType type,String properties);
    PVStructure scalarArray(ScalarType elementType, String properties);
    PVStructure structureArray(Structure structure,String properties);
    PVStructure enumerated(String[] choices);
    PVStructure enumerated(String[] choices,String properties);
}
</pre>
where
<dl>
   <dt>scalar</dt>
     <dd>Create a <code>PVStructure</code> that has a scalar field named value and with the
      specified <code>ScalarType</code>.
     The structure can have additional fields that are properties of the value field.
     properties is some combination of
     alarm, timeStamp, display, control, and valueAlarm.</dd>
   <dt>scalarArray</dt>
     <dd>Create a <code>PVStructure</code> that has a scalarArray field named value and with the
      specified elementType.
     The structure can have additional fields that are properties of the value field.
     properties is some combination of
     alarm, timeStamp, display, and control.</dd>
   <dt>structureArray</dt>
     <dd>Create a <code>PVStructure</code> that has a structureArray field named value and with the
      specified structure as the introspection interface for each array element.
     The structure can have additional fields that are properties of the value field.
     properties is some combination of alarm and timeStamp.</dd>
   <dt>enumerated(String[] choices)</dt>
      <dd>Create an enumerated <code>PVStructure</code>.
       The choices field is initialized with choices and set immutable.
      </dd>
   <dt>enumerated(String[] choices,String properties)</dt>
     <dd>Create a <code>PVStructure</code> that has an enumerated structure field named value.
       The choices field of value is initialized with choices and set immutable.
      The structure can have additional fields that are properties of the value field.
     properties is some combination of
     alarm, timeStamp, and enumeratedAlarm.</dd>
</dl>
<h3>Examples</h3>

<h4>Accessing pvData</h4>

<p>Assume that code wants to access two fields from a <code>PVStructure</code>:</p>
<dl>
  <dt>value</dt>
    <dd>Must be a <code>PVDouble</code>.</dd>
  <dt>timeStamp</dt>
    <dd>Just look for field with this name.</dd>
</dl>

<p>The following code uses introspection to get the desired information.</p>
<pre>String getValueAndTimeStamp(PVStructure pvStructure) {
   PVField valuePV = pvStructure.getSubField("value");
   if(valuePV==null) {
       return "value field not found";
   }
   if(valuePV.getField.getType!=Type.scalar) {
       return "value field is not a scalar";
   }
   Scalar scalar = (Scalar)valuePV.getField();
   if(scalar.getScalarType!=ScalarType.pvDouble) {
       return "value field is not a double";
   }
   PVDouble pvDouble = (PVDouble)valuePV;
   PVField timeStampPV = pvStructure.getSubField("timeStamp");
   if(timeStampPV==null) {
       return "timeStamp field not found";
   }
   double value = valuePV.get();
   return value + " timeStamp " + timeStampPV.toString();
}</pre>

<h4>Creating pvData</h4>

<p>Example of creating a scalar field.</p>
<pre>
PVDataCreate pvDataCreate = PVDataFactory.getPVDataCreate();
PVDouble pvValue = pvDataCreate.createPVScalar(ScalarType.pvDouble);
</pre>

<p>Create a structure.</p>
<pre>    
FieldCreate fieldCreate = FieldFactory.getFieldCreate();
PVDataCreate pvDataCreate = PVDataFactory.getPVDataCreate();

PVStructure create() {
    Field[] fields = new Field[2];
    String[] fieldNames = new String[2];
    fields[0] = fieldCreate.createScalar(ScalarType.pvLong);
    fields[1] = fieldeCreate.createScalar(ScalarType.pvInt);
    fieldNames[0] = "a";
    fieldNames[1] = "b";
    PVStructure pvStructure = pvDataCreate.createPVStructure(
        fieldNames,fields);
    return(pvStructure);
}
</pre>

<p>FieldBuilder provides an easier way to accomplish the previous:</p>
<pre>
PVStructure create() {
   return pvDataCreate.createPVStructure(
        fieldCreate.createFieldBuilder()
          .add("a",ScalarType.pvLong)
          .add("b",ScalarType.pvInt)
          .createStructure());
}
</pre>

<p>StandardPVField also provides an easy way to create fields. For example:</p>
<pre>
StandardPVField standardPVField = StandardPVFieldFactory.getStandardPVField();
PVStructure pvStructure = standardPVField.scalar(
    ScalarType.pvDouble,
    "alarm,timeStamp.display,control,valueAlarm");
</pre>

<h2 >Package org.epics.pvdata.factory</h2>

<p>This package provides factories and classes to implement everything defined
in package org.epics.pvdata.pv
Look at the code for details.
</p>

<h2 >Package org.epics.pvdata.property</h2>

<h3>Definition of Property</h3>

<p>A field can have properties provided by other fields in the same structure.
Often this field has the name <b>value</b>
A record can have multiple value
fields, which can appear in the top-level structure of a record or in a
substructure. All other fields in the structure containing a value field are
considered properties of the value field. The field name is also the property
name. The value field can have any type, i.e. scalar, scalarArray, or
structure. Typical property fields are timeStamp, alarm, display, control, and
history. The timeStamp is a special case. If it appears anywhere in the
structure hierarchy above a value field it is a property of the value field.</p>

<p>For example the following top-level structure has a single value field. The
value field has properties alarm, timeStamp, and display.</p>
<pre>
structure counterOutput
    double value
    alarm_t
        int severity 0
        int status 0
        string message
    double value
    display_t
        double limitLow 0.0
        double limitHigh 10.0
        string description "Sample Description"
        string format "%f"
        string units volts
</pre>

<p>The following example has three value fields each with properties alarm and
timeStamp. Voltage, Current, and Power each have a different alarms but all
share the timeStamp.</p>
<pre>structure powerSupplyValue
    double value
    alarm_t
        int severity 0
        int status 0
        string message

structure powerSupplySimple
    alarm_t
        int severity 0
        int status 0
        string message
    timeStamp_t
        long secondsPastEpoch
        int nanoseconds
        int userTag
    powerSupplyValue_t voltage
        double value
        alarm_t
            int severity 0
            int status 0
            string message
    powerSupplyValue_t power
        double value
        alarm_t
            int severity 0
            int status 0
            string message
    powerSupplyValue_t current
        double value
        alarm_t
            int severity 0
            int status 0
            string message
</pre>

<h3>Standard Properties</h3>

<p>The following field names have special meaning, i.e. support properties for
general purpose clients.</p>
<dl>
  <dt>value</dt>
    <dd>This is normally defined since most general purpose clients access this
      field. All other fields in the structure support or describe the value
      field. The type can any supported type but is usually one of the
      following: 
      <dl>
        <dt>scalar</dt>
          <dd>Any of the scalar types.</dd>
        <dt>scalarArray</dt>
          <dd>An array with <code>elementType</code> being a scalar type</dd>
        <dt>enumerated structure</dt>
          <dd>A structure that includes fields named index and
            choices. index is an int that selects a choice.
            choices is an array of strings that
            defines the complete set of choices.</dd>
        <dt>other</dt>
          <dd>Other structure or array types can also be defined if clients and
            support code agree on the meaning. Some examples are: 1) A
            structure defining a 2D matrix, 2) A structure defining an image,
            3) A structure that simulates a remote method, ...</dd>
      </dl>
    </dd>
  <dt>timeStamp</dt>
    <dd>The timeStamp. The type MUST be a timeStamp structure. Also if the
      pvData structure does not have a timeStamp then a search up the parent
      tree is made to find a timeStamp.</dd>
  <dt>alarm</dt>
    <dd>The alarm. The type MUST be an alarm structure. </dd>
  <dt>display</dt>
    <dd>A display structure as described below. It provides display
      characteristics for the value field.</dd>
  <dt>control</dt>
    <dd>A control structure as described below. It provides control
      characteristics for the value field.</dd>
  <dt>history</dt>
    <dd>Provides a history buffer for the value field. Note that currently
      pvData does not define history support.</dd>
  <dt>other</dt>
    <dd>Other standard properties can be defined.</dd>
</dl>

<p>In addition a structure can have additional fields that support the value
field but are not recognized by most general purpose client tools. Typical
examples are:</p>
<dl>
  <dt>input</dt>
    <dd>A field with support that changes the value field. This can be
      anything. It can be a channel access link. It can obtain a value from
      hardware. Etc.</dd>
  <dt>valueAlarm</dt>
    <dd>A field with support that looks for alarm conditions based on the
    value.</dd>
  <dt>output</dt>
    <dd>A field with support that reads the current value and sends it
      somewhere else. This can be anything. It can be a channel access link. It
      can write a value to hardware etc.</dd>
</dl>

<p>The model allows for device records. A device record has structure fields
that that support the pvData data model. For example a powerSupport record can
have fields power, voltage and current that each support the pvData data model.
</p>

<h3>PVProperty Interfaces and Classes</h3>
<h4>PVProperty</h4>
<p>Interface and factory for finding a field within a structure.</p>
<pre>
interface PVProperty {
    PVField findProperty(PVField pvField,String fieldName);
    PVField findPropertyViaParent(PVField pvField,String propertyName);
    String[] getPropertyNames(PVField pvField);
}
</pre>
where
<dl>
  <dt>findProperty</dt>
    <dd>Find a field that is a subfield or property of this <code>PVField</code>. The fieldName
    is of the form name.name...  <code>pvField</code> must be named value or it does not
    have properties. </dd>
  <dt>findPropertyViaParent</dt>
    <dd>Find a property by searching up the parent tree. The property name is
    expected to match the name of a field. The return value is the interface to
    the first field found that is not a null structure or null if not found.</dd>
  <dt>getPropertyNames</dt>
    <dd>Get a String array that holds the names of the properties for this field.</dd>
</dl>
<h4>PVPropertyFactory</h4>
<pre>
public class PVPropertyFactory {
     public static PVProperty getPVProperty();
}
</pre>

<h3>Standard Properties</h3>

<p>This section has structure definitions that support standard properties.
These definitions are defined in project javaIOC.</p>

<h4>timeStamp</h4>

<p>A timeStamp is represented by the following structure</p>
<pre>
structure timeStamp
    long secondsPastEpoch
    int nanoseconds
    int userTag
</pre>

<p>The Epoch is the POSIX epoch, i.e. Jan 1, 1970 00:00:00 UTC. Both the
seconds and nanoseconds are signed integers and thus can be negative. Since the
seconds is kept as a 64 bit integer, it allows for a time much greater than the
present age of the universe. Since the nanoseconds portion is kept as a 32 bit
integer it is subject to overflow if a value that corresponds to a value that
is greater than a little more than 2 seconds of less that about -2 seconds. The
support code always adjust seconds so that the nanoSecconds part is normalized,
i. e. it has is 0&lt;=nanoseconds&lt;nanoSecPerSec..</p>
<h5>TimeStamp</h5>
<p>The Java definition of a timeStamp is:</p>
<pre>interface TimeStamp {
    static final long milliSecPerSec = 1000;
    static final long microSecPerSec = milliSecPerSec*milliSecPerSec;
    static final long nanoSecPerSec = milliSecPerSec*microSecPerSec;
    static final long  posixEpochAtEpicsEpoch = 631152000;
    void normalize();
    long getSecondsPastEpoch();
    long getEpicsSecondsPastEpoch();
    int getNanoseconds();
    int getUserTag();
    void setUserTag(int userTag);
    void put(long secondsPastEpoch,int nanoseconds);
    long getMilliSeconds();
    void put(long milliSeconds);
    void getCurrentTime();
    boolean equals(TimeStamp other);
    boolean lt(TimeStamp other);
    boolean le(TimeStamp other);
    void add(long seconds);
    void add(double seconds);
    double diff(TimeStamp a,TimeStamp b);
}</pre>

<p>where:</p>
<dl>
  <dt>normalize</dt>
    <dd>Adjust secondsPastEpoch and nanoseconds so that 0&lt;=nanoseconds&lt;
      nanoSecPerSec.</dd>
  <dt>getSecondsPastEpoch</dt>
    <dd>Get the seconds part of timeStamp</dd>
  <dt>getEpicsSecondsPastEpoch</dt>
    <dd>Get seconds relative to the EPICS epoch. The epics epoch starts on Jan
      1 1990 00:00:00 UTC.</dd>
  <dt>getNanoseconds</dt>
    <dd>Get the nanoseconds part of timeStamp.</dd>
  <dt>getUserTag</dt>
    <dd>Get the userTag</dd>
  <dt>setUserTag</dt>
    <dd>Set the userTag</dd>
  <dt>put(long secondsPastEpoch,int nanoseconds)</dt>
    <dd>Put a value into the timeStamp.</dd>
  <dt>getMilliSeconds</dt>
    <dd>Get the number of milliseconds since the epoch.</dd>
  <dt>put(long milliSeconds);</dt>
    <dd>Put a value into the timeStamp given the number of milliSeconds since
      the epoch.</dd>
  <dt>getCurrentTime</dt>
    <dd>Get the current time.</dd>
  <dt>equals</dt>
    <dd>Is this time equal other?</dd>
  <dt>lt</dt>
    <dd>Is this time less than other.</dd>
  <dt>le</dt>
    <dd>Is this time less that or equal to other.</dd>
  <dt>add(long seconds)</dt>
    <dd>Add the specified number of seconds.</dd>
  <dt>add(double seconds)</dt>
    <dd>Add the specified number of seconds.</dd>
  <dt>diff</dt>
    <dd>Compute a-b. The result is in seconds.</dd>
</dl>

<p>The TimeStamp class provides arithmetic and comparison methods for time
stamps. The result is always kept in normalized form, which means that the
nanosecond portion is 0&le;=nano&lt;nanoSecPerSec. Note that it is OK to have
timeStamps for times previous to the epoch.</p>
<h5>TimeStampFactory</h5>
<pre>
class TimeStampFactory implements TimeStamp {
    public static TimeStamp create();
}
</pre>
<h5>PVTimeStamp</h5>
<pre>
interface PVTimeStamp {
    boolean attach(PVField pvField);
    void detach();
    boolean isAttached();
    void get(TimeStamp timeStamp);
    boolean set(TimeStamp timeStamp);
}
</pre>
where
<dl>
  <dt>attach</dt>
    <dd>Attempts to attach to <code
     >pvField</code> It returns (false,true) if a
      timeStamp structure is found. It looks first at <code>pvField</code> itself and if is
      not an appropriate pvData structure but the field name is value it looks
      up the parent structure tree.</dd>
  <dt>detach</dt>
    <dd>Detach from the pvData structure.</dd>
  <dt>isAttached</dt>
    <dd>Is there an attachment to a time stamp structure?</dd>
  <dt>get</dt>
    <dd>Copies data from the pvData structure to a <code>TimeStamp</code>. An exception is
      thrown if not attached to a pvData structure. </dd>
  <dt>set</dt>
    <dd>Copies data from <code>TimeStamp</code> to the pvData structure. An exception is
      thrown if not attached to a pvData structure. </dd>
</dl>
<h5>PVTimeStampFactory</h5>
<pre>
class PVTimeStampFactory implements PVTimeStamp {
    public static PVTimeStamp create();
}</pre>

<h4>alarm</h4>

<p>An alarm structure is defined as follows:</p>
<pre>
structure alarm
    int severity
    int status
    string message
</pre>

<p>Note that severity and status are NOT defined as enumerated structures.
The reason is performance, i.e. prevent passing the array of choice strings everywhere.
The AlarmStatus and AlarmSeverity provide the equivalent of choices for an
enumerated structure.</p>
<h5>AlarmSeverity</h5>
<p>Alarm Severity defines the possible alarm severities</p>
<pre>
enum AlarmSeverity {
 NONE,MINOR,MAJOR,INVALID,UNDEFINED;

    public static AlarmSeverity getSeverity(int value);
    private static final String[] alarmSeverityNames;
    public static String[] getSeverityNames() { return alarmSeverityNames;}
}
</pre>
where
<dl>
  <dt>getSeverity</dt>
    <dd>Get the alarm severity corresponding to the integer value.</dd>
  <dt>getSeverityNames</dt>
    <dd>Get the array of severity choices.</dd>
</dl>
<h5>AlarmStatus</h5>
<p>Alarm Status defines the possible alarm status conditions</p>
<pre>
enum AlarmStatus {
    NONE,DEVICE,DRIVER,RECORD,DB,CONF,UNDEFINED,CLIENT;

    public static AlarmStatus getStatus(int value);
    private static final String[] alarmStatusNames;
    public static String[] getStatusNames() { return alarmStatusNames;}
}
</pre>
where
<dl>
  <dt>getStatus</dt>
    <dd>Get the alarm status corresponding to the integer value.</dd>
  <dt>getStatusNames</dt>
    <dd>Get the array of status choices.</dd>
</dl>
<h5>Alarm</h5>
<pre>
class Alarm {
    public Alarm();
    public String getMessage();
    public void setMessage(String message);
    public AlarmSeverity getSeverity();
    public void setSeverity(AlarmSeverity alarmSeverity);
    public AlarmStatus getStatus();
    public void setStatus(AlarmStatus alarmStatus);
}</pre>
where
<dl>
  <dt>Alarm</dt>
    <dd>The constructor. It sets the severity to no alarm and the message to
    "".</dd>
  <dt>getMessage</dt>
    <dd>Get the message.</dd>
  <dt>setMessage</dt>
    <dd>Set the message.</dd>
  <dt>getSeverity</dt>
    <dd>Get the severity.</dd>
  <dt>setSeverity</dt>
    <dd>Set the severity.</dd>
  <dt>getStatus</dt>
    <dd>Get the status.</dd>
  <dt>setStatus</dt>
    <dd>Set the status.</dd>
</dl>

<h5>PVAlarm</h5>
<pre>interface PVAlarm {
    boolean attach(PVField pvField);
    void detach();
    boolean isAttached();
    void get(Alarm alarm);
    boolean set(Alarm alarm);
}
</pre>
<p>where</p>
<dl>
  <dt>PVAlarm</dt>
    <dd>The default constructor. Attach must be called before get or set can be
      called.</dd>
  <dt>attach</dt>
    <dd>Attempts to attach to <code
     >pvField</code> It returns (false,true) if
      it found an appropriate pvData structure. It looks first a pvField itself
      and if is not an appropriate pvData structure but the field name is value
      it looks to see if the parent structure has an appropriate sub
    structure.</dd>
  <dt>detach</dt>
    <dd>Just detaches from the pvData structure.</dd>
  <dt>isAttached</dt>
    <dd>Is there an attachment to an alarm structure?</dd>
  <dt>get</dt>
    <dd>Copies data from the pvData structure to an <code>Alarm</code>. An exception is
      thrown if not attached to a pvData structure. </dd>
  <dt>set</dt>
    <dd>Copies data from <code>Alarm</code> to the pvData structure. An exception is thrown
      if not attached to a pvData structure. </dd>
</dl>
<h5>PVAlarmFactory</h5>
<pre>
class PVAlarmFactory implements PVAlarm{
    public static PVAlarm create();
}</pre>

<h4>control</h4>

<p>Control information is represented by the following structure</p>
<pre>
structure control
    double limitLow
    double limitHigh
    double minStep
</pre>
<h5>Control</h5>
The java definition for Control is: 
<pre>class Control {
    Control();
    double getLow();
    double getHigh();
    double getMinStep();
    void setLow(double value);
    void setHigh(double value);
    void setMinStep(double value);
}</pre>

<p>where</p>
<dl>
  <dt>Control</dt>
    <dd>The default constructor.</dd>
  <dt>getLow</dt>
    <dd>Get the low limit.</dd>
  <dt>getHigh</dt>
    <dd>Get the high limit.</dd>
  <dt>getMinStep</dt>
    <dd>Get the min step.</dd>
  <dt>setLow</dt>
    <dd>Set the low limit.</dd>
  <dt>setHigh</dt>
    <dd>Set the high limit.</dd>
  <dt>setMinStep</dt>
    <dd>Set the min step.</dd>
</dl>

<h5>PVControl</h5>
<pre>interface PVControl {
    boolean attach(PVField pvField);
    void detach();
    boolean isAttached();
    void get(Control control);
    boolean set(Control control);
}
</pre>
<p>where</p>
<dl>
  <dt>attach</dt>
    <dd>Attempts to attach to <code>pvField</code> It returns (false,true) if
      it found an appropriate pvData structure. It looks first <code>PVField</code> itself
      and if is not an appropriate pvData structure but the field name is value
      it looks to see if the parent structure has an appropriate sub-structure.
</dd>
  <dt>detach</dt>
    <dd>Just detaches from the pvData structure.</dd>
  <dt>isAttached</dt>
    <dd>Is there an attachment to a control structure?</dd>
  <dt>get</dt>
    <dd>Copies data from the pvData structure to a <code>Control</code>. An exception is
      thrown if not attached to a pvData structure. </dd>
  <dt>set</dt>
    <dd>Copies data from <code>Control</code> to the pvData structure. An exception is
      thrown if not attached to a pvData structure. </dd>
  <dt>create</dt>
    <dd>Create a PVControl instance. Attach must be called before get or set
      can be called.</dd>
</dl>
<h5>PVControlFactory</h5>
<pre>
class PVControlFactory{
    public static PVControl create();
}</pre>

<h4>Display</h4>

<p>Display information is represented by the following structure</p>
<pre>
structure display
    double limitLow
    double limitHigh
    string description
    string format
    string units
</pre>
<h5>Display</h5>
<pre>class Display {
    Display();
    double getLow();
    double getHigh();
    void setLow(double value);
    void setHigh(double value);
    String getDescription();
    void setDescription(String value);
    String getFormat();
    void setFormat(String value);
    String getUnits();
    void setUnits(String value);
}</pre>

<p>where</p>
<dl>
  <dt>Control</dt>
    <dd>The default constructor.</dd>
  <dt>getLow</dt>
    <dd>Get the low limit.</dd>
  <dt>getHigh</dt>
    <dd>Get the high limit.</dd>
  <dt>setLow</dt>
    <dd>Set the low limit.</dd>
  <dt>setHigh</dt>
    <dd>Set the high limit.</dd>
  <dt>getDescription</dt>
    <dd>Get the description.</dd>
  <dt>setDescription</dt>
    <dd>Set the description.</dd>
  <dt>getFormat</dt>
    <dd>Get the format.</dd>
  <dt>setFormat</dt>
    <dd>Set the format.</dd>
  <dt>getUnits</dt>
    <dd>Get the units.</dd>
  <dt>setUnits</dt>
    <dd>Set the units.</dd>
</dl>

<h5>PVDisplay</h5>
<pre>interface PVDisplay {
    boolean attach(PVField pvField);
    void detach();
    boolean isAttached();
    void get(Display display);
    boolean set(Display display);
}
</pre>

<p>where</p>
<dl>
  <dt>attach</dt>
    <dd>Attempts to attach to <code
     >pvField</code> It returns (false,true) if
      it found an appropriate pvData structure. It looks first a pvField itself
      and if is not an appropriate pvData structure but the field name is value
      it looks to see if the parent structure has an appropriate sub
    structure.</dd>
  <dt>detach</dt>
    <dd>Just detaches from the pvData structure.</dd>
  <dt>isAttached</dt>
    <dd>Is there an attachment to a display structure?</dd>
  <dt>get</dt>
    <dd>Copies data from the pvData structure to a <code>Display</code>. An exception is
      thrown if not attached to a pvData structure.</dd>
  <dt>set</dt>
    <dd>Copies data from a <code>Display</code> to the pvData structure. An exception is
      thrown if not attached to a pvData structure. </dd>
  <dt>create</dt>
    <dd>Create a <code>PVDisplay</code> instance. Attach must be called before get or set
      can be called.</dd>
</dl>
<h5>PVDisplayFactory</h5>
<pre>
class PVDisplayFactory implements PVDisplay{
    public static PVDisplay create()
}</pre>

<h4>enumerated structure</h4>

<p>An enumerated structure is a structure that has fields:</p>
<pre>structure
    int index
    string[] choices</pre>

<h5>PVEnumerated</h5>
<pre>interface PVEnumerated {
    boolean attach(PVField pvField);
    void detach();
    boolean isAttached();
    boolean setIndex(int index);
    int getIndex();
    String getChoice();
    boolean choicesMutable();
    String[] getChoices();
    boolean setChoices(String[] choices);
}
</pre>

<p>where</p>
<dl>
  <dt>PVEnumerated</dt>
    <dd>The default constructor. Attach must be called before any get or set
      method can be called.</dd>
  <dt>attach</dt>
    <dd>Attempts to attach to <code
     >pvField</code> It returns (false,true) if
      pvField (is not, is) an enumerated structure.</dd>
  <dt>detach</dt>
    <dd>Just detaches from the pvData structure.</dd>
  <dt>isAttached</dt>
    <dd>Is there an attachment to an enumerated structure?</dd>
  <dt>setIndex</dt>
    <dd>Set the index field in the pvData structure. An exception is thrown if
      not attached to a pvData structure. </dd>
  <dt>getIndex</dt>
    <dd>Get the index field in the pvData structure. </dd>
  <dt>getChoice</dt>
    <dd>Get the String value corresponding to the current index field in the
      pvData structure. An exception is thrown if not attached to a pvData
      structure. </dd>
  <dt>choicesMutable</dt>
    <dd>Can the choices be changed? Note that this is often true. An exception
      is thrown if not attached to a pvData structure. </dd>
  <dt>getChoices</dt>
    <dd>Get the array of choices. An exception is thrown if not attached to a
      pvData structure. </dd>
  <dt>getNumberChoices</dt>
    <dd>Get the number of choices. An exception is thrown if not attached to a
      pvData structure. </dd>
  <dt>setChoices</dt>
    <dd>Change the choices. An exception is thrown if not attached to a pvData
      structure. </dd>
</dl>

<h5>PVEnumeratedFactory</h5>
<pre>
class PVEnumeratedFactory{
    PVEnumerated create();
}</pre>
<h3>multiChoice</h3>

<p>NOTE: This is not currently used by anything.
Bob sees it as an important facility in the future.
</p>
<p>MultiChoice is support for a multiChoice structure,
which is a structure containing two fields:</p>
<dl>
   <dt>choices</dt>
     <dd>An array of strings</dd>
   <dt>bitMask</dt>
     <dd>A bitMask that selects a subset of the choices.</dd>
</dl>

<h4>MultiChoice</h4>
<pre>
    public interface MultiChoice {
        interface Choices {
            String[] getChoices();
            int getNumberChoices();
        }
        byte[] getBitMask();
        String[] getChoices();
        Choices getSelectedChoices();
        void setBit(int index);
        void clear();
        int registerChoice(String choice);
    }
</pre>
<p>where</p>
<dl>
  <dt>getBitMask</dt>
    <dd>Returns the bitMask.</dd>
  <dt>getChoices</dt>
    <dd>Returns the complete set of choices..</dd>
  <dt>getSelectedChoices</dt>
    <dd>Returns the interface for getting the selected choices..</dd>
  <dt>setBit</dt>
    <dd>Select the choice for specified bit..</dd>
  <dt>clear</dt>
    <dd>Clear the bitMask, i.e. no choices are selected..</dd>
  <dt>registerChoice</dt>
    <dd>Register a new choice. If the choice already exists then it's index
      is returned. If not it is appended to the choices.</dd>
</dl>
<h4>MultiChoiceFactory</h4>
<pre>
    public class MultiChoiceFactory{
         public static MultiChoice getMultiChoice(PVField pvField);
    }
</pre>

<h2 >Package org.epics.pvdata.misc</h2>

<h3>Overview</h3>

<p>This package provides utility code:</p>
<dl>
  <dt>BitSet</dt>
    <dd>An implementation of <code>BitSet</code> that can be serialized.</dd>
  <dt>MessageQueue</dt>
    <dd>Support for queuing messages for requesters.</dd>
  <dt>Thread</dt>
    <dd><code>ThreadCreate</code> and <code>Executor</code></dd>
  <dt>TimeFunction</dt>
    <dd>Time how long a function call requires.</dd>
  <dt>LinkedList</dt>
    <dd>A double linked list facility that requires the user to allocate a
      node. It is more efficient that <code>ArrayList</code> and does not require the
      implementation to allocate storage for the nodes.</dd>
  <dt>Timer</dt>
    <dd>An implementation of <code>Timer</code> that does not require an object to be
      created for each timer request.</dd>
  <dt>Queue</dt>
    <dd>A queue implementation.</dd>
  <dt>Destroyable</dt>
    <dd>A base interface for destroy.</dd>
  <dt>Serialize</dt>
    <dd>A helper for serialization.</dd>
</dl>


<h3>bitSet</h3>
<h4>BitSet</h4>
<p>This is adapted from the java.util.BitSet. It adds serializable. See
<code>java.util.BitSet</code> for a description. This implementation adds the following
additional methods:</p>
<pre>    public boolean getAndSet(int bitIndex);
    public void set(BitSet src);
    public void or_and(BitSet set1, BitSet set2);</pre>

<p>where</p>
<dl>
  <dt>getAndSet</dt>
    <dd>gets and sets the bit at bitIndex.</dd>
  <dt>set</dt>
    <dd>fast copy operation from src to <code>bitSet</code></dd>
  <dt>or_and</dt>
    <dd>The result is the or of the current bitSet with the value of set1.and
      set2. The number of bits is the
    Math.max(set1.bitsInUse,set2.bitsInUse);</dd>
</dl>

<p>This is an implementation of <code>BitSet</code> that supports serialization, which the
standard Jave implementation does not allow.</p>

<h4>BitSetUtil</h4>
<pre>interface BitSetUtil {
    boolean compress(BitSet bitSet,PVStructure pvStructure);
}
</pre>

<p>This provides functions that operate of a BitSet for a <code>PVStructure</code>. It
currently has only one method:</p>
<dl>
  <dt>compress</dt>
    <dd>Compress the bits in a <code>BitSet</code> related to a structure.<br />
      For each structure: 
      <ol>
        <li>If the bit for the structure is set then the bit for all subfields
          of the structure are cleared. </li>
        <li>If the bit for the structure is not set but all immediate subfields
          have their bit set then the bit for the structure is set and the bits
          for all subfields are cleared. </li>
      </ol>
      Note that this is a recursive algorithm. That is if every immediate
      subfield has it's offset bit set then the bits for ALL fields that reside
      in the structure will be cleared.</dd>
    <dd>Channel Access can call this before sending data. It can then pass
      entire structures if the structure offset bit is set. </dd>
</dl>
<h4>BitSetUtilFactory</h4>
<pre>
class BitSetUtilFactory {
    public static BitSetUtil getCompressBitSet();
}</pre>

<h3>Message Queue</h3>

<h4>MessageNode</h4>
<pre>
public class MessageNode {
    public String message;
    public MessageType messageType;
}
</pre>
<h4>MessageQueue</h4>
<pre>
public interface MessageQueue {
    MessageNode get();
    boolean put(String message,MessageType messageType,boolean replaceLast);
    boolean isEmpty();
    boolean isFull();
    int getClearOverrun();
}
</pre>
<p>This is for use by code that wants to handle messages without blocking
higher priority threads.</p>

<p><code>MessageNode</code> is a class with two public data members:</p>
<dl>
  <dt>message</dt>
<dd>The message.</dd>
  <dt>messageType</dt>
<dd>The message type.</dd>
</dl>

<p><code>MessageQueue</code> is an interface with methods:</p>
<dl>
  <dt>put</dt>
<dd>Put a new message into the queue. False is returned if the queue was
  full and true otherwise.</dd>
  <dt>isEmpty</dt>
<dd>Is the queue empty?</dd>
  <dt>isFull</dt>
<dd>Is the queue full?</dd>
  <dt>getClearOverrun</dt>
<dd>Get the number of times <code>replaceFirst</code> or <code>replaceLast</code> have been called
  since the last call to <code>getClearOverrun</code>. The internal counter is reset to
  0.</dd>
</dl>
<h4>MessageQueueFactory</h4>
<pre>
public class MessageQueueFactory {
    public static MessageQueue create(int size);
}</pre>
where
<dl>
  <dt>create</dt>
    <dd>Create a <code>MessageQueue</code> and return the interface.</dd>
</dl>

<h3>thread</h3>

<h4>ThreadPriority</h4>
<pre>
public enum ThreadPriority {
    lowest,
    lower,
    low,
    middle,
    high,
    higher,
    highest;
    
    public static final int[] javaPriority;
    public int getJavaPriority();
    public static int getJavaPriority(ThreadPriority threadPriority);
}
</pre>

<h4>ThreadReady</h4>
<pre>
interface ThreadReady {
    void ready();
}
</pre>
<h4>RunnableReady</h4>
<pre>
interface RunnableReady {
    void run(ThreadReady threadReady);
}
</pre>
<h4>ThreadCreate</h4>
<pre>
interface ThreadCreate {
    Thread create(String name, int priority, RunnableReady runnableReady);
    Thread[] getThreads();
}
</pre>
<h4>ThreadCreateFactory</h4>
<pre>
public class ThreadCreateFactory {
    public static ThreadCreate getThreadCreate();
}</pre>

<p>ThreadCreate provides two features:</p>
<ol>
  <li>Create does not return until <code>ReadyRunnable.run</code> calls
  <code>ThreadReady.ready()</code>.</li>
  <li>A list of all active threads is kept. getThreads provides access to the
list.</li>
</ol>

<h4>executor</h4>

<p>An <code>Executor</code> is a thread that can execute any object that implements the Java
<code>Runnable</code> interface. The user can request that a single command be executed. If
the command is already in the list of commands to be executed it is NOT added
to the list when add is called.</p>
<h5>ExecutorNode</h5>
<pre>
public interface ExecutorNode {}
</pre>
<h5>Executor</h5>
<pre>
public interface Executor {
    ExecutorNode createNode(Runnable command);
    void execute(ExecutorNode executorNode);
    void stop();
}
</pre>
<h5>ExecutorFactory</h5>
<pre>
public class ExecutorFactory {
    static public Executor create(String name,ScanPriority priority);
}</pre>
where 
<dl>
  <dt>createNode</dt>
<dd>Create a ExecutorNode that can be passed to execute.</dd>
  <dt>execute</dt>
<dd>Request that command be executed. If it is already on the run list
  nothing is done.</dd>
  <dt>stop</dt>
<dd>Stop the thread and refuse additional execute requests.</dd>
</dl>

<h3>time a function call</h3>

<p>TimeFunction is a facility that measures the average number of seconds a
function call requires. When <code>timeCall</code> is called, it calls function in a loop.
It starts with a loop of one iteration. If the total elapsed time is less then
.1 seconds it increases the number of iterations by a factor of 10. It keeps
repeating until the elapsed time is greater than .1 seconds. It returns the
average number of seconds per call.</p>
<h4>TimeFunctionRequester</h4>
<pre>
public interface TimeFunctionRequester {
    void function();
}
</pre>
<h4>TimeFunction</h4>
<pre>
public interface TimeFunction {
    double timeCall();
}
</pre>
<h4>TimeFunctionFactory</h4>
<pre>
public class TimeFunctionFactory {
    public static TimeFunction create(TimeFunctionRequester requester);
}</pre>

<h3>linked list</h3>

<p>LinkedList implements a double linked list that requires a user to allocate
the nodes. It is more efficient that <code>ArrayList</code> for implementing stacks and
queues. For lists that are traversed while new elements can be added or
removed, <code>LinkedListArray</code> provides a way to get an array of the current
elements without allocating a new array each time the array is traversed.</p>

<p><code>LinkedListArray</code> converts a <code>LinkedList</code> to an <code>LinkNode</code> array. The
implementation provided by <code>LinkedListFactory</code> only creates a new <code>LinkNode</code> array
w.en the number of elements in the linkedList passed to setNodes is greater
than the length of the current <code>LinkNode</code> array.</p>
<h4>LinkedListNode</h4>
<pre>
public interface LinkedListNode&lt;T&gt; {
    public T getObject();
    boolean isOnList();
} 
</pre>
<h4>LinkedList</h4>
<pre>
public interface LinkedList {
    void addTail(LinkedListNode&lt;T&gt; listNode);
    void addHead(LinkedListNode&lt;T&gt; listNode);
    void insertAfter(LinkedListNode&lt;T&gt; listNode,LinkedListNode&lt;T&gt; addNode);
    void insertBefore(LinkedListNode&lt;T&gt; listNode,LinkedListNode&lt;T&gt; addNode);
    LinkedListNode&lt;T&gt; removeTail();
    LinkedListNode&lt;T&gt; removeHead();
    void remove(LinkedListNode&lt;T&gt; listNode);
    void remove(T object);
    LinkedListNode&lt;T&gt; getHead();
    LinkedListNode&lt;T&gt; getTail();
    LinkedListNode&lt;T&gt; getNext(LinkedListNode&lt;T&gt; listNode);
    LinkedListNode&lt;T&gt; getPrev(LinkedListNode&lt;T&gt; listNode);
    boolean isEmpty();
    boolean contains(T object);
}
</pre>
<h4>LinkedListArray</h4>
<pre>
public interface LinkedListArray&lt;T&gt; {
    void setNodes(LinkedList&lt;T&gt; linkedList);
    LinkedListNode&lt;T&gt;[] getNodes();
    int getLength();
    void clear();
}
</pre>
<h4>LinkedListCreate</h4>
<pre>
public class LinkedListCreate&lt;T&gt; {
    public static LinkedList&lt;T&gt; create();
    public static LinkedListNode&lt;T&gt; createNode(Object object);
    public static LinkedListArray&lt;T&gt; createArray();
}</pre>

<p>LinkedListCreate is created as follows:</p>
<pre>
LinkedListCreate&lt;SomeObject&gt; linkedListCreate = new LinkedListCreate&lt;SomeObject&gt;();</pre>

<p>Then a linked list can be created as follows:</p>
<pre>
LinkedList&lt;SomeObject&gt; linkedList = linkedListCreate.create();</pre>

<p>The only way a node can be allocated is by calling
<code>linkedListCreate.createNode(object)</code>. The object passed to createNode
is what is returned by <code>LinkedList.getObject</code>. For example:</p>
<pre>
private static class SomeObject {
    private LinkedListNode&lt;SomeObject&gt; listNode = null;
    // other definitions


    private Node(/* arguments*/) {
        listNode = linkedListCreate.createNode(this);
    }

    LinkedListNode&lt;SomeObject&gt; getListNode() {return listNode};
}

// then

SomeObject someObject = new SomeObject(/* args */);
linkedList.addTail(someObject);</pre>

<p>A node can only be on one list at a time but can be put, at different times,
on different lists as long as they all hold the same type of objects.</p>

<p>The class does not provide a lock but the user can synchronized via calls
like:</p>
<pre>
synchronized(linkedList) {
    linkedList.addTail(listNode);
}</pre>

<p>The following is an example of how to use LinkedListArray.</p>
<pre>
    LinkedListNode&lt;SomeObject&gt;[] nodes = null;
    int length = 0;
    synchronized(linkedList) {
        linkedListArray.setNodes(linkedList);
        nodes = linkedListArray.getNodes();
        length = linkedListArray.getLength();
    }
    for(int i=0; i&lt;length; i++) {
        SomeObject object = nodes[i].getObject();
        // do something with object
    }</pre>

<h3>timer</h3>

<p>This provides a general purpose timer. It provides the following features
not provided by <code>java.util.Timer</code> and <code>java.util.TimerTask</code>:</p>
<ol>
  <li>Priority<br />
    The java.util implementation does not allow the user to specify the
    priority of the timer thread. This implementation does.</li>
  <li>TimerNode<br />
    A java.util.TimerTask is not reusable. Once a <code>TimerTask</code> has been canceled
    or a delay <code>TimerTask</code> has run, the <code>TimerTask</code> can not be reused. Instead a
    new <code>TimerTask</code> must be created. A <code>TimerNode</code> can be reused.</li>
</ol>

<h4>Timer</h4>
<pre>
interface Timer {
    interface TimerCallback {
        void callback();
        void timerStopped();
    }
    interface TimerNode {
        void cancel();
        boolean isScheduled();
    }
    void scheduleAfterDelay(TimerNode timerNode,double delay);
    void schedulePeriodic(TimerNode timerNode,double delay,double period);
    void stop();
}
</pre>
<p>This is the interface for scheduling a timer callback. A timer is created by
calling <code>TimerFactory.create</code>. It has the methods:</p>
<dl>
  <dt>scheduleAfterDelay</dt>
    <dd>A request to schedule a callback after a delay specified in seconds. If
      stop has been called then <code>TimerCallback.timerStopped</code> is called
      immediately.</dd>
  <dt>schedulePeriodic</dt>
    <dd>Schedule a periodic callback. If stop has been called then
      <code>TimerCallback.timerStopped</code> is called immediately.</dd>
  <dt>stop</dt>
    <dd>Stop the timer. The queue is emptied and <code>TimerCallback.timerStopped</code> is
      called for each element of the queue. Further schedule calls result in a
      call to <code>TimerCallback.timerStopped</code>. Once stopped a timer is no longer
      useful. A new timer must be created.</dd>
</dl>
<h4>TimerFactory</h4>
<pre>
class TimerFactory {
    static public Timer create(String threadName, ThreadPriority priority);
    static public TimerNode createNode(TimerCallback timerCallback);
}</pre>
<p>This is the factory that implements the <code>Timer</code> and <code>TimerNode</code> interfaces. It
has the methods:</p>
<dl>
  <dt>create</dt>
    <dd>Create a new Timer.</dd>
  <dt>createNode</dt>
    <dd>Create a <code>TimerNode</code>. A <code>TimerNode</code> can be used to schedule any timer but a
      <code>TimerNode</code> can only be on a single timer queue and only once on a given
      timer queue.</dd>
</dl>

<h4>TimerCallback</h4>

<p>This is an interface that must be implemented by the user. It has the
following methods: </p>
<dl>
  <dt>callback</dt>
    <dd>This is called when a timer expires. This is called with no locks held.
      When called a delay timer is no longer on the queue but a periodic timer
      is on a queue. Thus the callback for a delay timer can issue a new
      schedule request but a periodic timer must not. Note the explanation of
      <code>TimerNode.cancel</code> below.</dd>
  <dt>timerStopped</dt>
    <dd><code>Timer.stop</code> was called when a timer request was queued. or if the timer
      is stopped and a schedule request is made.</dd>
</dl>

<h4>TimerNode</h4>

<p>This is an interface implemented by <code>TimerFactory</code>. It is allocated by calling
<code>TimerFactory.createNode</code>. It is passed as an argument when scheduling a
callback. It has the single method:</p>
<dl>
  <dt>cancel</dt>
    <dd>This is called to cancel a timer request. If a callback has been
      dequeued but the callback not called when cancel is called then a
      callback may still happen. New schedule requests can be made after a
      cancel request has been made.</dd>
  <dt>isScheduled</dt>
    <dd>Is this node in the timerQueue.</dd>
</dl>

<h3>queue</h3>

<p>This provides a queue which has an immutable capacity, which is specified
when the queue is created. When the queue is full the user code is expected to
keep using the current element until a new free element becomes available. This
is used by <code>pvData.monitor</code>.</p>
<h4>QueueCreate</h4>
<pre>
public class QueueCreate&lt;T&gt; {
    public Queue&lt;T&gt; create(QueueElement&lt;T&gt;[] queueElements) {
        return new QueueImpl&lt;T&gt;(queueElements);
    }

    public QueueElement&lt;T&gt; createQueueElement(T object) {
        return new QueueElementImpl&lt;T&gt;(object);
    }
}
</pre>
<h4>QueueElement</h4>
<pre>
public interface QueueElement&lt;T&gt; {
    public T getObject();
}
</pre>
<h4>Queue</h4>
<pre>
public interface Queue&lt;T&gt; {
    void clear();
    int getNumberFree();
    int capacity();
    QueueElement&lt;T&gt; getFree();
    void setUsed(QueueElement&lt;T&gt; queueElement);
    QueueElement&lt;T&gt; getUsed();
    void releaseUsed(QueueElement&lt;T&gt; queueElement);
}</pre>

<p>The queue methods are:</p>
<dl>
  <dt>clear</dt>
    <dd>Make the queue empty.</dd>
  <dt>getNumberFree</dt>
    <dd>Get the number of fee elements in the queue.</dd>
  <dt>capacity</dt>
    <dd>Get the capacity, i.e. the maximum number of elements the queue can
      hold.</dd>
  <dt>getFree</dt>
    <dd>Get the next free element. Null is returned if no free elements are
      available. If a non null value is returned then the element belongs to
      the caller until setUsed is called.</dd>
  <dt>setUsed</dt>
    <dd>Set a queue element used. This <span
      style="font-weight:bold;">must</span> be the element returned by the last
      call to getFree. </dd>
  <dt>getUsed</dt>
    <dd>Get the next used element of null if no more used elements are
      available.</dd>
  <dt>releaseUsed</dt>
    <dd>Set a queue element free. This must be the element returned by the last
      call to getUsed. </dd>
</dl>

<p>A <code>QueueCreate</code> instance is created via a call like the following:</p>
<pre> QueueCreate&lt;MyObject&gt; queueCreate = new QueueCreate&lt;MyObject&gt;();</pre>

<p>Once a queueCreate is available a queue instance is created via code like
the following:</p>
<pre>Queue&lt;MyObject&gt; queue create(MyObject[] myObjects) {
    QueueElement&lt;MyObject&gt;[] queueElements = new QueueElement[length];
    for(int i=0; i&lt;length; i++) {
        QueueElement&lt;MonitorElement&gt; queueElement =
                 queueCreate.createQueueElement(myObjects[i);
        queueElements[i] = queueElement;
    }
    return queueCreate.create(queueElements);
}</pre>

<p>A producer calls <code>getFree</code> and <code>setUsed</code> via code like the following:</p>
<pre>
   MyObject getFree() {
       QueueElement&lt;MyObject&gt; queueElement = queue.getFree();
       if(queueElement==null) return null;
       return queueElement.getObject();
  }</pre>

<p>A consumer calls getUsed and releaseUsed via code like the following:</p>
<pre>
     while(true) {
         QueueElement&lt;MyObject&gt; queueElement = queue.getUsed();
         if(queueElement==null) break;
         MyObject myObject = queueElement.getObject();
         // do something with myObject
         queue.releaseUsed(queueElement);
     }</pre>

<h3>Destroyable</h3>

<p>This is a base interface used by many other interfaces.</p>
<pre>interface Destroyable  {
    void destroy();
}</pre>

<p>where</p>
<dl>
  <dt>destroy</dt>
    <dd>Destroy the object.</dd>
</dl>

<h3>SerializeHelper</h3>

<p>This is a helper class for serialization, which is required for sending and
receiving pvData over the network.</p>
<pre>class SerializeHelper {
    static void writeSize(final int s, ByteBuffer buffer);
    static int readSize(ByteBuffer buffer);
    static void serializeString(final String value, ByteBuffer buffer);
    static void serializeSubstring(final String value,
         int offset, int length, ByteBuffer buffer);
    static String deserializeString(ByteBuffer buffer);
}</pre>

<p>where</p>
<dl>
  <dt>writeSize</dt>
    <dd>Serialize the size.</dd>
  <dt>readSize</dt>
    <dd>Deserialize the size.</dd>
  <dt>serializeString</dt>
    <dd>Serialize a String.</dd>
  <dt>serializeSubstring</dt>
    <dd>Serialize a substring.</dd>
  <dt>deserializeString</dt>
    <dd>Deserialize a string.</dd>
</dl>


<h2>src/copy</h2>
<p><b>copy</b> is not used in this project.
It is intended for use by pvAccess and by channel providers.
It is provided with this project because the code depends only on
pvData itself.
</p>
<p><b>copy</b> provides the ability to create a structure that has 
a copy of an arbitrary subset of the fields in an existing top level
structure. In addition it allows global options and field specific options.
It has two main components: <b>createRequest</b> and <b>pvCopy</b>.
Given a string createRequest creates a pvRequest, which is a PVStructure
that has the format expected by <b>pvCopy</b>.
</p>
<p>In addition <b>pvCopy</b> supports filter plugins.
<b>pvData</b> implements the following filters:
<b>array</b>,
<b>deadband</b>,
<b>timestamp</b>,
<b>ignore</b>.
See the developerGuide for details.
</p>
<p>In addition the plugin API supports implementing additional plugins.
</p>

<p>Copy provides:</p>
<dl>
   <dt>createRequest</dt>
     <dd>
      The Channel create methods in pvAccess all have an argument
      <b>PVStructure pvRequest</b>.<br />
      Given an ascii string createRequest creates a PVStructure that provides
      a pvData representation of the information from the ascii string.
      It is this structure that can be passed to the channel create methods.<br />
      The information in a pvRequest selects an arbitrary subset of the
      fields in a top level structure that resides in the server.
      In addition options can be specified. Both global and field specific
      options can be specified.
      </dd>
   <dt>pvCopy</dt>
     <dd>This is a facility used by channel providers.
     It provides client specific code that manages a copy of an arbitrary
     subset of the fields in a top level structure that resides in the
     provider. It also allows provider access to options specified
     by the client.<br />
     pvCopy also provides filter plugin support.
     </dd>
</dl>

<h3>createRequest</h3>
<p>This is mainly used by pvAccess clients. Given a request string it creates
a pvRequest structure that can be passed to the pvAccess create methods.
In turn pvAccess passes the pvRequest to a local channel provider which 
then passes it to pvCopy.
</p>
<p>The definition of the public members is:</p>
<pre>
class CreateRequest {
...
     static CreateRequestPtr create();
     virtual PVStructurePtr createRequest(String const &amp;request);
     String getMessage();
};
</pre>
<p>An example of how it is used is:</p>
<pre>
CreateRequestPtr createRequest = CreateRequest::create();
PVStructurePtr pvRequest = createRequest-&gt;createRequest(request);
if(pvRequest==NULL) {
    String error = createRequest-&gt;getMessage();
    // take some action
} else {
    //success do something
}
</pre>
<h3>pvCopy</h3>
<p>The definition of the public members is:</p>
<pre>
class epicsShareClass PVCopyTraverseMasterCallback
{
...
    virtual void nextMasterPVField(PVFieldPtr const &amp;pvField);
};

class class epicsShareClass PVCopy
{
...
    static PVCopyPtr create(
        PVStructurePtr const &amp;pvMaster,
        PVStructurePtr const &amp;pvRequest,
        String const &amp; structureName);
    PVStructurePtr getPVMaster();
    void traverseMaster(PVCopyTraverseMasterCallbackPtr const &amp; callback);
    StructureConstPtr getStructure();
    PVStructurePtr createPVStructure();
    size_t getCopyOffset(PVFieldPtr const  &amp;masterPVField);
    size_t getCopyOffset(
        PVStructurePtr const  &amp;masterPVStructure,
        PVFieldPtr const  &amp;masterPVField);
     PVFieldPtr getMasterPVField(std::size_t structureOffset);
     void initCopy(
        PVStructurePtr const  &amp;copyPVStructure,
        BitSetPtr const  &amp;bitSet);
     void updateCopySetBitSet(
        PVStructurePtr const  &amp;copyPVStructure,
        BitSetPtr const  &amp;bitSet);
    void updateCopyFromBitSet(
        PVStructurePtr const  &amp;copyPVStructure,
        BitSetPtr const  &amp;bitSet);
    void updateMaster(
        PVStructurePtr const  &amp;copyPVStructure,
        BitSetPtr const  &amp;bitSet);
    PVStructurePtr getOptions(std::size_t fieldOffset);
...
};
</pre>
where
<dl>
   <dt>PVCopyTraverseMasterCallback::nextMasterPVField</dt>
     <dd>
       <b>PVCopyTraverseMasterCallback</b> is a callback which must
       be implemented by the code that uses pvCopy, normally
       the channel provider. It has the single method <b>nextMasterPVField</b>
       <br />
       <b>nextMasterPVField</b> is called for each field in the master
       as a result of a call to <b>traverseMaster</b>.
     </dd>
   <dt>create</dt>
      <dd>
        This is the method for creating a PVCopy instance.<br/>
        <dl>
           <dt>pvMaster</dt>
             <dd>the top-level structure managed by the server.</dd>
          <dt>pvRequest</dt>
           <dd>selects the set of subfields desired
         and options for each field.</dd>
          <dt>structureName</dt>
            <dd>the name for the top-level of any <code>PVStructure</code> created.
            </dd>
        </dl>
      </dd>
   <dt>getPVMaster</dt>
      <dd>
       Gets the top-level structure from <code>pvMaster</code>.
      </dd>
   <dt>traverseMaster</dt>
      <dd>
      Traverse all fields of the top-level structure of <code>pvMaster</code>.
      For each field the callback is called.
      </dd>
   <dt>getStructure</dt>
      <dd>
       Get the introspection interface for a <code>PVStructure</code> for copy.
      </dd>
   <dt>createPVStructure</dt>
      <dd>Create a copy instance.
       Monitors keep a queue of monitor elements.
     Since each element needs a <code>PVStructure</code>, multiple top-level structures
     will be created.
      </dd>
   <dt>getCopyOffset</dt>
      <dd>Given a field in <code>pvMaster</code>.
       return the offset in copy for the same field.
      A value of String::npos means that the copy does not have this field.
      Two overloaded methods are provided. The first is called if
      the field of master is not a structure. The second is for
      subfields of a structure.
      </dd>
   <dt>getMasterPVField</dt>
      <dd>
       Given a offset in the copy get the corresponding field in pvMaster.
      </dd>
   <dt>initCopy</dt>
      <dd>
       Initialize the fields in <code>copyPVStructure</code>
       by giving each field the  value from the corresponding field in <code>pvMaster</code>.
       <code>bitSet</code> will be set to show that all fields are changed.
       This means that bit set will have the value <b>{0}</b>.
      </dd>
   <dt>updateCopySetBitSet</dt>
      <dd>
      Set all fields in <code>copyPVStructure</code> to the value of the corresponding field
      in <code>pvMaster</code>. Each field that is changed has it's corresponding
      bit set in bitSet.
      </dd>
   <dt>updateCopyFromBitSet</dt>
      <dd>
       For each set bit in bitSet set the field in <code>copyPVStructure</code> to the value
      of the corresponding field in <code>pvMaster</code>.
      </dd>
   <dt>updateMaster</dt>
      <dd>
       For each set bit in bitSet set the field in <code>pvMaster</code> to the value
      of the corresponding field in <code>copyPVStructure</code>.
      
      </dd>
   <dt>getOptions</dt>
      <dd>
       Get the options for the field at the specified offset.
      A NULL is returned if no options were specified for the field.
      If options were specified, the returned<code>PVStructure</code> is 
      a structure with a set of <code>PVString</code> subfields that specify name,value
      pairs. name is the subField name and value is the subField value.
      </dd>
</dl>

<h2>src/monitor</h2>
<p><b>monitor</b> is not used in this project.
It is intended for use by pvAccess and by channelProviders.
It provided with this project because the code depends only on
pvData itself.
It is support code for channel providers that implement channel
monitor.
It provides support for monitor queues.
</p>

<h3>monitor</h3>
<pre>
class MonitorElement {
    MonitorElement(PVStructurePtr const &amp; pvStructurePtr);
    PVStructurePtr pvStructurePtr;
    BitSetPtr changedBitSet;
    BitSetPtr overrunBitSet;
};

class Monitor {
    virtual Status start() = 0;
    virtual Status stop() = 0;
    virtual MonitorElementPtr poll() = 0;
    virtual void release(MonitorElementPtr const &amp; monitorElement) = 0;
};

class MonitorRequester : public virtual Requester {
    virtual void monitorConnect(Status const &amp; status,
        MonitorPtr const &amp; monitor, StructureConstPtr const &amp; structure) = 0;
    virtual void monitorEvent(MonitorPtr const &amp; monitor) = 0;
    virtual void unlisten(MonitorPtr const &amp; monitor) = 0;
};
</pre>
<h4>monitorElement</h4>
<p><b>MonitorElement</b> holds the data for one element of a monitor queue.
It has the fields:
</p>
<dl>
  <dt>pvStructurePtr</dt>
    <dd>A top-level structure with data values at the time the monitors occurs.</dd>
  <dt>changedBitSet</dt>
     <dd>Shows which fields have changed since the previous monitor.</dd>
  <dt>overrunBitSet</dt>
     <dd>Shows which fields have changed more than once since the previous monitor.</dd>
</dl>
<h4>monitorElement queue</h4>
<p>
A queue of monitor elements must be implemented by any channel provider that implements
<b>Channel::createMonitor</b>.
For an example implementation look at pvDatabaseCPP.
It has the following:
</p>
<pre>
typedef Queue&lt;MonitorElement&gt; MonitorElementQueue;
typedef std::tr1::shared_ptr&lt;MonitorElementQueue&gt; MonitorElementQueuePtr;

class MultipleElementQueue :
    public ElementQueue
{
public:
    POINTER_DEFINITIONS(MultipleElementQueue);
    virtual ~MultipleElementQueue(){}
    MultipleElementQueue(
        MonitorLocalPtr const &amp;monitorLocal,
        MonitorElementQueuePtr const &amp;queue,
        size_t nfields);
    virtual void destroy(){}
    virtual Status start();
    virtual Status stop();
    virtual bool dataChanged();
    virtual MonitorElementPtr poll();
    virtual void release(MonitorElementPtr const &amp;monitorElement);
...
};
</pre>
<h4>Monitor</h4>
<p><b>Monitor</b> must be implemented by any channel provider that implements
<b>Channel::createMonitor</b>.
Remote PVAccess also implements Monitor on the client side.
Note that each client has it's own queue that is not shared with other client.
</p>
<p>Monitor has the following methods:</p>
<dl>
   <dt>start</dt>
     <dd>
      Start monitoring.
      This will result in an initial monitor that has the current value
      of all fields.
     </dd>
   <dt>stop</dt>
     <dd>
      Stop monitoring.
     </dd>
   <dt>poll</dt>
     <dd>
      Called to get a monitor element.
      If no new elements are available then a null pointer is returned.
     </dd>
   <dt>release</dt>
     <dd>
      Release the monitor element.
      The caller owns the monitor element between the calls to <code>poll</code> and <code>release</code>.
     </dd>
</dl>
<h4>MonitorRequester</h4>
<p>This must be implemented by a pvAccess client.
It has the methods:</p>
<dl>
  <dt>monitorConnect</dt>
     <dd>
      A monitor has either connected of disconnected.
     </dd>
  <dt>monitorEvent</dt>
     <dd>
      A new monitor element is available.
     </dd>
  <dt>unlisten</dt>
     <dd>
      The channel is going away. The client cam no longer access the monitor.
     </dd>
</dl>

</div>
</body>
</html>
