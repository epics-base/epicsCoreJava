<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
      "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="content-type" content="text/html; charset=iso-8859-1" />
  <title>EPICS pvDataJava</title>
    <link rel="stylesheet" type="text/css" href="http://epics-pvdata.sourceforge.net/base.css" />
  <link rel="stylesheet" type="text/css" href="http://epics-pvdata.sourceforge.net/epicsv4.css" />

  <style type="text/css">
  /*<![CDATA[*/
     .about { margin-left: 3em; margin-right: 3em; font-size: .83em}
     table { margin-left: auto; margin-right: auto }
     .diagram { text-align: center; margin: 2.5em 0 }
     span.opt { color: grey }
     span.nterm { font-style:italic }
     span.term { font-family:courier }
     span.user { font-family:courier }
     span.user:before { content:"<" }
     span.user:after { content:">" }
     .nonnorm { font-style:italic }
     p.ed.priv { display: inline; }
     span.ed.priv { display: inline; }
     hr { border: none; background-color: #ccc; color: #ccc; height: 1px }
  /*]]>*/</style>
  <!-- Script that generates the Table of Contents -->
  <script type="text/javascript" src="http://epics-pvdata.sourceforge.net/script/tocgen.js"></script>

</head>
<body>


<div class="head">
<h1>EPICS pvDataJava</h1>
<!-- Maturity: Working Draft or Request for Comments, or Recommendation, and date.  -->

<h2 class="nocount">EPICS v4 Working Group, Working Draft, 18-August-2014</h2>

  <dl>
    <dt>Latest version:</dt>
    <dd><a
      href="pvDataJava.html">pvDataJava.html</a>
    </dd>
    <dt>This version:</dt>
    <dd><a
      href="pvDataJava_20140708.html">pvDataJava_20140708.html</a>
    </dd>
    <dt>Previous version:</dt>
    <dd> <a
      href="pvDataJava_20120903.html">pvDataJava_20120903.html</a>
      </a>
    </dd>
    <dt>Editors:</dt>
    <dd>Marty Kraimer, BNL</dd>
  </dl>

  <p class="copyright">This product is made available subject to acceptance of the <a
href="http://epics-pvdata.sourceforge.net/LICENSE.html">EPICS open source
license.</a></p>
<hr />  
</div>

<h2 class="nocount">Abstract</h2>

<p>pvDataJava is a computer software package for the efficient 
storage, access, and communication, of structured data. It is specifically the
Java implementation of pvData, which is one part of the set of related products in the EPICS
V4 control system programming environment:<br />
<a href="http://epics-pvdata.sourceforge.net/relatedDocumentsV4.html">relatedDocumentsV4.html</a>
</p>


<h2 class="nocount">Status of this Document</h2>

<p>For now this is a working copy so it is not the same as "This version" shown above.</p>

<p>This is the 18-August-2014 version of the Java implementation of pvData.
This version describes the new types union and unionArray.
It also describes CreateRequest, which has been moved from pvAccess to pvData,
and PVCopy, which has been moved from pvIOCCPP and now only depends on
pvData.</p>

<p> The text describes software which is a complete implementation of pvData as
currently planned by the EPICS V4 Working Group. </p> </p>


<div id="toc">
<h2 class="nocount" style="page-break-before: always">Table of Contents</h2>
</div>
<div id="contents" class="contents">

<h2>Introduction</h2>

<p>pvData is one of a set of related packages in the EPICS V4 core sofware. It
describes and implements the data management system to which the the other projects
interface.</p>

<p>pvData (Process Variable Data) defines and implements an efficent way to
store, access, and communicate memory resident data structures.</p>
<dl>
  <dt>definition</dt>
    <dd>Package org.epics.pvdata.pv has Java interface definitions that define
      pvData. Although defined with Java syntax they also document what is
      required for implementation in other languages such as C++.</dd>
  <dt>implementation</dt>
    <dd>The set of packages provided by this project provide a complete Java
      implementation of pvData. Project pvAccess is the network support for
      pvData, i.e. it provides a channel access client and server that fully
      support pvData. Project pvIOCJava provides an IOC (Input Output Controller)
      that supports pvData and provides record processing..</dd>
  <dt>efficient</dt>
    <dd>Small memory footprint, low cpu overhead, and concise code base.</dd>
  <dt>data storage</dt>
    <dd>pvData defines separate introspection and data interfaces. The
      introspection interfaces provide access to immutable objects, which
      allows introspection instances to be freely shared. The introspection
      interface for a process variable can be accessed without requiring access
      to the data.</dd>
  <dt>data access</dt>
    <dd>Client code can access pvData via the introspection and data
      interfaces. For "well known" data, e.g. image data, specialized interfaces
      can be provided without requiring any changes to the core software.</dd>
  <dt>data transfer</dt>
    <dd>The separation of introspection and data interfaces allows for
      efficient network data transfer. At connection time introspection
      information can be passed from server to client. Each side can create a
      data instance. The data is transferred between these instances. The data
      in the network buffers does not have to be self describing since each
      side has the introspection information.</dd>
  <dt>memory resident</dt>
    <dd>pvData only defines memory resident data.</dd>
  <dt>structured data</dt>
    <dd>pvData defines data as structures with subfields
      where each each subfield has a name and type.
      The types are defined next.</dd>
</dl>
<p>The pvData types are:</p>
<dl>
   <dt>scalar</dt>
   <dd>
      A scalar has one of the following scalarTypes:
      <dl>
         <dt>pvBoolean</dt>
           <dd><b>false</b> or <b>true</b>.</dd>
         <dt>pvByte, pvShort, pvInt, pvLong</dt>
            <dd>Signed integers of size 8,16,32,64 bits.</dd>
         <dt>pvUByte, pvUShort, pvUInt, pvULong</dt>
            <dd> Unsigned integers of size 8,16,32,64 bits.</dd>
         <dt>pvFloat, pvDouble</dt>
            <dd><b>IEEE</b> floating point numbers  of size 32 and 64 bits.</dd>
         <dt>pvString</dt>
            <dd>In Java a String and in C++ std::string</dd>
      </dl>
    </dd>
    <dt>scalarArray</dt>
    <dd>
      A scalarArray is a one dimensional array with the element
      has the same scalarType.
    </dd>
    <dt>structure</dt>
    <dd>
      A structure is an ordered set of fields where each field has a
      name and type.
      Since a field can have type structure complex structures can be created
      that simulate types.
     </dd>
     <dt>structureArray</dt>
     <dd>
      A structureArray is an array of structures where each element
      has the same structure introspection interface.
     </dd>
     <dt>union</dt>
     <dd>
      A union has a single sub-field with a variable type.
      A variant union allows the type to be any type.
      A regular union allows only a fixed set of types.
      </dd>
      <dt>unionArray</dt>
      <dd>
      A union array is an array of union fields where each element
      has the same introspection interface. Different elements can
      have different types but each must have a type determined by the
      union interface.
      </dd>
</dl>

<p>Project <b>pvIOCJava</b> implements a Process Variable (PV) Database,
which is a memory resident database holding pvData,
has the following features:</p>
<ul>
  <li>A database has records.</li>
  <li>Each record has a unique record name.</li>
  <li>A record has a top level PVStructure, which is a structured set of data
    as defined by this project.</li>
</ul>

<p>pvData was initially created to support the javaIOC and was part of the
javaIOC project.
The original javaIOC project has been broken up into many projects,
e. g. pvDataJava, pvAccessJava, pvIOCJava, pvServiceJava.
In addition there are C++ implementation of some of these projects.
pvData is intended for use by 1) pvAccess
clients, 2) Interface between client and network, 3) Interface between network
and pvAccess server, 4) Interface between server and IOC database.
Since it is an interface to data, it could also be used by other systems,
e.g. TANGO, TINE, etc.
A high level Physics application can hold data as pvData.
By starting a pvAccess server, the data can made available to network
clients.</p>

<p>pvData contains everything required, by pvAccess, to create and pass data
between pvAccess clients and servers. </p>

<h2 >PVData Meta Language</h2>

<p>This section describes a meta language for describing pvData.
Currently there are no plans for a parser for the meta language.
It is used for documentation. 
The meta language is used to describe both introspection interfaces and data interfaces.</p>
<p>The toString introspection and data methods described below 
present data in a format similar to the metadata syntax.
The C++ implementation uses streams I/O instead of toString
but it implements the same metadata syntax.
</p>

<h3>Definition</h3>

<p>PVData supports structured data. All data appears via top level structures.
A structure has an ordered set of fields where each field has a <span
style="font-family: courier;">fieldDef</span> defined as follows:</p>
<pre>type fieldName value // comment</pre>

<p>where <span>value</span> is present for data
objects and <span>//</span> indicates the the
rest of the line is a comment. </p>

<p>type is one of the following:</p>
<dl>
  <dt>scalar</dt>
   <dd>A scalar field can be any of the following: 
      <dl>
        <dt>boolean</dt>
          <dd>Has the value<span>true</span> or
            <span>false</span></dd>
        <dt>byte</dt>
          <dd>An 8 bit signed integer.</dd>
        <dt>short</dt>
          <dd>An 16 bit signed integer.</dd>
        <dt>int</dt>
          <dd>An 32 bit signed integer.</dd>
        <dt>long</dt>
          <dd>An 64 bit signed integer.</dd>
        <dt>ubyte</dt>
          <dd>An 8 bit unsigned integer.</dd>
        <dt>ushort</dt>
          <dd>An 16 bit unsigned integer.</dd>
        <dt>uint</dt>
          <dd>An 32 bit unsigned integer.</dd>
        <dt>ulong</dt>
          <dd>An 64 bit unsigned integer.</dd>
        <dt>float</dt>
          <dd>A IEEE float.</dd>
        <dt>double</dt>
          <dd>A IEEE double.</dd>
        <dt>string</dt>
          <dd>An immutable string.</dd>
      </dl>
    </dd>
  <dt>scalarArray</dt>
    <dd>A scalarArray field is an array of any of the scalar types. 
      <dl>
        <dt>boolean[]</dt>
        <dt>byte[]</dt>
        <dt>short[]</dt>
        <dt>int[]</dt>
        <dt>long[]</dt>
        <dt>ubyte[]</dt>
        <dt>ushort[]</dt>
        <dt>uint[]</dt>
        <dt>ulong[]</dt>
        <dt>float[]</dt>
        <dt>double[]</dt>
        <dt>string[]</dt>
      </dl>
    </dd>
  <dt>structure</dt>
    <dd>A structure field has the definition: 
      <pre>
structure fieldName
    fieldDef
    ...
      </pre>
      or 
      <pre>
xxx_t fieldName
    // if data object then following appear
    fieldDef
    ...
      </pre>
      For <b>structure fieldName</b> each
      <b>fieldDef</b> must have a unique
      <b>fieldName</b> within the <b>structure</b>
      For <b>"xxx_t fieldName"</b> xxx_t must be a
      previously structure definition of the form: 
      <pre>
structure xxx_t
    ...
      </pre>
    </dd>
  <dt>structureArray</dt>
    <dd>A structureArray field has the definition: 
      <pre>
structure[] fieldName
    structureDef
    ...
      </pre>
      <p>or</p>
      <pre>
xxx_t[] fieldName
      </pre>
      <p>Thus a structure array is an array where each element is a structure
      but all elements have the same introspection interface. For introspection
      the structureDef appears once without any data valuies.</p>
    </dd>
   <dt>union</dt>
      <dd>
       This has two flavors: a varient union or a union of a fixed set
       of types.
       A varient union has a single sub-field that can be of any type
       and has the name <b>any</b>.
       A regular union has a single sub-field has a type that is from
      a fixed set of types and a name associated with the type.
       The union introspection interface has a field array
       that has the types and a string array that has the names.<br />
      A varient union has the form:
      <pre>
union fieldName
    any any
      </pre>
      The following is an example of a regular union that can
      have one of three possible types: pvDouble, pvInt, or pvStructure
      where the structure is a timeStamp:
      <pre>
union value
    double doubleValue
    int intValue
    timeStamp timeStamp
        long secondsPastEpoch
        int nanoSeconds
        int userTag
      </pre>
      </dd>
   <dt>UnionArray</dt>
       <dd>
        This is an array of unions.
        Each element has the same interspection interface
         but the subifield of each element can have a different type.
       The following is an example of a union array:
       <pre>
any[]
    any
</pre>
       </dd>
</dl>

<p>The above is used to describe introspection objects. Data objects are
describe in a similar way but each scalar field and each array field has data
values. The definition of the data values depends on the type. For scalars the
data value is whatever is valid for the type.
For union only a single subfield will appear.
For a union array a single subfield will appear for each element.
</p>
<dl>
  <dt>boolean</dt>
    <dd>The value must be <span>true</span> or
      <span>false</span> </dd>
  <dt>byte,...ulong</dt>
    <dd>Any valid integer or hex value, e.g. <span
     >3 and 0x0ff</span> are valid values</dd>
  <dt>float,double</dt>
    <dd>Any valid integer or real e.g. <span>3,
      3.0, and 3e0</span> are valid values</dd>
  <dt>string</dt>
    <dd>The value can be an alphanumeric value or any set of characters
      enclosed in <span>""</span> Within quotes a
      quote is expressed as <span>\"</span>
      Examples are <span>aValue "a value" "a\"
      xxx"</span> are valid values. </dd>
</dl>

<p>For scalar arrays the syntax is:</p>
<pre>      = [value,...,value]</pre>

<p>where each <span>value</span> is a valid
scalar data value depending on the type. Thus it is a comma separated set of
values enclosed in <span>[]</span> White space is
permitted surrounding each comma.</p>

<h3>Examples</h3>

<p>Define the following top level structure:</p>
<pre>structure timeStamp_t
    long secondsPastEpoch
    int nanoSeconds </pre>

<p>Then the following introspection objects can be defined:</p>
<pre>structure scalarDoubleExample // introspection object
    double value
    timeStamp_t timeStamp</pre>
or 
<pre>structure scalarDoubleExample // introspection object
    double value
    structure timeStamp
        long secondsPastEpoch
        int  nanoSeconds</pre>

<p>The following data objects can be defined:</p>
<pre>structure scalarDoubleExample // data object
    double value 1.0
    timeStamp_t timeStamp
         long secondsPastEpoch 0
         int  nanoSeconds 0</pre>
or 
<pre>scalar arrayDoubleExample
    double[] value  [1.0,2.0]
    structure timeStamp
         long secondsPastEpoch 0
         int  nanoSeconds 0</pre>

<p>If the following interface is defined:</p>
<pre>structure point_t
    double x
    double y</pre>

<p>Then the following introspection objects can be defined: </p>
<pre>structure lineExample
    point_t begin
    point_t end

structure pointArrayExample
    point_t[] points
    </pre>
or 
<pre>structure lineExample
    structure begin
        double x
        double y
    structure end
        double x
        double y

structure pointArrayExample
    structure[] points
        structure point
            double x
            double y</pre>

<p>And the following data objects can be defined:</p>
<pre>structure lineExample
    point_t begin
        double x 0.0
        double y 0.0
    point_t end
        double x 10
        double y 10

structure pointArrayExample
    point_t[] value
        structure point
            double x 0.0
            double y 0.0
        structure point
            double x 10.0
            double y 10.0</pre>

<p>or</p>
<pre>structure lineExample
    structure begin
        double x 0
        double y 0
    structure end
        double x 10
        double y 10

structure pointArrayExample
    structure[] value
        structure point
            double x 0.0
            double y 0.0
        structure point
            double x 10.0
            double y 10.0</pre>

<h2 >Interface Definitions</h2>
<p>This section gives a <b>brief</b> description of the pvData intospection and data interfaces.
In this section the methods are shown but not described. See org.epics.pvdata.pv below for a
description of each method.</p>

<h3>Types</h3>

<p>The following are the type definitions:</p>
<pre>enum Type {
    scalar,
    scalarArray,
    structure,
    structureArray,
    union_t,
    unionArray;
}</pre>

<p>where</p>
<dl>
  <dt>scalar</dt>
    <dd>A field that has data with one of the scalarTypes.</dd>
  <dt>scalarArray</dt>
    <dd>A field that is an array where each element is the same scalarType.</dd>
  <dt>structure</dt>
    <dd>A field which has named subfields.</dd>
  <dt>structureArray</dt>
    <dd>A field that is an array of structures where each element has the same
      introspection interface, i.e. each element has the same structure.</dd>
  <dt>union</dt>
    <dd>A union has a single sub-field with a variable type.
     A variant union allows the type to be any type.
     A regular union allows only a fixed set of types
    </dd>
   <dt>unionArray</dt>
    <dd>
    A union array is an array of union fields where each element
    has the same introspection interface.
    Different elements can have different types but each must have
    a type determined by the union interface.
    </dd>
</dl>
<pre>enum ScalarType {
    pvBoolean,
    pvByte,pvShort,pvInt,pvLong,
    pvUByte,pvUShort,pvUInt,pvULong,
    pvFloat,pvDouble,
    pvString;
    // The following are convenience methods
    public boolean isInteger();
    public boolean isUInteger();
    public boolean isNumeric();
    public boolean isPrimitive();
    public static ScalarType getScalarType(String type);
    public String toString();
}</pre>

<p>where</p>
<dl>
  <dt>boolean</dt>
    <dd>true or false</dd>
  <dt>byte</dt>
    <dd>An 8 bit signed byte</dd>
  <dt>short</dt>
    <dd>16 bit signed integer</dd>
  <dt>int</dt>
    <dd>32 bit signed integer</dd>
  <dt>long</dt>
    <dd>64 bit signed integer</dd>
  <dt>ubyte</dt>
    <dd>An 8 bit unsigned byte</dd>
  <dt>ushort</dt>
    <dd>16 bit unsigned integer</dd>
  <dt>uint</dt>
    <dd>32 bit unsigned integer</dd>
  <dt>ulong</dt>
    <dd>64 bit unsigned integer</dd>
  <dt>float</dt>
    <dd>32 bit IEEE float</dd>
  <dt>double</dt>
    <dd>64 bit IEEE float</dd>
  <dt>string</dt>
    <dd>An immutable string. The Java implementation is String. For other
      implementations the network representation must be the same as for Java.
      Note that a string is treated like it is a scaler.</dd>
</dl>
<p><b>NOTE:</b> Java does not support unsigned integers so the Java implementation
of each unsigned type is implemented as the corresponding signed type.
The only exception is the Convert facility. When it performs a widening
operation, e.g. from ubyte to short, it performs the correct conversion.</p>

<h3>Introspection Interfaces</h3>

<p>Field is the base introspection interface. It has only an id and a type.</p>
<pre>interface Field extends Serializable {
    String getId();
    Type getType();
    void toString(StringBuilder buf);
    void toString(StringBuilder buf,int indentLevel);
    String toString();
}

interface Scalar extends Field {
    ScalarType getScalarType();
}

interface ScalarArray extends Field {
    ScalarType getElementType();
}

interface Structure extends Field {
    Field getField(String fieldName);
    int getFieldIndex(String fieldName);
    Field[] getFields();
    Field getField(int fieldIndex);
    String[] getFieldNames();
    String getFieldName(int fieldIndex)
}

interface StructureArray extends Field {
    Structure getStructure();
}

public interface Union extends Field{
    public static final String DEFAULT_ID = "union";
    public static final String ANY_ID = "any";
    Field getField(String fieldName);
    int getFieldIndex(String fieldName);
    Field[] getFields();
    Field getField(int fieldIndex);
    String[] getFieldNames();
    String getFieldName(int fieldIndex);
    boolean isVariant();
}

public interface UnionArray extends Field{
    Union getUnion();
}
</pre>

<p>The introspection interfaces provide access to immutable objects. This
allows introspection interfaces to be freely shared between data objects. For
example the introspection interface for a timeStamp, which is a structure
containing two fields, can be shared by every record that has a time stamp.</p>

<h3>Data Interfaces</h3>

<p>PVField is the base interface for a data field:</p>
<pre>interface PVField extends  Serializable {
    String getFieldName();
    String getFullName();
    int getFieldOffset();
    int getNextFieldOffset();
    int getNumberFields();
    boolean isImmutable();
    void setImmutable();
    Field getField();
    PVStructure getParent();
    void postPut();
    void setPostHandler(PostHandler postHandler);
    void toString(StringBuilder buf);
    void toString(StringBuilder buf,int indentLevel);
    String toString();
    // The following should go away.
    PVAuxInfo getPVAuxInfo();
}</pre>

<p>Each scalar type has an associated data interface: PVBoolean,
PVByte, PVShort, PVInt, PVLong,
PVUByte, PVUShort, PVUInt, PVULong,
PVFloat, PVDouble, and PVString. Each has a get and a
put method. For example:</p>
<pre>interface PVDouble extends PVScalar{
    double get();
    void put(double value);
}</pre>

<p>PVArray is the base class for arrays.</p>
<pre>interface PVArray extends PVField, SerializableArray {
    Array getArray();
    int getLength();
    void setLength(int length);
    int getCapacity();
    void setCapacity(int length);
    boolean isCapacityMutable();
    void setCapacityMutable(boolean isMutable);
}
</pre>

<p>PVScalarArray is the base class for scalar arrays.</p>
<pre>interface PVScalarArray extends PVArray {
    ScalarArray getScalarArray();
}</pre>

<p>For each scalar type an associated array data interface is defined. Each has
a get and put method. For example: </p>
<pre>public class DoubleArrayData {
    public double[] data;
    public int offset;
}

interface PVDoubleArray extends PVArray {
    int get(int offset, int len, DoubleArrayData data);
    int put(int offset,int len, double[] from, int fromOffset);
    void shareData(double[] from);
}</pre>

<p>PVStructureArray is the interface for an array of structures where each element
has the same iontrospection interface.</p>
<pre>public class StructureArrayData {
    public PVStructure[] data;
    public int offset;
}

interface PVStructureArray extends PVArray{
    StructureArray getStructureArray();
    int get(int offset, int length, StructureArrayData data);
    int put(int offset,int length, PVStructure[] from, int fromOffset);
    void shareData(PVStructure[] from);
}</pre>

<p>PVStructure is the data interface for a structure.</p>
<pre>
interface PVStructure extends PVField , BitSetSerializable{
    Structure getStructure();
    PVField[] getPVFields();
    PVField getSubField(String fieldName);
    PVField getSubField(int fieldOffset);
    &lt;T extends PVField&gt; T getSubField(Class&lt;T&gt; c, String fieldName);
    &lt;T extends PVField&gt; T getSubField(Class&lt;T&gt; c, int fieldOffset);
    // The following are convenience methods
    // Note that they are no longer needed because of above generic methods
    PVBoolean getBooleanField(String fieldName);
    PVByte getByteField(String fieldName);
    PVShort getShortField(String fieldName);
    PVInt getIntField(String fieldName);
    PVLong getLongField(String fieldName);
    PVFloat getFloatField(String fieldName);
    PVDouble getDoubleField(String fieldName);
    PVString getStringField(String fieldName);
    PVScalarArray getScalarArrayField(String fieldName);
    PVStructureArray getStructureArrayField(String fieldName);
    PVStructure getStructureField(String fieldName);
    PVArray getArrayField(String fieldName,ScalarType elementType);
    PVUnion getUnionField(String fieldName);
    PVUnionArray getUnionArrayField(String fieldName);
    public boolean checkValid();
}</pre>

<h3>Introspection and Data creation</h3>

<p>The following interface creates introspection instances:</p>
<pre>public interface FieldCreate {
    FieldBuilder createFieldBuilder();
    Scalar createScalar(ScalarType scalarType);
    ScalarArray createScalarArray(ScalarType elementType);
    StructureArray createStructureArray(Structure elementStructure);
    UnionArray createUnionArray(Union elementUnion);
    UnionArray createVariantUnionArray();
    Structure createStructure(String[] fieldNames, Field[] field);
    Structure createStructure(String id,String[] fieldNames, Field[] field);
    Structure appendField(Structure structure,String fieldName, Field field);
    Structure appendFields(Structure structure,String[] fieldNames, Field[] fields);
    Structure createStructure(Structure structToClone);
    Union createVariantUnion();
    Union createUnion(String[] fieldNames, Field[] fields);
    Union createUnion(String id, String[] fieldNames, Field[] fields);
    Field deserialize(ByteBuffer buffer, DeserializableControl control);
}</pre>

<p>The following is a convenience class for creating introspection objects:</p>
<pre>
public interface FieldBuilder
{
    public FieldBuilder setId(String id);
    public FieldBuilder add(String name, ScalarType scalarType);
    public FieldBuilder add(String name, Field field);
    public FieldBuilder addArray(String name, ScalarType scalarType);
    public FieldBuilder addArray(String name, Field element);
    public Structure createStructure();
    public Union createUnion();
    FieldBuilder addNestedStructure(String name); 
    FieldBuilder addNestedUnion(String name);
    FieldBuilder addNestedStructureArray(String name); 
    FieldBuilder addNestedUnionArray(String name);
    FieldBuilder endNested();
}
</pre>
<p>The following interface creates data instances:</p>
<pre>public interface PVDataCreate {
    PVField createPVField(Field field);
    PVField createPVField(PVField fieldToClone);
    PVScalar createPVScalar(Scalar scalar);
    PVScalar createPVScalar(ScalarType fieldType);
    PVScalar createPVScalar(PVScalar scalarToClone);
    PVScalarArray createPVScalarArray(ScalarArray array);
    PVScalarArray createPVScalarArray(ScalarType elementType);
    PVScalarArray createPVScalarArray(PVScalarArray arrayToClone;
    PVStructureArray createPVStructureArray(StructureArray structureArray);
    PVUnionArray createPVUnionArray(UnionArray unionArray);
    PVUnionArray createPVVariantUnionArray();
    PVStructure createPVStructure(Structure structure);
    PVStructure createPVStructure(String[] fieldNames,Field[] fields);
    PVStructure createPVStructure(PVStructure structToClone);
    PVUnion createPVUnion(Union union);
    PVUnion createPVVariantUnion();
    PVUnion createPVUnion(PVUnion unionToClone);
    &lt;T extends PVScalar, TA extends PVScalarArray&gt; T createPVScalar(
        PVScalarType&lt;T, TA&gt; scalarType);
    &lt;T extends PVScalar, TA extends PVScalarArray&gt; TA createPVScalarArray(
        PVScalarType&lt;T, TA&gt; elementType);
	
    PVStructureArray createPVStructureArray(Structure structure);
    PVUnionArray createPVUnionArray(Union union);
    PVField[] flattenPVStructure(PVStructure pvStructure);
}</pre>

<h3>pvData Conversion</h3>

<p>An interface named Convert provides all reasonable conversions to/from
pvData.
The convert utility is also used to implement the toString methods of PVField.
See org.epics.pvdata.pv.Convert for details.</p>

<h2 >Package Summary</h2>

<p>This document describes everything via Java definitions. The initial
implementation is in Java but the functionality is also implemented in C++ (See pvDataCPP for details).</p>

<p>pvData is distributed as a sourceforge mercurial project named pvDataJava.
It consists of the following java packages:</p>

<h3>org.epics.pvdata.pv</h3>

<p>The Java enum, interface, and class definitions that define pvData. This
section provides a complete definition of what pvData is.</p>

<h3>org.epics.pvdata.factory</h3>

<p>Provides everything required for creating pvData. It provides the following
factories:</p>
<dl>
  <dt>FieldFactory</dt>
    <dd>Creates introspection interfaces.</dd>
  <dt>PVDataFactory</dt>
    <dd>Creates data interfaces for all of the supported data types.</dd>
  <dt>ConvertFactory</dt>
    <dd>Converts between support data types.</dd>
  <dt>StatusFactory</dt>
     <dd>Status is a class for communication status between code modules.</dd>
  <dt>StandardFieldFactory</dt>
     <dd>Creates introspection objects for "well known" data.</dd>
  <dt>StandardPVFieldFactory</dt>
     <dd>Creates data objects for "well known" data.</dd>
</dl>

<p>Although pvDataFactory can provide the implementation for all supported data
types, often it is desirable to provide other implementations. To make it easy
to create alternate implementations a set of abstract and base classes are
supplied.</p>

<h3>org.epics.pvdata.property</h3>

<p>Provides a way to associated properties with a field. </p>

<p>The basic idea is to associate properties with any field named "value". All
the fields in the structure that contains the value field are considered
properties of value with the field name being the property name. See that
package overview for details.</p>

<p>This package also provides support for "well known" field definitions like
timeStamp, alarm, display,etc. Code that uses pvData can be simplified by using
this support.</p>

<h3>org.epics.pvdata.misc</h3>

<p>This package provides support that is used by pvData factories and might
also be useful to software that uses pvData.</p>

<h3>org.epics.pvdata.monitor</h3>

<p>Provides the ability to monitor changes to an arbitrary subset of the fields
in a record.</p>

<h2 >Package org.epics.pvdata.pv</h2>

<h3>Overview</h3>

<p>This package has the complete set of enum, interface, and class definitions
that describe PVData. The implementation is provided in package
org.epics.pvdata.factory.</p>

<p>A PVStructure is a field that contains an array of subfields. Each field has
code for accessing the field. The interface for each field is PVField or an
interface that extends PVField. Each field also has an introspection interface,
which is Field or an extension of Field. This package overview describes the
complete set of data and introspection interfaces for pvData.</p>

<p>This package also describes an interface Convert, which provides a rich set
of methods for converting and copying data between field.</p>

<p>The interface FieldCreate creates the introspection interfaces. The
interface PVDataCreate creates the PVField interfaces. Between them they
provide the ability to create every type of Field and PVField, i.e. they
provide a complete implemenation of pvData. It is also possible for other code
to provide implementations.</p>

<p>The interface StandardField provides introspection objects for standard fields.
The interface StandardPVField provides data objects for standard fields.</p>
<p>The interface StatusCreate and class Status provide status object to pass between source
modules.</p>

<h3>Process Variable Reflection</h3>

<p>Given the introspection object it is
possible to introspect a field without requiring access to data. The
reflection and data interfaces are separate because the data may not be
available. For example when a PVAccess client connects to a PV, the client
library can obtain the reflection information without obtaining any data. Only
when a client issues an I/O request will data be available. This separation is
especially important for arrays and structures so that a client can discover
the type without requiring that a large array or structure be transported over
the network.</p>

<h4>Type</h4>

<p>The types are defined by the Java definitions:</p>
<pre>
enum Type {
    scalar,
    scalarArray,
    structure,
    structureArray,
    union,
    unionArrray;
}

enum ScalarType {
    pvBoolean,
    pvByte, pvShort, pvInt, pvLong,
    pvUByte, pvUShort, pvUInt, pvULong,
    pvFloat,pvDouble,
    pvString;

    //Convenience methods
    public boolean isInteger();   // pvByte,...,pvULong
    public boolean isUInteger();   // pvUByte,...,pvULong
    public boolean isNumeric();    // pvByte,...pvDouble
    public boolean isPrimitive();  // pvBoolean,...pvDouble
    public static ScalarType getScalarType(String type);
    public String toString();
}</pre>

<h4>Serializable</h4>

<p>The following interfaces are called by pvAccess for transporting data over
the network. The abstract and base classes ensure that these methods are
properly implemented. </p>
<pre>
interface Serializable {
    void serialize(ByteBuffer buffer,SerializableControl flusher);
    void deserialize(ByteBuffer buffer,DeserializableControl control);
}
</pre>
where
<dl>
  <dt>serialize</dt>
    <dd>Serialize into buffer. flusher is called when buffer is full.</dd>
  <dt>deserialize</dt>
    <dd>deserialize from byte buffer. control is called when more data is required.</dd>
</dl>
<pre>
interface SerializableControl {
    void flushSerializeBuffer();
    void ensureBuffer(int size);
    void alignBuffer(int alignment);
    void cachedSerialize(Field field, ByteBuffer buffer)
}
</pre>
where
<dl>
   <dt>flushSerializeBuffer</dt>
      <dd>Code that called serialize must empty the buffer.
       The call can block until the buffer is flushed.</dd>
   <dt>ensureBuffer</dt>
      <dd>Helper method. Ensures specified size of bytes, flushes if necessary.</dd>
   <dt>alignBuffer</dt>
      <dd>Align buffer.Note that this takes care only current buffer alignment. If streaming protocol is used,
        care must be taken that entire stream is aligned.</dd>
   <dt>cachedSerialize</dt>
      <dd>Serialize Field instance via cache.</dd> 
</dl>
<pre>
interface DeserializableControl {
    void ensureData(int size);
    void alignData(int alignment);
    Field cachedDeserialize(ByteBuffer buffer)
}
</pre>
where
<dl>
   <dt>ensureData</dt>
     <dd>Helper method. Ensures specified size of bytes, provides it if necessary.</dd>`
   <dt>alignData</dt>
      <dd>Align buffer.Note that this takes care only current buffer alignment. If streaming protocol is used,
        care must be taken that entire stream is aligned.</dd>
   <dt>cachedDeserialize</dt>
      <dd>Deserialize Field instance via cache.</dd> 
</dl>
<pre>
interface SerializableArray extends Serializable {
    void serialize(ByteBuffer buffer, SerializableControl flusher, int offset, int count);
}       
</pre>
where
<dl>
   <dt>serialize</dt>
     <dd>Serialize field into given buffer.</dd>
</dl>
<pre>
interface BitSetSerializable {
   void serialize(ByteBuffer buffer, SerializableControl flusher, BitSet bitSet);
   void deserialize(ByteBuffer buffer, DeserializableControl control, BitSet bitSet);
}
</pre>
where
<dl>
   <dt>serialize</dt>
     <dd>Serialize field into given buffer. The BitSet shows the fields to serialize.</dd>
   <dt>deserialize</dt>
     <dd>Deserialize field into given buffer. The BitSet shows the fields to serialize.</dd>
</dl>

<h4>Reflection</h4>

<p>This section defines the complete set of Java PV reflection interfaces.
Reflection consists of the following:</p>
<dl>
  <dt>Field</dt>
    <dd>A field has an ID and a type. It can be converted to a string. 
        The format is the metadata format
        described in the overview.</dd>
  <dt>Scalar</dt>
    <dd>A scalar has a scalarType</dd>
  <dt>ScalarArray</dt>
    <dd>The element type is a scalarType</dd>
  <dt>Structure</dt>
    <dd>Has fields that can be any of the supported types.
      In addition it has a name for each field.</dd>
  <dt>StructureArray</dt>
    <dd>The field holds Structure[]. Each element has the same Structure
      interspection interface. A client can only get/put entire PVStructure
      elements NOT subfields of array elements.</dd>
  <dt>Union</dt>
    <dd>Has a single subField. The single field can either be
    any type (variant union) or any of a specfied set of types (regular union).
      interspection interface.</dd>
   <dt>UnionArray</dt>
     <dd>The field holds Union[]. Each element has the same Union
      interspection interface.</dd>
  <dt>FieldCreate</dt>
    <dd>This is an interface that provides methods to create introspection
      interfaces. A factory is provides to create FieldCreate.</dd>
</dl>
<h5>Field</h5>
<pre>    
interface Field extends Serializable {
    String getID();
    Type getType();
    void toString(StringBuilder buf));
    void toString(StringBuilder buf,int indentLevel);
    String toString();
} 
</pre>
where
<dl>
   <dt>getID</dt>
     <dd>Get the identification string.
      It can be empty.
      For scalar fields the ID is the metadata type, i.e. boolean, byte, etc.
      For scalarArray fields the ID is the metadata type, i.e. boolean[],
      byte[], etc.
      For structure fields the ID is determined by the argument specified
      when fieldCreate.createStructure is called.
      For structureArray fields the ID is XX[] where XX is the ID of the element structure.
     </dd>
   <dt>getType</dt>
     <dd>Get the field type.</dd>
   <dt>toString</dt>
     <dd>Create a String that shows the type.
      The format is the metadata syntax defined in the overview.</dd>
</dl>
<h5>Scalar</h5>
<pre>
interface Scalar extends Field {
    ScalarType getScalarType();
}
</pre>
where
<dl>
   <dt>getScalarType</dt>
     <dd>Return the ScalarType.</dd>
</dl>
<h5>ScalarArray</h5>
<pre>
interface ScalarArray extends Field{
    ScalarType getElementType();
}
</pre>
where
<dl>
   <dt>getElementType</dt>
     <dd>Return the ScalarType for each array element.</dd>
</dl>
<h5>Structure</h5>
<pre>
interface Structure extends Field{
    Field getField(String fieldName);
    int getFieldIndex(String fieldName);
    Field[] getFields();
    Field getField(int fieldIndex);
    String[] getFieldNames();
    String getFieldName(int fieldIndex);
}
</pre>
where
<dl>
   <dt>getField</dt>
     <dd>Return a field of the structure.
     The field can be requested by name or by index.</dd>
   <dt>getFieldIndex</dt>
     <dd>Return the index of the field with the specified fieldName.</dd>
   <dt>getFields</dt>
     <dd>Return the array of sub fields.</dd>
   <dt>getFieldNames</dt>
     <dd>Return the fieldNames for the fields.</dd>
   <dt>getFieldName</dt>
     <dd>Return the Field for the index.</dd>
</dl>
<h5>StructureArray</h5>
<pre>
interface StructureArray extends Field{
    Structure getStructure();
}
</pre>
where
<dl>
   <dt>getStructure</dt>
     <dd>Return the introspection interface for the array elements.</dd>
</dl>
<h5>Union</h5>
<pre>
public interface Union extends Field{
    public static final String DEFAULT_ID = "union";
    public static final String ANY_ID = "any";
    Field getField(String fieldName);
    int getFieldIndex(String fieldName);
    Field[] getFields();
    Field getField(int fieldIndex);
    String[] getFieldNames();
    String getFieldName(int fieldIndex);
    boolean isVariant();
}
</pre>
where
<dl>
   <dt>getField</dt>
     <dd>Given a name or an index the type is returned.
      <b>null</b> is returned if not found.
     </dd>
   <dt>getFieldIndex</dt>
      <dd>Get the index for name. -1 is returned if not found.
   <dt>getFields</dt>
       <dd>Get the array of types.</dd>
   <dt>getFieldNames</dt>
       <dd>Get the array of names.</dd>
   <dt>getFieldName</dt>
       <dd>Get the name for the specified index.</dd>
   <dt>isVariant</dt>
      <dd>returns <b>true</b> if this is varient array and <b>false</b> otherwise.
</dl>
<h5>UnionArray</h5>
<pre>
public interface UnionArray extends Field{
    Union getUnion();
}
</pre>
where
<dl>
   <dt>getUnion</dt>
     <dd>Get the union interface for each element.</dd>
</dl>
<h5>FieldCreate</h5>
<p><b>Syntax for fieldName and id.</b>
<p>A <b>fieldName</b> must begin with a letter and must be a sequence of letters
and digits.
A letter is defined as 'A'-'Z', 'a'-'z','_', or any Unicode character
that denotes a letter in a language. Similarly digits are '0'-'9' and any
Unicode character that denotes a digit in a language.
Note that this is the same as the Java syntax for variable names.</p>
<p>The syntax for <b>id</b> is the same except the '.' is also allowed
after the initial letter.</p>
<pre>public interface FieldCreate {
    FieldBuilder createFieldBuilder();
    Scalar createScalar(ScalarType scalarType);
    ScalarArray createScalarArray(ScalarType elementType);
    StructureArray createStructureArray(Structure elementStructure);
    UnionArray createUnionArray(Union elementUnion);
    UnionArray createVariantUnionArray();
    Structure createStructure(String[] fieldNames, Field[] field);
    Structure createStructure(String id,String[] fieldNames, Field[] field);
    Structure appendField(Structure structure,String fieldName, Field field);
    Structure appendFields(Structure structure,String[] fieldNames, Field[] fields);
    Structure createStructure(Structure structToClone);
    Union createVariantUnion();
    Union createUnion(String[] fieldNames, Field[] fields);
    Union createUnion(String id, String[] fieldNames, Field[] fields);
    Field deserialize(ByteBuffer buffer, DeserializableControl control);
}</pre>
where
<dl>
   <dt>createFieldBuilder</dt>
    <dd>Create an instance of FieldBuilder, which is desribed next.</dd>
   <dt>createScalar</dt>
     <dd>Return the Scalar with the specified scalarType.
       Note that the implementation creates a single instance for
      each scalarType.</dd>
   <dt>createScalarArray</dt>
     <dd>Return the ScalarArray with the specified elementType.
       Note that the implementation creates a single instance for
      each elementType.</dd>
   <dt>createStructureArray</dt>
     <dd>Return a StructureArray with the specified introspection
     interface for each array element.</dd>
   <dt>createStructure</dt>
     <dd>Return a Structure. There are two methods.
     The first creates a structure with an empty ID which results in an id of <b>structure</b>.
     </dd>
   <dt>appendField</dt>
     <dd>Append a field to a structure.</dd>
   <dt>appendFields</dt>
     <dd>Append an array of fields to a structure.</dd>
   <dt>createVariantUnion</dt>
      <dd>Create a varient union, i. e. a union where the subfield can be any valid type.</dd>
   <dt>createUnion</dt>
      <dd>Create a union where the sub-field can have any of the types an names defined
      by the arguments and the associated names.
      The default id is <b>union</b> for regular unions and <b>any</b> for variant unions.
     </dd>
   <dt>deserialize</dt>
     <dd>Deserialize a field from the the buffer.</dd>
</dl>
<h5>FieldBuilder</h5>
<p>FieldBuilder is a convenience class for creating introspection interfaces.
An example is:</p>
<pre>
FieldCreate fieldCreate = FieldFactory.getFieldCreate();
Structure s = fieldCreate.createFieldBuilder().
    add("double", ScalarType.pvDouble).
    addNestedStructure("nested").
        add("short", ScalarType.pvShort).
        add("long", ScalarType.pvLong).
        endNested().
    addArray("intArray", ScalarType.pvInt).
    createStructure();
System.out.println(s);
</pre>
This produces:
<pre>
structure
    double double
    structure nested
        short short
        long long
    int[] intArray
</pre>

<p>The Java interface is:</p>
<pre>
public interface FieldBuilder
{
    public FieldBuilder setId(String id);
    public FieldBuilder add(String name, ScalarType scalarType);
    public FieldBuilder add(String name, Field field);
    public FieldBuilder addArray(String name, ScalarType scalarType);
    public FieldBuilder addArray(String name, Field element);
    public Structure createStructure();
    public Union createUnion();
    FieldBuilder addNestedStructure(String name); 
    FieldBuilder addNestedUnion(String name);
    FieldBuilder addNestedStructureArray(String name); 
    FieldBuilder addNestedUnionArray(String name);
    FieldBuilder endNested();
}
</pre>
<dl>
  <dt>setId</dt>
     <dd>
      Specfy the id for the next createStructure or createUnion call.
     </dd>
  <dt>add</dt>
     <dd>
     Add a name and field for then next call to createStructure or createUnion.
     There are two forms: one for an existing field and the other for a scalar field.
     </dd>
  <dt>addArray</dt>
     <dd>
     Add a name and array field for then next call to createStructure or createUnion.
     There are two forms: one for an existing field and the other for a scalar field.
      Note that for an existing field this specifies the element type.
     </dd>
  <dt>createStructure</dt>
     <dd>
       Create a Structure from the precious add and addArray methods.
     </dd>
  <dt>createUnion</dt>
     <dd>
       Create a Union from the precious add and addArray methods.
     </dd>
  <dt>addNestedStructure</dt>
     <dd>
      Start a nested structure.
      This is followed by calls to other methods and ended by a call to endNested.
     </dd>
  <dt>addNestedUnion</dt>
     <dd>
      Start a nested union.
      This is followed by calls to other methods and ended by a call to endNested.
     </dd>
  <dt>addNestedStructureArray</dt>
     <dd>
      Start a nested structure array.
      This is followed by calls to other methods and ended by a call to endNested.
     </dd>
  <dt>addNestedUnionArray</dt>
     <dd>
      Start a nested union array.
      This is followed by calls to other methods and ended by a call to endNested.
     </dd>
  <dt>endNested</dt>
     <dd>
     </dd>
</dl>


<h3>status</h3>

<p>Status provides a way to pass status back to client code. It is new and not
currently used by pvData but may be in the future. It is used by code that uses
pvData.</p>
<h4>Status</h4>
<pre>
interface Status extends Serializable  {
    public enum StatusType {OK,WARNING,ERROR,FATAL};
    StatusType getType();
    String getMessage();
    String getStackDump();
    boolean isOK();
    boolean isSuccess();
}
</pre>
where
<dl>
  <dt>StatusType</dt>
    <dd>An enum for the status type.</dd>
  <dt>getType</dt>
    <dd>Get the statusType.</dd>
  <dt>getMessage</dt>
    <dd>Get a message explaining the error.</dd>
  <dt>getStackDump</dt>
    <dd>Get a stack dump.</dd>
  <dt>isOK</dt>
     <dd>Is the status the singleton object for StatusType.OK?</dd>
  <dt>isSuccess</dt>
     <dd>Is the StatusType either OK or WARNING?</dd>
</dl>
<h4>StatusCreate</h4>
<pre>
interface StatusCreate {
    Status getStatusOK(); 
    Status createStatus(StatusType type, String message, Throwable cause);
    Status deserializeStatus(ByteBuffer buffer, DeserializableControl control);
}
</pre>
where
<dl>
  <dt>getStatusOK</dt>
    <dd>Get a singleton that returns StatusType.OK and a null message and
      stackDump.</dd>
  <dt>createStatus</dt>
    <dd>Create a new Status.</dd>
  <dt>deserializeStatus</dt>
    <dd>Use this method instead of Status.deserialize(), since this allows OK
      status optimization.</dd>
</dl>

<h3>Requester</h3>

<p>In the pvIOCJava, PVRecord provides methods to register message requesters. Also a PVDatabase
provides an identical method. Thus when a message is generated for a field it
is propagated up to the record with the full field name attached and then
propagated to the PVDatabase which sends the messages to the registered
requesters.</p>
<pre>
enum MessageType {info,warning,error,fatalError}

interface Requester {
    String getRequesterName();
    void message(String message, MessageType messageType);
}
</pre>

<p>where</p>
<dl>
  <dt></dt>
  <dt>MessageType</dt>
    <dd>Type of message.</dd>
  <dt>Requester</dt>
    <dd>The default implementation is: 
      <ul>
        <li>getRequesterName<br />
          This is the full field name concatenated to the record name.</li>
        <li>message<br />
          For the default implementation, PVField prepends the full field name
          to the message and calls PVRecord.message. The default implementation
          for PVRecord either displays the message on stdout or stderr or gives
          the message to message requsters.</li>
      </ul>
    </dd>
</dl>

<h3>PVField - Data Interfaces</h3>

<p>This section defines the Java Interfaces for accessing the data within
a top level PVStructure.</p>

<h4>PVField</h4>

<p>PVField is the base interface for accessing data. Every field of a
top level PVStructure has a PVField associated with it.
This includes the top level structure itself.
</p>
<pre>interface PVField Serializable {
    String getFieldName();
    int getFieldOffset();
    int getNextFieldOffset();
    int getNumberFields();
    boolean isImmutable();
    void setImmutable();
    Field getField();
    PVStructure getParent();
    void postPut();
    void setPostHandler(PostHandler postHandler);
    void toString(StringBuilder buf);
    void toString(StringBuilder buf,int indentLevel);
    String toString();
    // The following should go away.
    PVAuxInfo getPVAuxInfo();
}</pre>

<p>where</p>
<dl>
  <dt>getFieldName</dt>
     <dd>Get the field name for this field. This will be a empty string for
     the top level structure.</dd>
  <dt>getFieldOffset</dt>
    <dd>Get offset of the PVField field within top level structure. Every field
      within the PVStructure has a unique offset. The top level structure has
      an offset of 0. The first field within the structure has offset equal to
      1. The other offsets are determined by recursively traversing each
      structure of the tree. </dd>
  <dt>getNextFieldOffset</dt>
    <dd>Get the next offset. If the field is a scalar or array field then this
      is just offset + 1. If the field is a structure it is the offset of the
      next field after this structure. Thus (nextOffset - offset) is always
      equal to the total number of fields within the field. </dd>
  <dt>getNumberFields</dt>
    <dd>Get the total number of fields in this field. This is nextFieldOffset -
      fieldOffset. </dd>
  <dt>isImmutable</dt>
    <dd>Is the field immutable?</dd>
  <dt>setImmutable</dt>
    <dd>Make the field immutable. Once a field is immutable it can never be
      changed since there is no method to again make it mutable. This is an
      important design decision because it allows immutable array fields to
      share the internal primitive data array.</dd>
  <dt>getField</dt>
    <dd>Get the reflection interface.</dd>
  <dt>getParent</dt>
    <dd>Get the interface for the parent or null if this is the top level
      PVStructure.</dd>
  <dt>postPut</dt>
    <dd>If a postHandler is registered it is called otherwise no action is
      taken.<br />
     <b>NOTE: </b>The implementation  of the various data interfaces automatically
      call postPut when a field is changed. However this is not true
      for a subField of a PVUnion, PVUnionArray, or PVStructureArray.
     If a subField of any of these is changed then the code that is making
     the modification must call postPut for the PVUnion, PVUnionArray, or PVStructureArray
     field. Note also that it is not a good idea to modify a subfield of a PVUnionArray
     or a PVStructureArray since it violates the idea of Copy On Write for arrays.
    </dd>
  <dt>setPostHandler</dt>
     <dd>Set the handler for postPut. At most one handler can be set.</dd>
  <dt>toString</dt>
    <dd>Converts the field data to a string. This is mostly for debugging
      purposes. The format is the meta data format described in the pvData
      project overview.
      <b>Note:</b> The actual conversion is done by the Convert facility. </dd>
</dl>

<h4>PVAuxInfo</h4>
<p><b>NOTE:</b> PVAuxInfo should go away.</p>

<p>AuxInfo (Auxillary Information) is information about a field that is
application specific. It will not be available outside the application that
implements the database. In particular it will not be made available to Channel
Access. It is used by the database itself to override the default
implementation of fields. The JavaIOC uses it for attaching support code.
Database Configuration and other tools can use it for configuration
information. Each Field and each PVField can have have an arbitrary number of
auxInfos. An auxInfo is a (key,PVScalar) pair where key is a string.</p>
<pre>
public interface PVAuxInfo {
    PVField getPVField();
    PVScalar createInfo(String key,ScalarType scalarType);
    Map&lt;String,PVScalar&gt; getInfos();
    PVScalar getInfo(String key);
    void toString(StringBuilder buf);
    void toString(StringBuilder buf,int indentLevel);
}
</pre>

<p>where</p>
<dl>
  <dt>getPVField</dt>
    <dd>Get the PVField to which this PVAuxInfo is attached.</dd>
  <dt>createInfo</dt>
    <dd>Create a new PVScalar of type scalarType.</dd>
  <dt>getInfos</dt>
    <dd>Get a map of all the auxInfos.</dd>
  <dt>getInfo</dt>
    <dd>Get the PVScalar with the specified key.</dd>
  <dt>toString</dt>
    <dd>Print all the auxInfo data in metadata format.</dd>
</dl>

<h4>PVScalar and extensions</h4>
<pre>
interface PVScalar extends PVField {
    Scalar getScalar();
}
</pre>

<h5>Primitive PVField types</h5>

<p>The interfaces for primitive data types are:</p>
<pre>
interface PVBoolean extends PVScalar {
    boolean get();
    void put(boolean value);
}

interface PVByte extends PVScalar {
    byte get();
    void put(byte value);
}

interface PVShort extends PVScalar {
    short get();
    void put(short value);
}

interface PVInt extends PVScalar {
    int get();
    void put(int value);
}

interface PVLong extends PVScalar {
    long get();
    void put(long value);
}

interface PVUByte extends PVScalar {
    byte get();
    void put(byte value);
}

interface PVUShort extends PVScalar {
    short get();
    void put(short value);
}

interface PVUInt extends PVScalar {
    int get();
    void put(int value);
}

interface PVULong extends PVScalar {
    long get();
    void put(long value);
}

interface PVFloat extends PVScalar {
    float get();
    void put(float value);
}

interface PVDouble extends PVScalar {
    double get();
    void put(double value);
}
</pre>
<p><b>NOTE:</b> The implementation for each unsigned integer is the same as for the same signed type.
This is because Java does not implement unsigned primitive types.</p>

<h5>PVString</h5>

<p>The interface for string is:</p>
<pre>
interface PVString extends PVScalar, SerializableArray {
    String get();
    void put(String value);
}
</pre>

<h4>PVArray and Extensions</h4>

<p><span style="font-family: courier">PVArray</span> is the base interface for
all the other PV Array interfaces. It extends PVField and provides the
additional methods:</p>
<pre>
interface PVArray extends PVField, SerializableArray {
    int getLength();
    void setLength(int len);
    int getCapacity();
    void setCapacity(int len);
    boolean isCapacityMutable();
    void setCapacityMutable(boolean isMutable);
}
</pre>
<dl>
  <dt>getLength</dt>
<dd>Get the current length. This is less that or equal to the capacity.</dd>
  <dt>setLength</dt>
<dd>Set the length. If the PVField is not mutable then an exception is
  thrown. If this is greater than the capacity setCapacity is called.</dd>
  <dt>getCapacity</dt>
<dd>Get the capacity, i.e. this is the sized of the underlying data
array.</dd>
  <dt>setCapacity</dt>
<dd>Set the capacity. The semantics are implementation dependent but
  typical semantics are as follows: If the capacity is not mutable an
  exception is thrown. A new data array is created and data is copied from
  the old array to the new array. </dd>
  <dt>isCapacityMutable</dt>
<dd>Is the capacity mutable</dd>
  <dt>setCapacityMutable</dt>
<dd>Specify if the capacity can be changed.</dd>
</dl>

<h5>PVArray Extensions</h5>

<p>The interface for each array type has get and put methods which have the
same arguments except for the data type. For example PVDoubleArray is:</p>
<pre>
public class DoubleArrayData {
    public double[] data;
    public int offset;
}
interface PVDoubleArray extends PVScalarArray {
    int get(int offset, int len, DoubleArrayData data);
    int put(int offset, int len, double[]from, int fromOffset);
    void shareData(double[] from);
}i
</pre>

<p>Get "exposes" it's internal array by setting data.data and data.offset. The
caller is responsible for copying the array elements. This violates the
principle that objects should not expose their internal data but is done for
efficency. For example it makes it possible to copy between arrays with
identical element types via a call to System.arraycopy without requiring an
intermediate array.</p>

<p>Both get and put return the number of elements actually transfered. The
arguments are:</p>
<dl>
  <dt>offset</dt>
<dd>The offset in the PV array.</dd>
  <dt>len</dt>
<dd>The maximum number of elements to transfer. The number actually
  transfered will be less than or equal to this value.</dd>
  <dt>data</dt>
<dd>Get sets data.data to it's internal array and data.offset to the offset
  into the array. The caller is responsible for the actual data
transfer.</dd>
  <dt>from</dt>
<dd>The array from which the data is taken. This array is supplied by the
  caller</dd>
  <dt>fromOffset</dt>
<dd>The offset in <span>from</span></dd>
</dl>

<p>The caller must be prepared to make multiple calls to retrieve or put an
entire array. A caller should accept or put partial arrays. For example the
following reads an entire array:</p>
<pre>
double[] getArray(PVDoubleArray pv)
{
    int len = pv.getLength();
    double[] storage = new double[len];
    DoubleArrayData data = new DoubleArrayData();
    int offset = 0;
    while(offset &lt; len) {
        int num = pv.get(offset,(len-offset),data);
        System.arraycopy(data.data,data.offset,storage,offset,num);
        offset += num;
    }
    return storage;
}
</pre>

<p>shareData results in the PVArray using the primitive array that is passed to
this method. This is most useful for immutable arrays. In this case the caller
must set the PVArray to be immutable. If the PVArray is not immutable then 
the application is responsibility for coordinating access to the array.
This violates the principle that objects should not expose their internal data but
is important for immutable arrays. For example pvData and the javaIOC define
many enumerated structures where an enumerated structure has twofields: index
and choices. Choices is a PVStringArray that holds the enumerated choices.
Index is a PVInt that is the index of the currently selected choice. The
choices can be immutable. Allowing the choices internal String[] to be shared
between all the instances of an enumerated structure saves on storage. Another
reason for allowing shared data is so that an application which processes an
array can be separated into multiple modules that directly access the internal
data array of a PVArray. This can be required for minimizing CPU overhead. In
this case it is the applications responsibility to coordinate access to the
array.</p>

<h5>Complete set of PVArray Extensions</h5>
<pre>
interface PVScalarArray extends PVArray {
    ScalarArray getScalarArray();
}

public class BooleanArrayData {
    public boolean[] data;
    public int offset;
}
interface PVBooleanArray extends PVScalarArray {
    int get(int offset, int len, BooleanArrayData data);
    int put(int offset, int len, boolean[]from, int fromOffset);
    void shareData(boolean[] from);
}

public class ByteArrayData {
    public byte[] data;
    public int offset;
}
interface PVByteArray extends PVScalarArray {
    int get(int offset, int len, ByteArrayData data);
    int put(int offset, int len, byte[]from, int fromOffset);
    void shareData(byte[] from);
}
interface PVUByteArray extends PVScalarArray {
    int get(int offset, int len, ByteArrayData data);
    int put(int offset, int len, byte[]from, int fromOffset);
    void shareData(byte[] from);
}

public class ShortArrayData {
    public short[] data;
    public int offset;
}
interface PVShortArray extends PVScalarArray {
    int get(int offset, int len, ShortArrayData data);
    int put(int offset, int len, short[]from, int fromOffset);
    void shareData(short[] from);
}
interface PVUShortArray extends PVScalarArray {
    int get(int offset, int len, ShortArrayData data);
    int put(int offset, int len, short[]from, int fromOffset);
    void shareData(short[] from);
}

public class IntArrayData {
    public int[] data;
    public int offset;
}
interface PVIntArray extends PVScalarArray {
    int get(int offset, int len, IntArrayData data);
    int put(int offset, int len, int[]from, int fromOffset);
    void shareData(int[] from);
}
interface PVUIntArray extends PVScalarArray {
    int get(int offset, int len, IntArrayData data);
    int put(int offset, int len, int[]from, int fromOffset);
    void shareData(int[] from);
}

public class LongArrayData {
    public long[] data;
    public int offset;
}
interface PVLongArray extends PVScalarArray {
    int get(int offset, int len, LongArrayData data);
    int put(int offset, int len, long[]from, int fromOffset);
    void shareData(long[] from);
}
interface PVULongArray extends PVScalarArray {
    int get(int offset, int len, LongArrayData data);
    int put(int offset, int len, long[]from, int fromOffset);
    void shareData(long[] from);
}

public class FloatArrayData {
    public float[] data;
    public int offset;
}
interface PVFloatArray extends PVScalarArray {
    int get(int offset, int len, FloatArrayData data);
    int put(int offset, int len, float[]from, int fromOffset);
    void shareData(float[] from);
}

public class DoubleArrayData {
    public double[] data;
    public int offset;
}
interface PVDoubleArray extends PVScalarArray {
    int get(int offset, int len, DoubleArrayData data);
    int put(int offset, int len, double[]from, int fromOffset);
    void shareData(double[] from);
}

public class StringArrayData {
    public String[] data;
    public int offset;
}
interface PVStringArray extends PVScalarArray {
    int get(int offset, int len, StringArrayData data);
    int put(int offset, int len, String[]from, int fromOffset);
    void shareData(String[] from);
}

public class StructureArrayData {
    public PVStructure[] data;
    public int offset;
}

interface PVStructureArray extends PVArray {
    StructureArray getStructureArray();
    int get(int offset, int length, StructureArrayData data);
    int put(int offset,int length, PVStructure[] from, int fromOffset);
    void shareData(PVStructure[] from);
}

public class UnionArrayData {
    public PVUnion[] data;
    public int offset;
}

interface PVUnionArray extends PVArray{
    UnionArray getUnionArray();
    int get(int offset, int length, UnionArrayData data);
    int put(int offset,int length, PVUnion[] from, int fromOffset);
    void shareData(PVUnion[] from);
}
</pre>
<p><b>NOTES:</b></p>
<dl>
   <dt>Unsigned types</dt>
     <dd>The implementation for each unsigned integer is the same as for the same signed type.
     This is because Java does not implement unsigned primitive types.</dd>
   <dt>PVStructureArray and PVUnionArray</dt>
     <dd>A client can only access the data in the
       elements of the array via the get and put methods, i.e. it is not possible to
       access subfields indirectly. PVStructureArray.getNumberFields() returns 1, i.e.
       the field looks like a leaf field.</dd>
</dl>

<h4>PVStructure</h4>

<p>The interface for a structure is:</p>
<pre>
interface PVStructure extends PVField , BitSetSerializable{
    Structure getStructure();
    PVField[] getPVFields();
    PVField getSubField(String fieldName);
    PVField getSubField(int fieldOffset);
    &lt;T extends PVField&gt; T getSubField(Class&lt;T&gt; c, String fieldName);
    &lt;T extends PVField&gt; T getSubField(Class&lt;T&gt; c, int fieldOffset);
    // The following are convenience methods
    // Note that they are no longer needed because of above generic methods
    PVBoolean getBooleanField(String fieldName);
    PVByte getByteField(String fieldName);
    PVShort getShortField(String fieldName);
    PVInt getIntField(String fieldName);
    PVLong getLongField(String fieldName);
    PVFloat getFloatField(String fieldName);
    PVDouble getDoubleField(String fieldName);
    PVString getStringField(String fieldName);
    PVScalarArray getScalarArrayField(String fieldName);
    PVStructureArray getStructureArrayField(String fieldName);
    PVStructure getStructureField(String fieldName);
    PVArray getArrayField(String fieldName,ScalarType elementType);
    PVUnion getUnionField(String fieldName);
    PVUnionArray getUnionArrayField(String fieldName);
    public boolean checkValid();
}</pre>

<p>where</p>
<dl>
  <dt>getStructure</dt>
    <dd>Get the introspection interface for the structure.</dd>
  <dt>getPVFields</dt>
    <dd>Returns the array of subfields. The set of subfields must all have
      different field names.</dd>
  <dt>getSubField(String fieldName)</dt>
    <dd>Get a subField of a field. For a PVStructure a non-null result is
      returned if fieldName is a field of the PVStructure. The fieldName can be
      of the form name.name...</dd>
  <dt>getSubField(int fieldOffset)</dt>
    <dd>Get the field located a fieldOffset, where fieldOffset is relative to
      the top level structure. This returns null if the specified field is not
      located within this PVStructure.</dd>
   <dt>getSubField - generic versions</dt>
     <dd>These are the methods to that get a subfield and convert it to the proper type.
    These two methods replace all the type specific methods, which ae no longer required
    and should not be used.</dd>
</dl>

<h4>PVDataCreate</h4>

<p>PVDataCreate is an interface that provides methods that create PVField
interfaces. A factory is provided that creates PVDataCreate.</p>
<pre>interface PVDataCreate {
    PVField createPVField(Field field);
    PVField createPVField(PVField fieldToClone);
    PVScalar createPVScalar(Scalar scalar);
    PVScalar createPVScalar(ScalarType fieldType);
    PVScalar createPVScalar(PVScalar scalarToClone);
    PVScalarArray createPVScalarArray(ScalarArray array);
    PVScalarArray createPVScalarArray(ScalarType elementType);
    PVScalarArray createPVScalarArray(PVScalarArray arrayToClone;
    PVStructureArray createPVStructureArray(StructureArray structureArray);
    PVUnionArray createPVUnionArray(UnionArray unionArray);
    PVUnionArray createPVVariantUnionArray();
    PVStructure createPVStructure(Structure structure);
    PVStructure createPVStructure(String[] fieldNames,Field[] fields);
    PVStructure createPVStructure(PVStructure structToClone);
    PVUnion createPVUnion(Union union);
    PVUnion createPVVariantUnion();
    PVUnion createPVUnion(PVUnion unionToClone);
    &lt;T extends PVScalar, TA extends PVScalarArray&gt; T createPVScalar(
        PVScalarType&lt;T, TA&gt; scalarType);
    &lt;T extends PVScalar, TA extends PVScalarArray&gt; TA createPVScalarArray(
        PVScalarType&lt;T, TA&gt; elementType);
	
    PVStructureArray createPVStructureArray(Structure structure);
    PVUnionArray createPVUnionArray(Union union);
    PVField[] flattenPVStructure(PVStructure pvStructure);
}</pre>
where 
<dl>
  <dt>createPVField</dt>
    <dd>The PVField is created reusing the Field interface. Two methods are
      provided. Each calls the corresponding createPVScalar, createPVArray, or
      createPVStructure depending in the type of the argument.</dd>
  <dt>createPVScalar</dt>
    <dd>Creates an instance of a PVScalar. Three versions are supplied. The
      first is passed an introspection interface. The second provides the field
      name and the scalarType. The last provides a field name and a PVScalar to
      clone. The newly created PVScalar will have the same auxInfos as the
      original.
      A generic version is available.
      </dd>
  <dt>createPVScalarArray</dt>
    <dd>Create an instance of a PVArray. Three versions are supplied. The first
      is passed an introspection interface. The second provides the field name
      and the elementType. The last provides a field name and a PVArray to
      clone. The newly created PVArray will have the same auxInfos as the
      original.
      A generic version is available.
      </dd>
  <dt>createPVStructureArray</dt>
    <dd>Create a PVStructureArray. It must be passed a structureToClone. This
      will become the Structure interface for ALL elements of the
      PVStructureArray. It MUST be used to create any new array elements.</dd>
   <dt>createPVUnionArray</dt>
    <dd>Create a PVUnionArray. It must be passed a union. This
      will become the union interface for ALL elements of the
      PVUnionArray.. It MUST be used to create any new array elements.</dd>
   <dt>createPVVariantUnionArray</dt>
      <dd>Create a variant PVUnionArray.
       Each array element can have any type.
       </dd>
  <dt>createPVStructure</dt>
    <dd>Create an instance of a PVStructure. Three methods are provided. The
      first method uses a previously created structure introspection interface.
      The second uses a PVField[].
      The third initializes the subfields by cloning the fields contained in
      structToClone. The newly created sub-fields will have the same values and
      auxInfos as the original. If structToClone is null then the new structure
      is initialized to have 0 sub-fields.</dd>
   <dt>createPVUnion</dt>
    <dd>Create a PVUnion. It must be passed a union. This
      will become the union interface for the single sub-field.
      </dd>
   <dt>createPVVariantUnion</dt>
      <dd>Create a variant PVUnion.
       The sub-field can have any type.
       </dd>
  <dt>flattenPVStructure</dt>
    <dd>Create an array of PVFields for the fields in the PVStructure. The
      order is according to fieldOffset.</dd>
</dl>

<h3>Convert</h3>

<p><b>NOTE:</b> copying immutable array fields. If an entire immutable array
field is copied to another array that has the same elementType, both offsets
are 0, and the length is the length of the source array, then the shareData
method of the target array is called and the target array is set immutable.
Thus the source and target share the same primitive array.</p>

<p>This section describes the supported conversions between data types.</p>
<ul>
  <li>All supported types can be converted to a string. If you ask for a 100
    megabyte array to be converted to a string expect a lot of output.</li>
  <li>Conversion from a string to a scalar type.</li>
  <li>Conversion from an array of strings to an array of scalar types.</li>
  <li>Copy between the following types of scalar PVs 
    <ul>
      <li>Numeric type to another numeric type</li>
      <li>Both have the same type.</li>
      <li>Either is a string</li>
    </ul>
  </li>
  <li>Copy between PVArrays that satisfy one of the following. 
    <ul>
      <li>Numeric to numeric</li>
      <li>Both have the same type.</li>
      <li>Either is a string.</li>
    </ul>
  </li>
  <li>Conversions between numeric scalar types.</li>
  <li>Conversions between arrays of numeric type.</li>
  <li>Conversion between compatible structures.</li>
  <li>Support for unsigned integers. Because Java does primitive unsigned
   integers the only support is in "widening" operations.
   For example if a PVUByte is converted to short then the proper conversion will
   be done.</li>
  <li>A utility method the returns the full field name of a field.</li>
</ul>
<pre>
interface Convert {
    void getFullFieldName(StringBuilder builder,PVField pvField)
    void getString(StringBuilder buf,PVField pv, int indentLevel);
    void getString(StringBuilder buf,PVField pv);
    void fromString(PVScalar pv,String from);
    void fromString(PVScalarArray pv,String from);
    int fromStringArray(PVScalarArray pv,
         int offset, int len, String[]from, int fromOffset);
    int toStringArray(PVScalarArray pv,
         int offset, int len, String[]to, int toOffset);
    boolean isCopyCompatible(Field from, Field to);
    void copy(PVField from,PVField to);
    boolean isCopyScalarCompatible(Field from, Field to);
    void copyScalar(PVField from, PVField to);
    boolean isCopyScalarArrayCompatible(ScalarArray from, ScalarArray to);
    int copyScalarArray(PVScalarArray from, int offset,
         PVScalarArray to, int toOffset, int len);
    boolean isCopyStructureCompatible(Structure from, Structure to);
    void copyStructure(PVStructure from, PVStructure to);
    boolean isCopyUnionCompatible(Union from, Union to);
    void copyUnion(PVUnion from, PVUnion to);
    boolean isCopyStructureArrayCompatible(StructureArray from, StructureArray to);
    void copyStructureArray(PVStructureArray from, PVStructureArray to);
    boolean isCopyUnionArrayCompatible(UnionArray from, UnionArray to);
    void copyUnionArray(PVUnionArray from, PVUnionArray to);
    // For the following the pv Type must be PVByte, ...., PVDouble
    byte toByte(PVField pv);
    short toShort(PVField pv);
    int   toInt(PVField pv);
    long  toLong(PVField pv);
    float toFloat(PVField pv);
    double toDouble(PVField pv);
    String toString(PVScalar pv);
    void  fromByte(PVField pv, byte from);
    void  fromShort(PVField pv, short from);
    void  fromInt(PVField pv, int from);
    void  fromLong(PVField pv, long from);
    void  fromUByte(PVField pv, byte from);
    void  fromUShort(PVField pv, short from);
    void  fromUInt(PVField pv, int from);
    void  fromULong(PVField pv, long from);
    void  fromFloat(PVField pv, float from);
    void  fromDouble(PVField pv, double from);
// For the following the element type must be pvByte, ...., pvDouble
    int toByteArray(PVScalarArray pv,
        int offset, int len, byte[]to, int toOffset);
    int toShortArray(PVScalarArray pv,
        int offset, int len, short[]to, int toOffset);
    int toIntArray(PVScalarArray pv,
        int offset, int len, int[]to, int toOffset);
    int toLongArray(PVScalarArray pv,
        int offset, int len, long[]to, int toOffset);
    int toFloatArray(PVScalarArray pv,
        int offset, int len, float[]to, int toOffset);
    int toDoubleArray(PVScalarArray pv,
        int offset, int len, double[]to, int toOffset);
    int fromByteArray(PVScalarArray pv,
        int offset, int len, byte[]from, fromOffset);
    int fromShortArray(PVScalarArray pv,
        int offset, int len, short[]from, fromOffset);
    int fromIntArray(PVScalarArray pv,
        int offset, int len, int[]from, fromOffset);
    int fromLongArray(PVScalarArray pv,
        int offset, int len, long[]from, fromOffset);
    int fromUByteArray(PVScalarArray pv,
        int offset, int len, byte[]from, fromOffset);
    int fromUShortArray(PVScalarArray pv,
        int offset, int len, short[]from, fromOffset);
    int fromUIntArray(PVScalarArray pv,
        int offset, int len, int[]from, fromOffset);
    int fromULongArray(PVScalarArray pv,
        int offset, int len, long[]from, fromOffset);
    int fromFloatArray(PVScalarArray pv,
        int offset, int len, float[]from, fromOffset);
    int fromDoubleArray(PVScalarArray pv,
        int offset, int len, double[]from, fromOffset);
    void newLine(StringBuilder builder, int indentLevel);
}
</pre>

<p>The array methods all return the number of elements copied or converted.
This can be less than <span>len</span> if the
PVField array contains less than len elements.</p>

<p><span>newLine</span> is a convenience method
for code that implements <span>toString</span> It
generates a newline and inserts blanks at the beginning of the newline.</p>

<p>The getString methods dump the data in the metadata syntax described in the
pvData project overview. Note that the toString methods of PVField are
implemented by calling these convert methods.</p>

<h3>StandardField and StandardPVField</h3>
<p><b>Warning:</b>
The concept of Standard Field is closely related to property which is described below.
The section on property provides details about alarm,
timeStamp, display, control, and enumerated.
That section should be read in conjuction with this section.</p>
<p>A standard field is a field that tools know how to use.
pvData defines and provides support for the following standard fields.</p>
<dl>
  <dt>enumerated</dt>
    <dd>This is a structure that has two subfields: index, and choices</dd>
  <dt>value</dt>
   <dd>This is any field with the name "value".
    It can be any type.
    The other standard fields can provide "properties" for the value field.
   </dd>
  <dt>timeStamp</dt>
    <dd>Encodes a time stamp. It can be a standalone field or be a property
    if a value field, in which case it should be a sub field of the same structure
    as the value field.</dd>
  <dt>alarm</dt>
    <dd>Encodes an alarm. It is normally a property
    if a value field, in which case it should be a sub field of the same structure
    as the value field.</dd>
  <dt>display</dt>
    <dd>Encodes a set of information for displaying a scalar or scalarArray value.
     It is normally a property
    if a value field, in which case it should be a sub field of the same structure
    as the value field.</dd>
  <dt>control</dt>
    <dd>Encodes a set of information for limits for a scalar or scalarArray value.
     It is normally a property
    if a value field, in which case it should be a sub field of the same structure
    as the value field.</dd>
  <dt>valueAlarm</dt>
    <dd>Defines a set of values for setting alarm values for a scalar value.
     It has separate definitions for booleanAlarm, byteAlarm, shortAlarm,
     intAlarm, longAlarm, floatAlarm, and doubleAlarm.
     There is also an enumeratedAlarm for an enumerated value field.</dd>
</dl>
<h4>StandardField</h4>
<pre>
interface StandardField {
    Structure scalar(ScalarType scalarType,String properties);
    Structure scalarArray(ScalarType elementType, String properties);
    Structure structureArray(Structure structure,String properties);
    Structure enumerated();
    Structure enumerated(String properties);
    Structure alarm();
    Structure timeStamp();
    Structure display();
    Structure control();
    Structure booleanAlarm();
    Structure byteAlarm();
    Structure shortAlarm();
    Structure intAlarm();
    Structure longAlarm();
    Structure floatAlarm();
    Structure doubleAlarm();
    Structure enumeratedAlarm();
}
</pre>
where
<dl>
   <dt>scalar</dt>
     <dd>Create a Structure that has a scalar field named value and with the
      specfied scalarType.
     The structure can have aditional fields that are properties of the value field.
     properties is some combination of
     alarm, timeStamp, display, control, and valueAlarm.</dd>
   <dt>scalarArray</dt>
     <dd>Create a Structure that has a scalarArray field named value and with the
      specfied elementType,.
     The structure can have aditional fields that are properties of the value field.
     properties is some combination of
     alarm, timeStamp, display, and control.</dd>
   <dt>structureArray</dt>
     <dd>Create a Structure that has a structureArray field named value and with the
      specfied structure as the introspection interface for each array element,.
     The structure can have aditional fields that are properties of the value field.
     properties is some combination of alarm and timeStamp.</dd>
   <dt>enumerated()</dt>
      <dd>Create an enumerated Structure</dd>
   <dt>enumerated(String properties)</dt>
     <dd>Create a Structure that has an enumerated structure field named value.
      The structure can have aditional fields that are properties of the value field.
     properties is some combination of
     alarm, timeStamp, and enumeratedAlarm.</dd>
   <dt>alarm</dt>
     <dd>Create an alarm Structure.</dd>
   <dt>timeStamp</dt>
     <dd>Create a timeStamp Structure.</dd>
   <dt>display</dt>
     <dd>Create an display Structure.</dd>
   <dt>control</dt>
     <dd>Create a control Structure.</dd>
   <dt>booleanAlarm</dt>
     <dd>Create a booleanAlarm Structure.</dd>
   <dt>byteAlarm</dt>
     <dd>Create a byteAlarm Structure.</dd>
   <dt>shortAlarm</dt>
     <dd>Create a shortAlarm Structure.</dd>
   <dt>intAlarm</dt>
     <dd>Create a intAlarm Structure.</dd>
   <dt>longAlarm</dt>
     <dd>Create a longAlarm Structure.</dd>
   <dt>floatAlarm</dt>
     <dd>Create a floatAlarm Structure.</dd>
   <dt>doubleAlarm</dt>
     <dd>Create a doubleAlarm Structure.</dd>
   <dt>enumeratedAlarm</dt>
     <dd>Create a enumearatedAlarm Structure.</dd>
</dl>
<h4>StandardPVField</h4>
<pre>
interface StandardPVField {
    PVStructure scalar(ScalarType type,String properties);
    PVStructure scalarArray(ScalarType elementType, String properties);
    PVStructure structureArray(Structure structure,String properties);
    PVStructure enumerated(String[] choices);
    PVStructure enumerated(String[] choices,String properties);
}
</pre>
where
<dl>
   <dt>scalar</dt>
     <dd>Create a PVStructure that has a scalar field named value and with the
      specfied scalarType.
     The structure can have aditional fields that are properties of the value field.
     properties is some combination of
     alarm, timeStamp, display, control, and valueAlarm.</dd>
   <dt>scalarArray</dt>
     <dd>Create a PVStructure that has a scalarArray field named value and with the
      specfied elementType,.
     The structure can have aditional fields that are properties of the value field.
     properties is some combination of
     alarm, timeStamp, display, and control.</dd>
   <dt>structureArray</dt>
     <dd>Create a PVStructure that has a structureArray field named value and with the
      specfied structure as the introspection interface for each array element,.
     The structure can have aditional fields that are properties of the value field.
     properties is some combination of alarm and timeStamp.</dd>
   <dt>enumerated(String[] choices)</dt>
      <dd>Create an enumerated PVStructure.
       The choices field is initialized with choices and set immutable.
      </dd>
   <dt>enumerated(String[] choices,String properties)</dt>
     <dd>Create a PVStructure that has an enumerated structure field named value.
       The choices field of value is initialized with choices and set immutable.
      The structure can have aditional fields that are properties of the value field.
     properties is some combination of
     alarm, timeStamp, and enumeratedAlarm.</dd>
</dl>
<h3>Examples</h3>

<h4>Accessing PVData</h4>

<p>Assume that code wants to access two fields from a PVStructure:</p>
<dl>
  <dt>value</dt>
    <dd>Must be a PVDouble.</dd>
  <dt>timeStamp</dt>
    <dd>Just look for field with this name.</dd>
</dl>

<p>The following code uses introspection to get the desired information.</p>
<pre>String getValueAndTimeStamp(PVStructure pvStructure) {
   PVField valuePV = pvStructure.getSubField("value");
   if(valuePV==null) {
       return "value field not found";
   }
   if(valuePV.getField.getType!=Type.scalar) {
       return "value field is not a scalar";
   }
   Scalar scalar = (Scalar)valuePV.getField();
   if(scalar.getScalarType!=ScalarType.pvDouble) {
       return "value field is not a double";
   }
   PVDouble pvDouble = (PVDouble)valuePV;
   PVField timeStampPV = pvStructure.getSubField("timeStamp");
   if(timeStampPV==null) {
       return "timeStamp field not found";
   }
   double value = valuePV.get();
   return value + " timeStamp " + timeStampPV.toString();
}</pre>

<h4>Creating PVData</h4>

<p>Example of creating a scalar field.</p>
<pre>
PVDataCreate pvDataCreate = PVDataFactory.getPVDataCreate();
PVDouble pvValue = pvDataCreate.createPVScalar(ScalarType.pvDouble);
</pre>

<p>Create a structure.</p>
<pre>    
FieldCreate fieldCreate = FieldFactory.getFieldCreate();
PVDataCreate pvDataCreate = PVDataFactory.getPVDataCreate();

PVStructure create() {
    Field[] fields = new Field[2];
    String[] fieldNames = new String[2];
    fields[0] = fieldCreate.createScalar(ScalarType.pvLong);
    fields[1] = fieldeCreate.createScalar(ScalarType.pvInt);
    fieldNames[0] = "a";
    fieldNames[1] = "b";
    PVStructure pvStructure = pvDataCreate.createPVStructure(
        fieldNames,fields);
    return(pvStructure);
}
</pre>

<p>FieldBuilder provides an easier way to accomplish the previous:</p>
<pre>
PVStructure create() {
   return pvDataCreate.createPVStructure(
        fieldCreate.createFieldBuilder()
          .add("a",ScalarType.pvLong)
          .add("b",ScalarType.pvInt)
          .createStructure());
}
</pre>

<p>StandardPVField also provides an easy way to create fields. For example:</p>
<pre>
StandardPVField standardPVField = StandardPVFieldFactory.getStandardPVField();
PVStructure pvStructure = standardPVField.scalar(
    ScalarType.pvDouble,
    "alarm,timeStamp.display,control,valueAlarm");
</pre>

<h2 >Package org.epics.pvdata.factory</h2>

<p>This package provides factories and classes to implement everything defined
in package org.epics.pvdata.pv
Look at the code for details.
</p>

<h2 >Package org.epics.pvdata.property</h2>

<h3>Definition of Property</h3>

<p>Only fields named "value" have properties. A record can have multiple value
fields, which can appear in the top level structure of a record or in a
substructure. All other fields in the structure containing a value field are
considered properties of the value field. The fieldname is also the property
name. The value field can have any type, i.e. scalar, scalarArray, or
structure. Typical property fields are timeStamp, alarm, display, control, and
history. The timeStamp is a special case. If it appears anywhere in the
structure hieraracy above a value field it is a property of the value field.</p>

<p>For example the following top level structure has a single value field. The
value field has properties alarm, timeStamp, and display.</p>
<pre>
structure counterOutput
    double value
    alarm_t
        int severity 0
        int status 0
        string message
    double value
    display_t
        double limitLow 0.0
        double limitHigh 10.0
        string description "Sample Description"
        string format "%f"
        string units volts
</pre>

<p>The following example has three value fields each with properties alarm and
timeStamp. Voltage, Current, and Power each have a different alarms but all
share the timeStamp.</p>
<pre>structure powerSupplyValue
    double value
    alarm_t
        int severity 0
        int status 0
        string message

structure powerSupplySimple
    alarm_t
        int severity 0
        int status 0
        string message
    timeStamp_t
        long secondsPastEpoch
        int nanoSeconds
        int userTag
    powerSupplyValue_t voltage
        double value
        alarm_t
            int severity 0
            int status 0
            string message
    powerSupplyValue_t power
        double value
        alarm_t
            int severity 0
            int status 0
            string message
    powerSupplyValue_t current
        double value
        alarm_t
            int severity 0
            int status 0
            string message
</pre>

<h3>Standard Properties</h3>

<p>The following field names have special meaning, i.e. support properties for
general purpose clients.</p>
<dl>
  <dt>value</dt>
    <dd>This is normally defined since most general purpose clients access this
      field. All other fields in the structure support or describe the value
      field. The type can any supported type but is usually one of the
      following: 
      <dl>
        <dt>scalar</dt>
          <dd>Any of the scalar types.</dd>
        <dt>scalarArray</dt>
          <dd>An array with the elementType being a scalar type</dd>
        <dt>enumerated structure</dt>
          <dd>A structure that includes fields named index and
            choices. index is an int that selects a choice.
            choices is an array of strings that
            defines the complete set of choices.</dd>
        <dt>other</dt>
          <dd>Other structure or array types can also be defined if clients and
            support code agree on the meaning. Some examples are: 1) A
            structure defining a 2D matrix, 2) A structure defining an image,
            3) A structure that simulates a remote method, ...</dd>
      </dl>
    </dd>
  <dt>timeStamp</dt>
    <dd>The timeStamp. The type MUST be a timeStamp structure. Also if the
      PVData structure does not have a timeStamp then a search up the parent
      tree is made to find a timeStamp.</dd>
  <dt>alarm</dt>
    <dd>The alarm. The type MUST be an alarm structure. </dd>
  <dt>display</dt>
    <dd>A display structure as described below. It provides display
      characteristics for the value field.</dd>
  <dt>control</dt>
    <dd>A control structure as described below. It provides control
      characteristics for the value field.</dd>
  <dt>history</dt>
    <dd>Provides a history buffer for the value field. Note that currently
      PVData does not define history suppoprt.</dd>
  <dt>other</dt>
    <dd>Other standard properties can be defined.</dd>
</dl>

<p>In addition a structure can have additional fields that support the value
field but are not recognized by most general purpose client tools. Typical
examples are:</p>
<dl>
  <dt>input</dt>
    <dd>A field with support that changes the value field. This can be
      anything. It can be a channel access link. It can obtain a value from
      hardware. Etc.</dd>
  <dt>valueAlarm</dt>
    <dd>A field with support that looks for alarm conditions based on the
    value.</dd>
  <dt>output</dt>
    <dd>A field with support that reads the current value and sends it
      somewhere else. This can be anything. It can be a channel access link. It
      can write a value to hardware. Etc.</dd>
</dl>

<p>The model allows for device records. A device record has structure fields
that that support the PVData data model. For example a powerSupport record can
have fields power, voltage, current that each support the PVData data model.
</p>

<h3>PVProperty Interfaces and Classes</h3>
<h4>PVProperty</h4>
<p>Interface and factory for finding a field within a structure.</p>
<pre>
interface PVProperty {
    PVField findProperty(PVField pvField,String fieldName);
    PVField findPropertyViaParent(PVField pvField,String propertyName);
    String[] getPropertyNames(PVField pvField);
}
</pre>
where
<dl>
  <dt>findProperty</dt>
    <dd>Find a field that is a subfield or property of this PVField. The fieldName
    is of the form name.name... The pvField must be named value or it does not
    have properties. </dd>
  <dt>findPropertyViaParent</dt>
    <dd>Find a property by searching up the parent tree. The property name is
    expected to match the name of a field. The return value is the interface to
    the first field found that is not a null structure or null if not found.</dd>
  <dt>getPropertyNames</dt>
    <dd>Get a String array that holds the names of the properties for this field.</dd>
</dl>
<h4>PVPropertyFactory</h4>
<pre>
public class PVPropertyFactory {
     public static PVProperty getPVProperty();
}
</pre>

<h3>Standard Properties</h3>

<p>This section has structure definitions that support standard properties.
These definitions are defined in project javaIOC.</p>

<h4>timeStamp</h4>

<p>A timeStamp is represented by the following structure</p>
<pre>
structure timeStamp
    long secondsPartEpoch
    int nanoSeconds
    int userTag
</pre>

<p>The Epoch is the POSIX epoch, i.e. Jan 1, 1970 00:00:00 UTC. Both the
seconds and nanoSeconds are signed integers and thus can be negative. Since the
seconds is kept as a 64 bit integer, it allows for a time much greater than the
present age of the universe. Since the nanoSeconds portion is kept as a 32 bit
integer it is subject to overflow if a value that corresponds to a value that
is greater than a little more than 2 seconds of less that about -2 seconds. The
support code always adjust seconds so that the nanoSecconds part is normalized,
i. e. it has is 0&lt;=nanoSeconds&lt;nanoSecPerSec..</p>
<h5>TimeStamp</h5>
<p>The Java definition of a timeStamp is:</p>
<pre>interface TimeStamp {
    static final long milliSecPerSec = 1000;
    static final long microSecPerSec = milliSecPerSec*milliSecPerSec;
    static final long nanoSecPerSec = milliSecPerSec*microSecPerSec;
    static final long  posixEpochAtEpicsEpoch = 631152000;
    void normalize();
    long getSecondsPastEpoch();
    long getEpicsSecondsPastEpoch();
    int getNanoSeconds();
    int getUserTag();
    void setUserTag(int userTag);
    void put(long secondsPastEpoch,int nanoSeconds);
    long getMilliSeconds();
    void put(long milliSeconds);
    void getCurrentTime();
    boolean equals(TimeStamp other);
    boolean lt(TimeStamp other);
    boolean le(TimeStamp other);
    void add(long seconds);
    void add(double seconds);
    double diff(TimeStamp a,TimeStamp b);
}</pre>

<p>where:</p>
<dl>
  <dt>normalize</dt>
    <dd>Adjust secondsPastEpoch and nanoSeconds so that 0&lt;=nanoSeconds&lt;
      nanoSecPerSec.</dd>
  <dt>getSecondsPastEpoch</dt>
    <dd>Get the seconds part of timeStamp</dd>
  <dt>getEpicsSecondsPastEpoch</dt>
    <dd>Get seconds relative to the EPICS epoch. The epics epoch starts on Jan
      1 1990 00:00:00 UTC.</dd>
  <dt>getNanoSeconds</dt>
    <dd>Get the nanoSeconds part of timeStamp.</dd>
  <dt>getUserTag</dt>
    <dd>Get the userTag</dd>
  <dt>setUserTag</dt>
    <dd>Set the userTag</dd>
  <dt>put(long secondsPastEpoch,int nanoSeconds)</dt>
    <dd>Put a value into the timeStamp.</dd>
  <dt>getMilliSeconds</dt>
    <dd>Get bthe number of milliseconds since the epoch.</dd>
  <dt>put(long milliSeconds);</dt>
    <dd>Put a value into the timeStamp given the number of milliSeconds since
      the epoch.</dd>
  <dt>getCurrentTime</dt>
    <dd>Get the curent time.</dd>
  <dt>equals</dt>
    <dd>Is this time equal other?</dd>
  <dt>lt</dt>
    <dd>Is this time less than other.</dd>
  <dt>le</dt>
    <dd>Is this time less that or equal to other.</dd>
  <dt>add(long seconds)</dt>
    <dd>Add the specified number of seconds.</dd>
  <dt>add(double seconds)</dt>
    <dd>Add the specified number of seconds.</dd>
  <dt>diff</dt>
    <dd>Compute a-b. The result is in seconds.</dd>
</dl>

<p>The TimeStamp class provides arithmetic and comparison methods for time
stamps. The result is always kept in normalized form, which means that the nano
second portion is 0&le;=nano&lt;nanoSecPerSec. Note that it is OK to have
timeStamps for times previous to the epoch.</p>
<h5>TimeStampFactory</h5>
<pre>
class TimeStampFactory implements TimeStamp {
    public static TimeStamp create();
}
</pre>
<h5>PVTimeStamp</h5>
<pre>
interface PVTimeStamp {
    boolean attach(PVField pvField);
    void detach();
    boolean isAttached();
    void get(TimeStamp timeStamp);
    boolean set(TimeStamp timeStamp);
}
</pre>
where
<dl>
  <dt>attach</dt>
    <dd>Attempts to attach to <span
     >pvField</span> It returns (false,true) if a
      timeStamp structure is found. It looks first at pvField itself and if is
      not an appropriate pvData structure but the field name is value it looks
      up the parent structure tree.</dd>
  <dt>detach</dt>
    <dd>Detach from the pvData structure.</dd>
  <dt>isAttached</dt>
    <dd>Is there an attachment to a timeStamp structure?</dd>
  <dt>get</dt>
    <dd>Copies data from the pvData structure to a TimeStamp. An exception is
      thrown if not attached to a pvData structure. </dd>
  <dt>set</dt>
    <dd>Copies data from TimeStamp to the pvData structure. An exception is
      thrown if not attached to a pvData structure. </dd>
</dl>
<h5>PVTimeStampFactory</h5>
<pre>
class PVTimeStampFactory implements PVTimeStamp {
    public static PVTimeStamp create();
}</pre>

<h4>alarm</h4>

<p>An alarm structure is defined as follows:</p>
<pre>
structure alarm
    int severity
    int status
    string message
</pre>

<p>Note that severity and status are NOT defined as enumerated structures.
The reason is performance, i. e. prevent passing the array of choice strings everywhere.
The AlarmStatus and AlarmSeverity provide the equivalent of choices for an
enumerated structure.</p>
<h5>AlarmSeverity</h5>
<p>Alarm Severity defines the possible alarm severities</p>
<pre>
enum AlarmSeverity {
 NONE,MINOR,MAJOR,INVALID,UNDEFINED;

    public static AlarmSeverity getSeverity(int value);
    private static final String[] alarmSeverityNames;
    public static String[] getSeverityNames() { return alarmSeverityNames;}
}
</pre>
where
<dl>
  <dt>getSeverity</dt>
    <dd>Get the alarm severity corresponding to the integer value.</dd>
  <dt>getSeverityNames</dt>
    <dd>Get the array of severity choices.</dd>
</dl>
<h5>AlarmStatus</h5>
<p>Alarm Status defines the possible alarm status conditions</p>
<pre>
enum AlarmStatus {
    NONE,DEVICE,DRIVER,RECORD,DB,CONF,UNDEFINED,CLIENT;

    public static AlarmStatus getStatus(int value);
    private static final String[] alarmStatusNames;
    public static String[] getStatusNames() { return alarmStatusNames;}
}
</pre>
where
<dl>
  <dt>getStatus</dt>
    <dd>Get the alarm status corresponding to the integer value.</dd>
  <dt>getStatusNames</dt>
    <dd>Get the array of status choices.</dd>
</dl>
<h5>Alarm</h5>
<pre>
class Alarm {
    public Alarm();
    public String getMessage();
    public void setMessage(String message);
    public AlarmSeverity getSeverity();
    public void setSeverity(AlarmSeverity alarmSeverity);
    public AlarmStatus getStatus();
    public void setStatus(AlarmStatus alarmStatus);
}</pre>
where
<dl>
  <dt>Alarm</dt>
    <dd>The constructor. It sets the severity to no alarm and the message to
    "".</dd>
  <dt>getMessage</dt>
    <dd>Get the message.</dd>
  <dt>setMessage</dt>
    <dd>Set the message.</dd>
  <dt>getSeverity</dt>
    <dd>Get the severity.</dd>
  <dt>setSeverity</dt>
    <dd>Set the severity.</dd>
  <dt>getStatus</dt>
    <dd>Get the status.</dd>
  <dt>setStatus</dt>
    <dd>Set the status.</dd>
</dl>

<h5>PVAlarm</h5>
<pre>interface PVAlarm {
    boolean attach(PVField pvField);
    void detach();
    boolean isAttached();
    void get(Alarm alarm);
    boolean set(Alarm alarm);
}
</pre>
<p>where</p>
<dl>
  <dt>PVAlarm</dt>
    <dd>The default constructor. Attach must be called before get or set can be
      called.</dd>
  <dt>attach</dt>
    <dd>Attempts to attach to <span
     >pvField</span> It returns (false,true) if
      it found an appropriate pvData structure. It looks first a pvField itself
      and if is not an appropriate pvData structure but the field name is value
      it looks to see if the parent structure has an appropriate sub
    structure.</dd>
  <dt>detach</dt>
    <dd>Just detaches from the pvData structure.</dd>
  <dt>isAttached</dt>
    <dd>Is there an attachment to an alarm structure?</dd>
  <dt>get</dt>
    <dd>Copies data from the pvData structure to an Alarm. An exception is
      thrown if not attached to a pvData structure. </dd>
  <dt>set</dt>
    <dd>Copies data from Alarm to the pvData structure. An exception is thrown
      if not attached to a pvData structure. </dd>
</dl>
<h5>PVAlarmFactory</h5>
<pre>
class PVAlarmFactory implements PVAlarm{
    public static PVAlarm create();
}</pre>

<h4>control</h4>

<p>Control information is represented by the following structure</p>
<pre>
structure control
    double limitLow
    double limitHigh
    double minStep
</pre>
<h5>Control</h5>
The java definition for Control is: 
<pre>class Control {
    Control();
    double getLow();
    double getHigh();
    void setLow(double value);
    void setHigh(double value);
}</pre>

<p>where</p>
<dl>
  <dt>Control</dt>
    <dd>The default constructure.</dd>
  <dt>getLow</dt>
    <dd>Get the low limit.</dd>
  <dt>getHigh</dt>
    <dd>Get the high limit.</dd>
  <dt>setLow</dt>
    <dd>Set the low limit.</dd>
  <dt>setHigh</dt>
    <dd>Set the high limit.</dd>
</dl>

<h5>PVControl</h5>
<pre>interface PVControl {
    boolean attach(PVField pvField);
    void detach();
    boolean isAttached();
    void get(Control control);
    boolean set(Control control);
}
</pre>
<p>where</p>
<dl>
  <dt>attach</dt>
    <dd>Attempts to attach to <span
     >pvField</span> It returns (false,true) if
      it found an appropriate pvData structure. It looks first a pvField itself
      and if is not an appropriate pvData structure but the field name is value
      it looks to see if the parent structure has an appropriate sub
    structure.</dd>
  <dt>detach</dt>
    <dd>Just detaches from the pvData structure.</dd>
  <dt>isAttached</dt>
    <dd>Is there an attachment to a control structure?</dd>
  <dt>get</dt>
    <dd>Copies data from the pvData structure to a Control. An exception is
      thrown if not attached to a pvData structure. </dd>
  <dt>set</dt>
    <dd>Copies data from Control to the pvData structure. An exception is
      thrown if not attached to a pvData structure. </dd>
  <dt>create</dt>
    <dd>Create a PVControl instance. Attach must be called before get or set
      can be called.</dd>
</dl>
<h5>PVControlFactory</h5>
<pre>
class PVControlFactory{
    public static PVControl create();
}</pre>

<h4>Display</h4>

<p>Display information is represented by the following structure</p>
<pre>
structure display
    double limitLow
    double limitHigh
    string description
    string format
    string units
</pre>
<h5>Display</h5>
<pre>class Display {
    Display();
    double getLow();
    double getHigh();
    void setLow(double value);
    void setHigh(double value);
    String getDescription();
    void setDescription(String value);
    String getFormat();
    void setFormat(String value);
    String getUnits();
    void setUnits(String value);
}</pre>

<p>where</p>
<dl>
  <dt>Control</dt>
    <dd>The default constructure.</dd>
  <dt>getLow</dt>
    <dd>Get the low limit.</dd>
  <dt>getHigh</dt>
    <dd>Get the high limit.</dd>
  <dt>setLow</dt>
    <dd>Set the low limit.</dd>
  <dt>setHigh</dt>
    <dd>Set the high limit.</dd>
  <dt>getDescription</dt>
    <dd>Get the description.</dd>
  <dt>setDescription</dt>
    <dd>Set the description.</dd>
  <dt>getFormat</dt>
    <dd>Get the format.</dd>
  <dt>setFormat</dt>
    <dd>Set the format.</dd>
  <dt>getUnits</dt>
    <dd>Get the units.</dd>
  <dt>setUnits</dt>
    <dd>Set the units.</dd>
</dl>

<h5>PVDisplay</h5>
<pre>interface PVDisplay {
    boolean attach(PVField pvField);
    void detach();
    boolean isAttached();
    void get(Display display);
    boolean set(Display display);
}
</pre>

<p>where</p>
<dl>
  <dt>attach</dt>
    <dd>Attempts to attach to <span
     >pvField</span> It returns (false,true) if
      it found an appropriate pvData structure. It looks first a pvField itself
      and if is not an appropriate pvData structure but the field name is value
      it looks to see if the parent structure has an appropriate sub
    structure.</dd>
  <dt>detach</dt>
    <dd>Just detaches from the pvData structure.</dd>
  <dt>isAttached</dt>
    <dd>Is there an attachment to a display structure?</dd>
  <dt>get</dt>
    <dd>Copies data from the pvData structure to a Display. An exception is
      thrown if not attached to a pvData structure.</dd>
  <dt>set</dt>
    <dd>Copies data from Display to the pvData structure. An exception is
      thrown if not attached to a pvData structure. </dd>
  <dt>create</dt>
    <dd>Create a PVDisplay instance. Attach must be called before get or set
      can be called.</dd>
</dl>
<h5>PVDisplayFactory</h5>
<pre>
class PVDisplayFactory implements PVDisplay{
    public static PVDisplay create()
}</pre>

<h4>enumerated structure</h4>

<p>An enumerated structure is a structure that has fields:</p>
<pre>structure
    int index
    string[] choices</pre>

<h5>PVEnumerated</h5>
<pre>interface PVEnumerated {
    boolean attach(PVField pvField);
    void detach();
    boolean isAttached();
    boolean setIndex(int index);
    int getIndex();
    String getChoice();
    boolean choicesMutable();
    String[] getChoices();
    boolean setChoices(String[] choices);
}
</pre>

<p>where</p>
<dl>
  <dt>PVEnumerated</dt>
    <dd>The default constructor. Attach must be called before any get or set
      method can be called.</dd>
  <dt>attach</dt>
    <dd>Attempts to attach to <span
     >pvField</span> It returns (false,true) if
      pvField (is not, is) an enumerated structure.</dd>
  <dt>detach</dt>
    <dd>Just detaches from the pvData structure.</dd>
  <dt>isAttached</dt>
    <dd>Is there an attachment to an enemerated structure?</dd>
  <dt>setIndex</dt>
    <dd>Set the index field in the pvData structure. An exception is thrown if
      not attached to a pvData structure. </dd>
  <dt>getIndex</dt>
    <dd>Get the index field in the pvData structure. </dd>
  <dt>getChoice</dt>
    <dd>Get the String value corresponding to the current index field in the
      pvData structure. An exception is thrown if not attached to a pvData
      structure. </dd>
  <dt>choicesMutable</dt>
    <dd>Can the choices be changed? Note that this is often true. An exception
      is thrown if not attached to a pvData structure. </dd>
  <dt>getChoices</dt>
    <dd>Get the array of choices. An exception is thrown if not attached to a
      pvData structure. </dd>
  <dt>getNumberChoices</dt>
    <dd>Get the number of choices. An exception is thrown if not attached to a
      pvData structure. </dd>
  <dt>setChoices</dt>
    <dd>Change the choices. An exception is thrown if not attached to a pvData
      structure. </dd>
</dl>

<h5>PVEnumeratedFactory</h5>
<pre>
class PVEnumeratedFactory{
    PVEnumerated create();
}</pre>
<h3>multiChoice</h3>

<p>NOTE: This is not currently used by anything.
Bob sees it as an important facility in the future.
</p>
<p>MultiChoice is support for a multiChoice structure,
which is a structure containing two fields:</p>
<dl>
   <dt>choices</dt>
     <dd>An array of strings</dd>
   <dt>bitMask</dt>
     <dd>A bitMask that selects a subset of the choices.</dd>
</dl>

<h4>MultiChoice</h4>
<pre>
    public interface MultiChoice {
        interface Choices {
            String[] getChoices();
            int getNumberChoices();
        }
        byte[] getBitMask();
        String[] getChoices();
        Choices getSelectedChoices();
        void setBit(int index);
        void clear();
        int registerChoice(String choice);
    }
</pre>
<p>where</p>
<dl>
  <dt>getBitMask</dt>
    <dd>Returns the bitMask.</dd>
  <dt>getChoices</dt>
    <dd>Returns the complete set of choices..</dd>
  <dt>getSelectedChoices</dt>
    <dd>Returns the interface for getting the selected choices..</dd>
  <dt>setBit</dt>
    <dd>Select the choice for specified bit..</dd>
  <dt>clear</dt>
    <dd>Clear the bitMask, i.e. no choices are selected..</dd>
  <dt>registerChoice</dt>
    <dd>Register a new choice. If thed choice already exists then it''s index
      is returned. If not it is appended to the choices.</dd>
</dl>
<h4>MultiChoiceFactory</h4>
<pre>
    public class MultiChoiceFactory{
         public static MultiChoice getMultiChoice(PVField pvField);
    }
</pre>

<h2 >Package org.epics.pvdata.misc</h2>

<h3>Overview</h3>

<p>This package provides utility code:</p>
<dl>
  <dt>BitSet</dt>
    <dd>An implementation of BitSet that can be serialized.</dd>
  <dt>MessageQueue</dt>
    <dd>Support for queuing messages for requesters.</dd>
  <dt>Thread</dt>
    <dd>ThreadCreate and Executor</dd>
  <dt>TimeFunction</dt>
    <dd>Time how long a function call requires.</dd>
  <dt>LinkedList</dt>
    <dd>A douuble linked list facility that requires the user to allocate a
      node. It is more efficient that ArrayList and does not require the
      implementation to allocate storage for the nodes.</dd>
  <dt>Timer</dt>
    <dd>An implementation of Timer that does not require an object to be
      created for each timer request.</dd>
  <dt>Queue</dt>
    <dd>A queue implementation.</dd>
  <dt>Destroyable</dt>
    <dd>A base interface for destroy.</dd>
  <dt>Serialize</dt>
    <dd>A helper for serialization.</dd>
</dl>


<h3>bitSet</h3>
<h4>BitSet</h4>
<p>This is adapted from the java.util.BitSet. It adds serializable. See
java.util.BitSet for a description. This implementation adds the following
additional methods:</p>
<pre>    public boolean getAndSet(int bitIndex);
    public void set(BitSet src);
    public void or_and(BitSet set1, BitSet set2);</pre>

<p>where</p>
<dl>
  <dt>getAndSet</dt>
    <dd>gets and sets the bit at bitIndex.</dd>
  <dt>set</dt>
    <dd>fast copy operation from src to this bitSet</dd>
  <dt>or_and</dt>
    <dd>The result is the or of the current bitSet with the value of set1.and
      set2. The number of bits is the
    Math.max(set1.bitsInUse,set2.bitsInUse);</dd>
</dl>

<p>This is an implementation of BitSet that supports serialization, which the
standard Jave implementation does not allow.</p>

<h4>BitSetUtil</h4>
<pre>interface BitSetUtil {
    boolean compress(BitSet bitSet,PVStructure pvStructure);
}
</pre>

<p>This provides functions that operate of a BitSet for a PVStructure. It
currently has only one method:</p>
<dl>
  <dt>compress</dt>
    <dd>Compress the bits in a BitSet related to a structure.<br />
      For each structure: 
      <ol>
        <li>If the bit for the structure is set then the bit for all subfields
          of the structure are cleared. </li>
        <li>If the bit for the structure is not set but all immediate subfields
          have their bit set then the bit for the structure is set and the bits
          for all subfields are cleared. </li>
      </ol>
      Note that this is a recursive algorithm. That is if every immediate
      subfield has it's offset bit set then the bits for ALL fields that reside
      in the structure will be cleared.</dd>
    <dd>Channel Access can call this before sending data. It can then pass
      entire structures if the structure offset bit is set. </dd>
</dl>
<h4>BitSetUtilFactory</h4>
<pre>
class BitSetUtilFactory {
    public static BitSetUtil getCompressBitSet();
}</pre>

<h3>message Queue</h3>

<h4>MessageNode</h4>
<pre>
public class MessageNode {
    public String message;
    public MessageType messageType;
}
</pre>
<h4>MessageQueue</h4>
<pre>
public interface MessageQueue {
    MessageNode get();
    boolean put(String message,MessageType messageType,boolean replaceLast);
    boolean isEmpty();
    boolean isFull();
    int getClearOverrun();
}
</pre>
<p>This is for use by code that wants to handle messages without blocking
higher priority threads.</p>

<p>A messageNode is a class with two public data members:</p>
<dl>
  <dt>message</dt>
<dd>The message.</dd>
  <dt>messageType</dt>
<dd>The message type.</dd>
</dl>

<p>A messageQueue is an interface with methods:</p>
<dl>
  <dt>put</dt>
<dd>Put a new message into the queue. False is returned if the queue was
  full and true otherwise.</dd>
  <dt>isEmpty</dt>
<dd>Is the queue empty?</dd>
  <dt>isFull</dt>
<dd>Is the queue full?</dd>
  <dt>getClearOverrun</dt>
<dd>Get the number of times replaceFirst or replaceLast have been called
  since the last call to getClearOverrun. The internal counter is reset to
  0.</dd>
</dl>
<h4>MessageQueueFactory</h4>
<pre>
public class MessageQueueFactory {
    public static MessageQueue create(int size);
}</pre>
where
<dl>
  <dt>create</dt>
    <dd>Create a MessageQueue and return the interface.</dd>
</dl>

<h3>thread</h3>

<h4>ThreadPriority</h4>
<pre>
public enum ThreadPriority {
    lowest,
    lower,
    low,
    middle,
    high,
    higher,
    highest;
    
    public static final int[] javaPriority;
    public int getJavaPriority();
    public static int getJavaPriority(ThreadPriority threadPriority);
}
</pre>

<h4>ThreadReady</h4>
<pre>
interface ThreadReady {
    void ready();
}
</pre>
<h4>RunnableReady</h4>
<pre>
interface RunnableReady {
    void run(ThreadReady threadReady);
}
</pre>
<h4>ThreadCreate</h4>
<pre>
interface ThreadCreate {
    Thread create(String name, int priority, RunnableReady runnableReady);
    Thread[] getThreads();
}
</pre>
<h4>ThreadCreateFactory</h4>
<pre>
public class ThreadCreateFactory {
    public static ThreadCreate getThreadCreate();
}</pre>

<p>ThreadCreate provides two features:</p>
<ol>
  <li>Create does not return until ReadyRunnable.run calls
  ThreadReady.ready().</li>
  <li>A list of all active threads is kept. getThreads provides access to the
list.</li>
</ol>

<h4>executor</h4>

<p>An Executor is a thread that can execute any object that implements the Java
Runnable interface. The user can request that a single command be executed. If
the command is already in the list of commands to be executed it is NOT added
to the list when add is called.</p>
<h5>ExecutorNode</h5>
<pre>
public interface ExecutorNode {}
</pre>
<h5>Executor</h5>
<pre>
public interface Executor {
    ExecutorNode createNode(Runnable command);
    void execute(ExecutorNode executorNode);
    void stop();
}
</pre>
<h5>ExecutorFactory</h5>
<pre>
public class ExecutorFactory {
    static public Executor create(String name,ScanPriority priority);
}</pre>
where 
<dl>
  <dt>createNode</dt>
<dd>Create a ExecutorNode that can be passed to execute.</dd>
  <dt>execute</dt>
<dd>Request that command be executed. If it is already on the run list
  nothing is done.</dd>
  <dt>stop</dt>
<dd>Stop the thread and refuse additional execute requests.</dd>
</dl>

<h3>time a function call</h3>

<p>TimeFunction is a facility that measures the average number of seconds a
function call requires. When timeCall is called, it calls function in a loop.
It starts with a loop of one iteration. If the total elapsed time is less then
.1 seconds it increases the number of iterrations by a factor of 10. It keeps
repeating until the elapsed time is greater than .1 seconds. It returns the
average number of seconds per call.</p>
<h4>TimeFunctionRequester</h4>
<pre>
public interface TimeFunctionRequester {
    void function();
}
</pre>
<h4>TimeFunction</h4>
<pre>
public interface TimeFunction {
    double timeCall();
}
</pre>
<h4>TimeFunctionFactory</h4>
<pre>
public class TimeFunctionFactory {
    public static TimeFunction create(TimeFunctionRequester requester);
}</pre>

<h3>linked list</h3>

<p>LinkedList implements a double linked list that requires a user to allocate
the nodes. It is more efficent that ArrayList for implementing stacks and
queues. For lists that are traversed while new elements can be added or
removed, LinkedListArray provides a way to get an array of the currrent
elements without allocating a new array each time the array is traversed.</p>

<p>LinkedListArray converts a LinkedList to an LinkNode array. The
implementation provided by LinkedListFactory only creates a new LinkNode array
w.en the number of elements in the linkedList passed to setNodes is greater
than the length of the current LinkNode array.</p>
<h4>LinkedListNode</h4>
<pre>
public interface LinkedListNode&lt;T&gt; {
    public T getObject();
    boolean isOnList();
} 
</pre>
<h4>LinkedList</h4>
<pre>
public interface LinkedList {
    void addTail(LinkedListNode&lt;T&gt; listNode);
    void addHead(LinkedListNode&lt;T&gt; listNode);
    void insertAfter(LinkedListNode&lt;T&gt; listNode,LinkedListNode&lt;T&gt; addNode);
    void insertBefore(LinkedListNode&lt;T&gt; listNode,LinkedListNode&lt;T&gt; addNode);
    LinkedListNode&lt;T&gt; removeTail();
    LinkedListNode&lt;T&gt; removeHead();
    void remove(LinkedListNode&lt;T&gt; listNode);
    void remove(T object);
    LinkedListNode&lt;T&gt; getHead();
    LinkedListNode&lt;T&gt; getTail();
    LinkedListNode&lt;T&gt; getNext(LinkedListNode&lt;T&gt; listNode);
    LinkedListNode&lt;T&gt; getPrev(LinkedListNode&lt;T&gt; listNode);
    boolean isEmpty();
    boolean contains(T object);
}
</pre>
<h4>LinkedListArray</h4>
<pre>
public interface LinkedListArray&lt;T&gt; {
    void setNodes(LinkedList&lt;T&gt; linkedList);
    LinkedListNode&lt;T&gt;[] getNodes();
    int getLength();
    void clear();
}
</pre>
<h4>LinkedListCreate</h4>
<pre>
public class LinkedListCreate&lt;T&gt; {
    public static LinkedList&lt;T&gt; create();
    public static LinkedListNode&lt;T&gt; createNode(Object object);
    public static LinkedListArray&lt;T&gt; createArray();
}</pre>

<p>LinkedListCreate is created as follows:</p>
<pre>
LinkedListCreate&lt;SomeObject&gt; linkedListCreate = new LinkedListCreate&lt;SomeObject&gt;();</pre>

<p>Then a linked list can be created as follows:</p>
<pre>
LinkedList&lt;SomeObject&gt; linkedList = linkedListCreate.create();</pre>

<p>The only way a node can be allocated is by calling
linkedListCreate.createNode(SomeObject object). The object passed to createNode
is what is returned by LinkedList.getObject. For example:</p>
<pre>
private static class SomeObject {
    private LinkedListNode&lt;SomeObject&gt; listNode = null;
    // other definitions


    private Node(/* arguments*/) {
        listNode = linkedListCreate.createNode(this);
    }

    LinkedListNode&lt;SomeObject&gt; getListNode() {return listNode};
}

// then

SomeObject someObject = new SomeObject(/* args */);
linkedList.addTail(someObject);</pre>

<p>A node can only be on one list at a time but can be put, at different times,
on different lists as long as they all hold the same type of objects.</p>

<p>The class does not provide a lock but the user can synchronized via calls
like:</p>
<pre>
synchronized(linkedList) {
    linkedList.addTail(listNode);
}</pre>

<p>The following is an example of how to use LinkedListArray.</p>
<pre>
    LinkedListNode&lt;SomeObject&gt;[] nodes = null;
    int length = 0;
    synchronized(linkedList) {
        linkedListArray.setNodes(linkedList);
        nodes = linkedListArray.getNodes();
        length = linkedListArray.getLength();
    }
    for(int i=0; i&lt;length; i++) {
        SomeObject object = nodes[i].getObject();
        // do something with object
    }</pre>

<h3>timer</h3>

<p>This provides a general purpose timer. It provides the following features
not provided by java.util.Timer and java.util.TimerTask:</p>
<ol>
  <li>Priority<br />
    The java.util implementation does not allow the user to specify the
    priority of the timer thread. This implementation does.</li>
  <li>TimerNode<br />
    A java.util.TimerTask is not reusable. Once a timerTask has been canceled
    or a delay timerTask has run, the TimerTask can not be reused. Instead a
    new TimerTask must be created. A TimerNode can be reused.</li>
</ol>

<h4>Timer</h4>
<pre>
interface Timer {
    interface TimerCallback {
        void callback();
        void timerStopped();
    }
    interface TimerNode {
        void cancel();
        boolean isScheduled();
    }
    void scheduleAfterDelay(TimerNode timerNode,double delay);
    void schedulePeriodic(TimerNode timerNode,double delay,double period);
    void stop();
}
</pre>
<p>This is the interface for scheduling a timer callback. A timer is created by
calling TimerFactory.create. It has the methods:</p>
<dl>
  <dt>scheduleAfterDelay</dt>
    <dd>A request to schedule a callback after a delay specified in seconds. If
      stop has been called then TimerCallback.timerStopped is called
      immediately.</dd>
  <dt>schedulePeriodic</dt>
    <dd>Schedule a periodic callback. If stop has been called then
      TimerCallback.timerStopped is called immediately.</dd>
  <dt>stop</dt>
    <dd>Stop the timer. The queue is emptied and TimerCallback.timerStopped is
      called for each element of the queue. Further schedule calls result in a
      call to TimerCallback.timerStopped. Once stopped a timer is no longer
      useful. A new timer must be created.</dd>
</dl>
<h4>TimerFactory</h4>
<pre>
class TimerFactory {
    static public Timer create(String threadName, ThreadPriority priority);
    static public TimerNode createNode(TimerCallback timerCallback);
}</pre>
<p>This is the factory that implements the Timer and TimerNode interfaces. It
has the methods:</p>
<dl>
  <dt>create</dt>
    <dd>Create a new Timer.</dd>
  <dt>createNode</dt>
    <dd>Create a TimerNode. A timerNode can be used to schedule any timer but a
      timeNode can only be on a single timer queue and only once on a given
      timer queue.</dd>
</dl>

<h4>TimerCallback</h4>

<p>This is an interface that must be implemented by the user. It has the
following methods: </p>
<dl>
  <dt>callback</dt>
    <dd>This is called when a timer expires. This is called with no locks held.
      When called a delay timer is no longer on the queue but a periodioc timer
      is on a queue. Thus the callback for a delay timer can issue a new
      schedule request but a periodic timer must not. Note the explaination of
      TimerNode.cancel below.</dd>
  <dt>timerStopped</dt>
    <dd>Timer.stop was called when a timer request was queued. or if the timer
      is stopped and a schedule request is made.</dd>
</dl>

<h4>TimerNode</h4>

<p>This is an interface implemented by TimerFactory. It is allocated by calling
TimerFactory.createNode. It is passed as an argument when scheduling a
callback. It has the single method:</p>
<dl>
  <dt>cancel</dt>
    <dd>This is called to cancel a timer request. If a callback has been
      dequeued but the callback not called when cancel is called then a
      callback may still happen. New schedule requests can be made after a
      cancel request has been made.</dd>
  <dt>isScheduled</dt>
    <dd>Is this node in the timerQueue.</dd>
</dl>

<h3>queue</h3>

<p>This provides a queue which has an immutable capacity, which is specified
when the queue is created. When the queue is full the user code is expected to
keep using the current el;ement until a new free element becomes avalable. This
is used by pvData.monitor.</p>
<h4>QueueCreate</h4>
<pre>
public class QueueCreate&lt;T&gt; {
    public Queue&lt;T&gt; create(QueueElement&lt;T&gt;[] queueElements) {
        return new QueueImpl&lt;T&gt;(queueElements);
    }

    public QueueElement&lt;T&gt; createQueueElement(T object) {
        return new QueueElementImpl&lt;T&gt;(object);
    }
}
</pre>
<h4>QueueElement</h4>
<pre>
public interface QueueElement&lt;T&gt; {
    public T getObject();
}
</pre>
<h4>Queue</h4>
<pre>
public interface Queue&lt;T&gt; {
    void clear();
    int getNumberFree();
    int capacity();
    QueueElement&lt;T&gt; getFree();
    void setUsed(QueueElement&lt;T&gt; queueElement);
    QueueElement&lt;T&gt; getUsed();
    void releaseUsed(QueueElement&lt;T&gt; queueElement);
}</pre>

<p>The queue methods are:</p>
<dl>
  <dt>clear</dt>
    <dd>Make the queue empty.</dd>
  <dt>getNumberFree</dt>
    <dd>Get the number of fee elements in the queue.</dd>
  <dt>capacity</dt>
    <dd>Get the capacity, i.e. the maximun number of elements the queue can
      hold.</dd>
  <dt>getFree</dt>
    <dd>Get the next free element. Null is returned if no free elements are
      available. If a non null value is returned then the element belongs to
      the caller until setUsed is called.</dd>
  <dt>setUsed</dt>
    <dd>Set a queue element used. This <span
      style="font-weight:bold;">must</span> be the element returned by the last
      call to getFree. </dd>
  <dt>getUsed</dt>
    <dd>Get the next used element of null if no more used elements are
      available.</dd>
  <dt>releaseUsed</dt>
    <dd>Set a queue element free. This must be the element returned by the last
      call to getUsed. </dd>
</dl>

<p>A queueCreate instance is created via a call like the following:</p>
<pre> QueueCreate&lt;MyObject&gt; queueCreate = new QueueCreate&lt;MyObject&gt;();</pre>

<p>Once a queueCreate is available a queue instance is created via code like
the following:</p>
<pre>Queue&lt;MyObject&gt; queue create(MyObject[] myObjects) {
    QueueElement&lt;MyObject&gt;[] queueElements = new QueueElement[length];
    for(int i=0; i&lt;length; i++) {
        QueueElement&lt;MonitorElement&gt; queueElement =
                 queueCreate.createQueueElement(myObjects[i);
        queueElements[i] = queueElement;
    }
    return queueCreate.create(queueElements);
}</pre>

<p>A producer calls getFree and setUsed via code like the following:</p>
<pre>
   MyObject getFree() {
       QueueElement&lt;MyObject&gt; queueElement = queue.getFree();
       if(queueElement==null) return null;
       return queueElement.getObject();
  }</pre>

<p>A consumer calls getUsed and releaseUsed via code like the following:</p>
<pre>
     while(true) {
         QueueElement&lt;MyObject&gt; queueElement = queue.getUsed();
         if(queueElement==null) break;
         MyObject myObject = queueElement.getObject();
         // do something with myObject
         queue.releaseUsed(queueElement);
     }</pre>

<h3>Destroyable</h3>

<p>This is a base interface used by many other interfaces.</p>
<pre>interface Destroyable  {
    void destroy();
}</pre>

<p>where</p>
<dl>
  <dt>destroy</dt>
    <dd>Destroy the object.</dd>
</dl>

<h3>SerializeHelper</h3>

<p>This is a helper class for serialization, which is required for sending and
receiving pvData over the nerwork.</p>
<pre>class SerializeHelper {
    static void writeSize(final int s, ByteBuffer buffer);
    static int readSize(ByteBuffer buffer);
    static void serializeString(final String value, ByteBuffer buffer);
    static void serializeSubstring(final String value,
         int offset, int length, ByteBuffer buffer);
    static String deserializeString(ByteBuffer buffer);
}</pre>

<p>where</p>
<dl>
  <dt>writeSize</dt>
    <dd>Serialize the size.</dd>
  <dt>readSize</dt>
    <dd>Deserialize the size.</dd>
  <dt>serializeString</dt>
    <dd>Serialize a String.</dd>
  <dt>serializeSubstring</dt>
    <dd>Serialize a substring.</dd>
  <dt>deserializeString</dt>
    <dd>Deserialize a string.</dd>
</dl>

<h2>support for copy and monitor</h2>
<p><b>copy</b> and <b>monitor</b> are not used in this project.
They are intended for use by pvAccess and by pvAccess servers.
They are provided with this project because the code depends only on
pvData itself.
</p>
<p>This document describes C++ specific code.
<a href="http://epics-pvdata.sourceforge.net/informative/pvRequest.html">
pvRequest.html</a>
provides a language independent overview of <b>copy</b> and <b>monitor</b>.
</p>
<p>
<b>NOTE:pvRequest.html</b> must be updated since it is based on an earlier version of pvCopy that
had knowlege of PVRecord. The C++ version was implemented in pvDatabaseCPP
and the Java version on pvIOCJava.
At present only the C++ version of the new API for pvCopy is implemented.
</p>
<p>Copy provides:
<dl>
   <dt>createRequest</dt>
     <dd>
      The Channel create methods in pvAccess all have an argument
      <b>PVStructure pvRequest</b>.<br />
      Given an ascii string createRequest creates a PVStructure that provides
      a pvData representation of the information from the ascii string.
      It is this structure that can be passed to the channel create methods.<br />
      The information in a pvRequest selects an arbitrarary subset of the
      fields in a top level structure that resides in the server.
      In addition options can be specified. Both global and field specific
      options can be specified.
      </dd>
   <dt>pvCopy</dt>
     <dd>This is a faculity used by channel providers.
     It provides client specific code that manages a copy of an arbitrary
     subset of the fields in a top level structure that resides in the
     provider. It also allows provider access to options specified
     by the client.
     </dd>
</dl>
Monitor provides:
<dl>
  <dt>monitor</dt>
    <dd>This is support code for channel providers that implement channel
    monitor. It, together with the queue facility, provides support for
    monitor queues.
    </dd>
  <dt>monitorPlugin</dt>
    <dd>This is support for implementing monitor plugins.
     A monitor plugin can be developed that has no knowledge
     of pvAccess but only pvData.
    </dd>
</dl>
</p>

<h2>support for copy</h2>
<p><b>copy</b> provides the ability to create a structure that has 
a copy of an arbitrary subset of the fields in an existing top level
structure. In addition it allows global options and field specific options.
It has two main components: <b>createRequest</b> and <b>pvCopy</b>.
Given a string createRequest creates a pvRequest, which is a PVStructure
that has the format expected by <b>pvCopy</b>.
</p>

<h3>createRequest</h3>
<p>This is mainly used by pvAccess clients. Given a request string it creates
a pvRequest structure that can be passed to the pvAccess create methods.
In turn pvAccess passes the pvRequest to a local channel provider which 
then passes it to pvCopy.
</p>
<p>The definition of the public members is:</p>
<pre>
class CreateRequest {
...
     static CreateRequestPtr create();
     virtual PVStructurePtr createRequest(String const &amp;request);
     String getMessage();
};
</pre>
<p>An example of how it is used is:</p>
<pre>
CreateRequestPtr createRequest = CreateRequest::create();
PVStructurePtr pvRequest = createRequest-&gt;createRequest(request);
if(pvRequest==NULL) {
    String error = createRequest-&gt;getMessage();
    // take some action
} else {
    //success do something
}
</pre>
<h3>pvCopy</h3>
<p>The definition of the public members is:</p>
<pre>
class epicsShareClass PVCopyTraverseMasterCallback
{
...
    virtual void nextMasterPVField(PVFieldPtr const &amp;pvField);
};

class class epicsShareClass PVCopy
{
...
    static PVCopyPtr create(
        PVStructurePtr const &amp;pvMaster,
        PVStructurePtr const &amp;pvRequest,
        String const &amp; structureName);
    PVStructurePtr getPVMaster();
    void traverseMaster(PVCopyTraverseMasterCallbackPtr const &amp; callback);
    StructureConstPtr getStructure();
    PVStructurePtr createPVStructure();
    size_t getCopyOffset(PVFieldPtr const  &amp;masterPVField);
    size_t getCopyOffset(
        PVStructurePtr const  &amp;masterPVStructure,
        PVFieldPtr const  &amp;masterPVField);
     PVFieldPtr getMasterPVField(std::size_t structureOffset);
     void initCopy(
        PVStructurePtr const  &amp;copyPVStructure,
        BitSetPtr const  &amp;bitSet);
     void updateCopySetBitSet(
        PVStructurePtr const  &amp;copyPVStructure,
        BitSetPtr const  &amp;bitSet);
    void updateCopyFromBitSet(
        PVStructurePtr const  &amp;copyPVStructure,
        BitSetPtr const  &amp;bitSet);
    void updateMaster(
        PVStructurePtr const  &amp;copyPVStructure,
        BitSetPtr const  &amp;bitSet);
    PVStructurePtr getOptions(std::size_t fieldOffset);
...
};
</pre>
where
<dl>
   <dt>PVCopyTraverseMasterCallback::nextMasterPVField</dt>
     <dd>
       <b>PVCopyTraverseMasterCallback</b> is a callback which must
       be implemented by the code that uses pvCopy, normally
       the channel provider. It has the single method <b>nextMasterPVField</b>
       <br />
       <b>nextMasterPVField</b> is called for each field in the master
       as a result of a call to <b>traverseMaster</b>.
     </dd>
   <dt>create</dt>
      <dd>
        This is the method for creating a PVCopy instance.<br/>
        <dl>
           <dt>pvMaster</dt>
             <dd>the top level sructure managed by the server.</dd>
          <dt>pvRequest</dt>
           <dd>selects the set of subfields desired
         and options for each field.</dd>
          <dt>structureName</dt>
            <dd>the name for the top level of any PVStructure created.
            </dd>
        </dl>
      </dd>
   <dt>getPVMaster</dt>
      <dd>
       Gets the top level structure from pvMaster.
      </dd>
   <dt>traverseMaster</dt>
      <dd>
      Traverse all fields of the top level structure of pvMaster.
      For each field the callback is called.
      </dd>
   <dt>getStructure</dt>
      <dd>
       Get the introspection interface for a PVStructure for e copy.
      </dd>
   <dt>createPVStructure</dt>
      <dd>Create a copy instance.
       Monitors keep a queue of monitor elements.
     Since each element needs a PVStructure, multiple top level structures
     will be created.
      </dd>
   <dt>getCopyOffset</dt>
      <dd>Given a field in pvMaster.
       return the offset in copy for the same field.
      A value of String::npos means that the copy does not have this field.
      Two overloaded methods are provided. The first is called if
      the field of master is not a structure. The second is for
      subfields of a structure.
      </dd>
   <dt>getMasterPVField</dt>
      <dd>
       Given a offset in the copy get the corresponding field in pvMaster.
      </dd>
   <dt>initCopy</dt>
      <dd>
       Initialize the fields in copyPVStructure
       by giving each field the  value from the corresponding field in pvMaster.
       bitSet will be set to show that all fields are changed.
       This means that bit set will have the value <b>{0}</b>.
      </dd>
   <dt>updateCopySetBitSet</dt>
      <dd>
      Set all fields in copyPVStructure to the value of the corresponding field
      in pvMaster. Each field that is changed has it's corresponding
      bit set in bitSet.
      </dd>
   <dt>updateCopyFromBitSet</dt>
      <dd>
       For each set bit in bitSet set the field in copyPVStructure to the value
      of the corrseponding field in pvMaster.
      </dd>
   <dt>updateMaster</dt>
      <dd>
       For each set bit in bitSet set the field in pvMaster to the value
      of the corrseponding field in copyPVStructure.
      
      </dd>
   <dt>getOptions</dt>
      <dd>
       Get the options for the field at the specified offset.
      A NULL is returned if no options were specified for the field.
      If options were specified,PVStructurePtr is 
      a structure with a set of PVString subfields that specify name,value
      pairs. name is the subField name and value is the subField value.
      </dd>
</dl>




<h2>support for monitor</h2>
<p>This consists of two components:
<dl>
   <dt>monitor</dt>
     <dd>Used by code that implements pvAccess montors.</dd>
   <dt>monitorPlugin</dt>
      <dd>Code that provides special semantics for monitors.</dd>
</dl>
</p>
<h3>monitor</h3>
<pre>
class MonitorElement {
    MonitorElement(PVStructurePtr const &amp; pvStructurePtr);
    PVStructurePtr pvStructurePtr;
    BitSetPtr changedBitSet;
    BitSetPtr overrunBitSet;
};

class Monitor {
    virtual Status start() = 0;
    virtual Status stop() = 0;
    virtual MonitorElementPtr poll() = 0;
    virtual void release(MonitorElementPtr const &amp; monitorElement) = 0;
};

class MonitorRequester : public virtual Requester {
    virtual void monitorConnect(Status const &amp; status,
        MonitorPtr const &amp; monitor, StructureConstPtr const &amp; structure) = 0;
    virtual void monitorEvent(MonitorPtr const &amp; monitor) = 0;
    virtual void unlisten(MonitorPtr const &amp; monitor) = 0;
};
</pre>
<h4>monitorElement</h4>
<p><b>MonitorElement</b> holds the data for one element of a monitor queue.
It has the fields:
<dl>
  <dt>pvStructurePtr</dt>
    <dd>A top level structure with data values at the time the monitors occurs.</dd>
  <dt>changedBitSet</dt>
     <dd>Shows which fields have changed since the previous monitor.</dd>
  <dt>overrunBitSet</dt>
     <dd>Shows which fields have changed more han once since the previous monitor.</dd>
</dl>
</p>
<h4>monitorElement queue</h4>
<p>
A queue of monitor elements must be implemented by any channel provider that implements
<b>Channel::createMonitor</b>.
For an example implementation look at pvDatabaseCPP.
It has the following:
<pre>
typedef Queue&lt;MonitorElement&gt; MonitorElementQueue;
typedef std::tr1::shared_ptr&lt;MonitorElementQueue&gt; MonitorElementQueuePtr;

class MultipleElementQueue :
    public ElementQueue
{
public:
    POINTER_DEFINITIONS(MultipleElementQueue);
    virtual ~MultipleElementQueue(){}
    MultipleElementQueue(
        MonitorLocalPtr const &amp;monitorLocal,
        MonitorElementQueuePtr const &amp;queue,
        size_t nfields);
    virtual void destroy(){}
    virtual Status start();
    virtual Status stop();
    virtual bool dataChanged();
    virtual MonitorElementPtr poll();
    virtual void release(MonitorElementPtr const &amp;monitorElement);
...
};
</pre>
<h4>Monitor</h4>
<p><b>Monitor</b> must be implemented by any channel provider that implements
<b>Channel::createMonitor</b>.
Remote PVAccess also implements Monitor on the client side.
Note that each client has it's own queue that is not shared with other client.
</p>
<p>Monitor has the following methods:</p>
<dl>
   <dt>start</dt>
     <dd>
      Start monitoring.
      This will result in a an inital monitor that has the current value
      of all fields.
     </dd>
   <dt>stop</dt>
     <dd>
      Stop monitoring.
     </dd>
   <dt>poll</dt>
     <dd>
      Called to get a monitor element.
      If no new elemants are available then a null pointer is returned.
     </dd>
   <dt>release</dt>
     <dd>
      Release the monotor element.
      The caller owns the monitor element between the calls to poll and release.
     </dd>
<dl>
</dl>
<h4>MonitorRequester</h4>
<p>This must be implemented by a pvAccess client.
It has the methods:</p>
<dl>
  <dt>monitorConnect</dt>
     <dd>
      A monitor has either connected of disconnected.
     </dd>
  <dt>monitorEvent</dt>
     <dd>
      A new monitor element is available.
     </dd>
  <dt>unlisten</dt>
     <dd>
      The channel is going away. The client cam no longer access the monitor.
     </dd>
</dl>

<h3>monitorPlugin</h3>
<pre>
class MonitorPlugin
{
    virtual String const &amp; getName() = 0;
    virtual bool causeMonitor(
        PVFieldPtr const &amp;pvField,
        PVStructurePtr const &amp;pvTop,
        MonitorElementPtr const &amp;monitorElement) = 0;
    virtual void monitorDone(
        MonitorElementPtr const &amp;monitorElement);
    virtual void startMonitoring();
    virtual void stopMonitoring();
    virtual void beginGroupPut();
    virtual void endGroupPut();
};

class MonitorPluginCreator
{
    virtual MonitorPluginPtr create(
        FieldConstPtr const &amp;field,
        StructureConstPtr const &amp;top,
        PVStructurePtr const &amp;pvFieldOptions) = 0;
     virtual String const &amp; getName() = 0;
}

class MonitorPluginManager
{
    static MonitorPluginManagerPtr get();
    bool addPlugin(
         String const &amp;pluginName,
         MonitorPluginCreatorPtr const &amp;creator);
    MonitorPluginCreatorPtr findPlugin(String const &amp;pluginName);
    void showNames();
};

</pre>
<h4>MonitorPlugin</h4>
<p><b>MonitorPlugin</b> must be implemented by the plugin implementation.
It has methods:</p>
<dl>
   <dt>getName</dt>
     <dd>Get the name of the plugin.</dd>
   <dt>causeMonitor</dt>
     <dd>
       Should the value of pvField cause a monitor to be raised.
       pvField and pvTop are fields in the top level structure
       being monitored. monitorElement has the top level structure
       for the copy</b>.
       The implementation should <b>not</b> modify the fields in the structure
        being monitored.
        Called with pvTop locked.
     </dd>
   <dt>monitorDone</dt>
     <dd>
       Called just before monitorElement will be given to client.
       The plugin can change the data values and bitSets in monitorElement.
        Called with pvTop unlocked.
    </dd>
   <dt>startMonitoring</dt>
     <dd>
      Monitoring is starting.
     </dd>
   <dt>stopMonitoring</dt>
     <dd>
      Monitoring is being stopped.
     </dd>
   <dt>beginGroupPut</dt>
     <dd>
      A set of puts is starting.
        Called with pvTop locked.
     </dd>
   <dt>endGroupPut</dt>
     <dd>
      The set of puts is complete.
        Called with pvTop locked.
     </dd>
</dl>
<h4>MonitorPluginCreator</h4>
<p><b>MonitorPluginCreator</b> must also be implemented by the plugin implementation.
It is called for each field instance that has options of the from
<b>[plugin=name...]</b> where <b>name</b> is the name of the plugin.
Note that a plugin instance will belong to a single client.
It has methods:</p>
<dl>
   <dt>getName</dt>
     <dd>Get the name of the plugin.</dd>
   <dt>create</dt>
     <dd>
     Create a new plugin instance.
     If the arguments are not compatible with the plugin a NULL shared pointer is
     returned.<br/>
    pvFieldOptions is
      a structure with a set of PVString subfields that specify <b>name,value</b>
      pairs. name is the subField name and value is the subField value.<br/>
     Note that a plugin will below to a single client.
    </dd>
<dl>
<h4>MonitorPluginManager</h4>
<p><b>MonitorPluginManager</b> has the methods:</p>
<dl>
   <dt>get</dt>
     <dd>
     MonitorPluginManager is a singleton.
     The first call to get will create the single instance.
     Further calls will rerurn the single instance.
     </dd>
   <dt>addPlugin</dt>
     <dd>
     Add a new plugin.
     </dd>
   <dt>findPlugin</dt>
     <dd>
      Find a plugin. A NULL shared pointer is reurned if it has not been added.
     </dd>
   <dt>showNames</dt>
     <dd>
      Show the names of all puugins that have been added.
     </dd>
</dl>
<p><b>NOTE:</b>
Should the method <b>causeMonitor</b> 
have arguments <b>pvField</b> and <b>pvTop</b>
be defined so that they can not be modfied.
This would be posssible if the following was defined:
<pre>
typedef std::tr1::shared_ptr&lt;const PVField&gt; PVFieldConstPtr;
typedef std::tr1::shared_ptr&lt;const PVStructure&gt; PVStructureConstPtr;
</pre>
then the definition for causeMonitor could be:
<pre>
virtual bool causeMonitor(
        PVFieldConstPtr const &amp;pvField,
        PVStructureConstPtr const &amp;pvTop,
        MonitorElementPtr const &amp;monitorElement) = 0;
</pre>
But just adding these definitions is not sufficent.
In addition all methods defined in pvDataCPP must be checked.
In particular many of the methods in <b>Convert</b> must have
their arguments modified.
Big job.
</p>
<h2>monitorPlugin example</h2>
<h3>Example Plugin Overview</h3>
<p>This section describes an example plugin that:</p>
<ul>
   <li>Only raises monitors when a field changes value.<br />
     If no plugin is provided
     the default is to raise a monitor when a put is issued to a field.</li>
   <li>Optionally a change will not raise a monitor.<br />
     The change will, however,
     appear if a put to another field raise a monitor.</li>
</ul>
<p>As an example assume that a channel provided by pvAccess has a top level structure
that represents a power supply.</p>
<pre>
structure powerSupply
    structure alarm
    structure timeStamp
    structure power
       double value
       structure alarm
       struvture display
    structure voltage
       double value
       structure alarm
       struvture display
    structure current
       double value
       structure alarm
       struvture display
</pre>
<p>A pvAccess client wants to create a monitor on the powerSupply as follows:
The client wants a top level structure that looks like:
<pre>
structure powerSupply
    structure alarm
    structure timeStamp
    structure power
       double value
    structure voltage
       double value
    structure current
       double value
</pre>
In addition the client wants monitors to occur only when one of the monitored
fields changes value but not just because a put occured.
Also if only the timeStamp changes value then that should not cause a monitor.
</p>
<p>The example monitor plugin implements the semantics the
client wants. It can be attached to any field via the following options:
<pre>
[plugin=onChange,raiseMonitor=value]
</pre>
This plugin will trigger a monitor for the field only if the field changes
value. In addition <b>value</b> equals <b>false</b> means do not raise a monotor
for changes to this field.
But if a change to another field does cause a monitor the change to this field
will be passed to the client.
</p>
<p>
Assume that the client has already connected to the channel.
The client can then issue the commands:</p>
<pre>
String request("field(alarm[plugin=onChange]");
request += ",timeStamp[plugin=onChange,raiseMonitor=false]";
request += ",power.value[plugin=onChange";
request += ",voltage.value[plugin=onChange";
request += ",current.value[plugin=onChange";

PVStructurePtr pvRequest = createRequest-&gt;createRequest(request);

MonitorPtr monitor = channel-&gt;createMonitor(monitorRequester,pvRequest);
</pre>
<h3>Example Plugin Code</h3>
<p>The header file to create the example has the definition:</p>
<pre>
class ExampleMonitorPlugin{
public:
    static void create();
};
</pre>
<p>The implementation is:</p>
<pre>
class OnChangePlugin : public MonitorPlugin
{
public:
    virtual ~OnChangePlugin(){}
    OnChangePlugin() {}
    bool init(
        FieldConstPtr const &amp;field,
        StructureConstPtr const &amp;top,
        PVStructurePtr const &amp;pvFieldOptions)
   {
        pvField = getPVDataCreate()-&gt;createPVField(field);
        raiseMonitor = true;
        if(pvFieldOptions!=NULL) {
            PVStringPtr pvString =
                pvFieldOptions-&gt;getSubField&lt;PVString&gt;("raiseMonitor");
                if(pvString!=NULL) {
                    String value = pvString-&gt;get();
                    if(value.compare("false")==0) raiseMonitor = false;
                }
        }
        return true;
   }
   virtual String &amp;getName(){return pluginName;}
   virtual bool causeMonitor(
        PVFieldPtr const &amp;pvNew,
        PVStructurePtr const &amp;pvTop,
        MonitorElementPtr const &amp;monitorElement)
   {
       bool isSame = convert-&gt;equals(pvNew,pvField);
       if(isSame) return false;
       convert-&gt;copy(pvNew,pvField);
       return raiseMonitor;
   }
private:
   PVFieldPtr pvField;
   bool raiseMonitor;
};
class OnChangePluginCreator : public MonitorPluginCreator
{
public:
    virtual String &amp;getName(){return pluginName;}
    virtual MonitorPluginPtr create(
        FieldConstPtr const &amp;field,
        StructureConstPtr const &amp;top,
        PVStructurePtr const &amp;pvFieldOptions)
   {
       OnChangePluginPtr plugin(new OnChangePlugin());
       bool result = plugin-&gt;init(field,top,pvFieldOptions);
       if(!result) return MonitorPluginPtr();
       return plugin;
   }

};

void ExampleMonitorPlugin::create()
{
    static OnChangePluginCreatorPtr plugin;
    static Mutex mutex;
    Lock xx(mutex);
    if(plugin==NULL) {
        plugin = OnChangePluginCreatorPtr(new OnChangePluginCreator());
        MonitorPluginManager::get()-&gt;addPlugin(pluginName,plugin);
    }
}
</pre>


</div>
</body>
</html>
