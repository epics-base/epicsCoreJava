<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
      "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="content-type" content="text/html; charset=iso-8859-1" />
  <title>EPICS pvDataJava</title>
    <link rel="stylesheet" type="text/css" href="http://epics-pvdata.sourceforge.net/base.css" />
  <link rel="stylesheet" type="text/css" href="http://epics-pvdata.sourceforge.net/epicsv4.css" />

  <style type="text/css">
  /*<![CDATA[*/
     .about { margin-left: 3em; margin-right: 3em; font-size: .83em}
     table { margin-left: auto; margin-right: auto }
     .diagram { text-align: center; margin: 2.5em 0 }
     span.opt { color: grey }
     span.nterm { font-style:italic }
     span.term { font-family:courier }
     span.user { font-family:courier }
     span.user:before { content:"<" }
     span.user:after { content:">" }
     .nonnorm { font-style:italic }
     p.ed { color: #AA0000 }
     span.ed { color: #AA0000 }
     p.ed.priv { display: inline; }
     span.ed.priv { display: inline; }
  /*]]>*/</style>
  <!-- Script that generates the Table of Contents -->
  <script type="text/javascript" src="http://epics-pvdata.sourceforge.net/script/tocgen.js"></script>

</head>
<body>


<div class="head">
<h1>EPICS pvDataJava</h1>
<!-- Maturity: Working Draft or Request for Comments, or Recommendation, and date.  -->

<h2 class="nocount">EPICS v4 Working Group, Working Draft,
08-Aug-2012</h2>
<dl>
  <dt>This version:</dt>
    <dd><a
      href="http://epics-pvdata.sourceforge.net/pvDataJava_20111220.html">pvDataJava_20111220.html</a></dd>
  <dt>Latest version:</dt>
    <dd><a
      href="http://epics-pvdata.sourceforge.net/pvDataJava_20111220.html">pvDataJava_20111220.html</a></dd>
  <dt>Editors:</dt>
    <dd>Marty Kraimer, BNL</dd>
</dl>
</div>

<h2 class="nocount">Abstract</h2>

<p>pvDataJava is the Java implementation of pvData, which is one of a related
set of products:</p>
<dl>
  <dt><a
  href="http://epics-pvdata.hg.sourceforge.net/hgweb/epics-pvdata/pvDataJava/raw-file/tip/documentation/pvDataJava.html">pvData</a></dt>
    <dd>pvData (Process Variable Data) defines and implements an efficent way
      to store, access, and transmit memory resident structured data</dd>
  <dt><a
  href="http://epics-pvdata.hg.sourceforge.net/hgweb/epics-pvdata/pvAccessJava/raw-file/tip/documentation/pvAccessJava.html">pvAccess</a></dt>
    <dd>pvAccess is network support for transmitting pvData.</dd>
  <dt><a
  href="http://epics-pvdata.hg.sourceforge.net/hgweb/epics-pvdata/pvIOCJava/raw-file/tip/documentation/pvIOCJava.html">pvIOC</a></dt>
    <dd>A pvIOC is a network accessable smart real time database. The database
      consists of memory resident records. Each record has a name that is
      unique within the local area network and contains a top level pvData
      structure. Each field of a record can optionally have support code
      attached to it. The support is called when a request is made to process
      the record. The support code is what makes the record "smart". A pvAccess
      server is provided so that the records can be accesed via the network.
    </dd>
  <dt><a
  href="http://epics-pvdata.hg.sourceforge.net/hgweb/epics-pvdata/pvServiceJava/raw-file/tip/documentation/pvAccessJava.html">pvService</a></dt>
    <dd>A middle layer for implementing services.</dd>
</dl>

<p>Each of the products has a Java and a C++ implementation.</p>

<p>The products are all part of the <a
href="http://epics-pvdata.sourceforge.net/">V4</a> implementation of <a
href="http://www.aps.anl.gov/epics/">Experimental Physics and Industrial
Control System.</a></p>

<h2 class="nocount">Status of this Document</h2>

<p>This is the 08-Aug-2012 version of the Java implementation of pvData. It is
a complete implementation of pvData as currently defined. </p>

<h2 class="nocount">TODO</h2>
<p>The following is a list of unresolved issues for pvDataJava:</p>
<dl>
   <dt>org.epics.pvdata.util</dt>
     <dd>This has code created by Greg White.
       If being used this document should talk about it.
      If not being used it should be deleted.</dd>
</dl>

<div id="toc">
<h2 class="nocount" style="page-break-before: always">Table of Contents</h2>
</div>
<div id="contents" class="contents">

<h2 >Introduction</h2>

<p>This product is available via an <a
href="http://epics-pvdata.sourceforge.net/LICENSE.html">open source
license</a></p>

<p>pvData is one of a set of related projects. It describes and implements the
data that the other projects support. Thus it is not useful by itself but
understanding pvData is required in order to understand the other projects. The
reader should also become familar with projects pvAccess and javaIOC, which are
located via the same sourceforge site as this project.</p>

<p>pvData (Process Variable Data) defines and implements an efficent way to
store, access, and transmit memory resident structured data.</p>
<dl>
  <dt>definition</dt>
    <dd>Package org.epics.pvdata.pv has Java interface definitions that define
      pvData. Although defined with Java syntax they also document what is
      required for implementation in other languages such as C++.</dd>
  <dt>implementation</dt>
    <dd>The set of packages provided by this project provide a complete Java
      implementation of pvData. Project pvAccess is the network support for
      pvData, i.e. it provides a channel access client and server that fully
      support pvData. Project pvIOCJava provides an IOC (Input Output Controller)
      that supports pvData and provides record processing..</dd>
  <dt>efficient</dt>
    <dd>Small memory footprint, low cpu overhead, and concise code base.</dd>
  <dt>data storage</dt>
    <dd>pvData defines separate introspection and data interfaces. The
      introspection interfaces provide access to immutable objects, which
      allows introspection instances to be freely shared. The introspection
      interface for a process variable can be accessed without requiring access
      to the data.</dd>
  <dt>data access</dt>
    <dd>Client code can access pvData via the introspection and data
      interfaces. For "well known" data, e.g. image data, specialized interfaces
      can be provided without requiring any changes to the core software.</dd>
  <dt>data transfer</dt>
    <dd>The separation of introspection and data interfaces allows for
      efficient network data transfer. At connection time introspection
      information can be passed from server to client. Each side can create a
      data instance. The data is transferred between these instances. The data
      in the network buffers does not have to be self describing since each
      side has the introspection information.</dd>
  <dt>memory resident</dt>
    <dd>pvData only defines memory resident data.</dd>
  <dt>structured data</dt>
    <dd>pvData has four types: scalar, scalarArray, structure, and structureArray.
      A scalar has one of the following scalarTypes : pvBoolean, pvByte, pvShort, pvInt, pvLong,
      pvUByte, pvUShort, pvUInt, pvULong, pvFloat, pvDouble, and
      pvString. A scalarArray is a one dimensional array with the element type being any of the scalarTypes.
      A structure is an ordered set of fields where each field has a
      name and type.
      are supported.A structureArray is an array of structures where each element has the same intrspection interface.
      Since a field can have type structure complex structures can be created
      that simulate types.</dd>
</dl>

<p>The pvIOCJava implements a Process Variable (PV) Database, which is a memory
resident database holding pvData, has the following features:</p>
<ul>
  <li>A database has records.</li>
  <li>Each record has a unique record name.</li>
  <li>A record has a top level PVStructure, which is a structured set of data
    as defined by this project.</li>
</ul>

<p>pvData was initially created to support the javaIOC and was part of the
javaIOC project.
The original javaIOC project has been broken up into many projects, e. g. pvDataJava, pvAccessJava,
pvIOCJava, pvServiceJava. In addition there are C++ implementation of each of these projects.
pvData is intended for use by 1) channel access
clients, 2) Interface between client and network, 3) Interface between network
and channel access server, 4) Interface between server and IOC database. Since
it is an interface to data, it could also be used by other systems, e.g. TANGO,
TINE, etc. A high level Physics application can hold data as pvData. By
starting a channel access server, the data can made available to network
clients.</p>

<p>pvData contains everything required to support Channel Access and Channel
Access clients and servers. </p>

<h2 >PVData Meta Language</h2>

<p>This section describes a meta language for describing pvData.
Currently there are no plans for a parser for the meta language.
It is used for documentation. 
The meta language is used to describe both introspection interfaces and data interfaces.</p>
<p>The toString introspection and data methods described below 
present data in a format similar to the metadata syntax.</p>

<h3>Definition</h3>

<p>PVData supports structured data. All data appears via top level structures.
A structure has an ordered set of fields where each field has a <span
style="font-family: courier;">fieldDef</span> defined as follows:</p>
<pre>type fieldName value // comment</pre>

<p>where <span>value</span> is present for data
objects and <span>//</span> indicates the the
rest of the line is a comment. </p>

<p>type is one of the following:</p>
<dl>
  <dt>scalar</dt>
   <dd>A scalar field can be any of the following: 
      <dl>
        <dt>boolean</dt>
          <dd>Has the value<span>true</span> or
            <span>false</span></dd>
        <dt>byte</dt>
          <dd>An 8 bit signed integer.</dd>
        <dt>short</dt>
          <dd>An 16 bit signed integer.</dd>
        <dt>int</dt>
          <dd>An 32 bit signed integer.</dd>
        <dt>long</dt>
          <dd>An 64 bit signed integer.</dd>
        <dt>ubyte</dt>
          <dd>An 8 bit unsigned integer.</dd>
        <dt>ushort</dt>
          <dd>An 16 bit unsigned integer.</dd>
        <dt>uint</dt>
          <dd>An 32 bit unsigned integer.</dd>
        <dt>ulong</dt>
          <dd>An 64 bit unsigned integer.</dd>
        <dt>float</dt>
          <dd>A IEEE float.</dd>
        <dt>double</dt>
          <dd>A IEEE double.</dd>
        <dt>string</dt>
          <dd>An immutable string.</dd>
      </dl>
    </dd>
  <dt>scalarArray</dt>
    <dd>A scalarArray field is an array of any of the scalar types. 
      <dl>
        <dt>boolean[]</dt>
        <dt>byte[]</dt>
        <dt>short[]</dt>
        <dt>int[]</dt>
        <dt>long[]</dt>
        <dt>ubyte[]</dt>
        <dt>ushort[]</dt>
        <dt>uint[]</dt>
        <dt>ulong[]</dt>
        <dt>float[]</dt>
        <dt>double[]</dt>
        <dt>string[]</dt>
      </dl>
    </dd>
  <dt>structure</dt>
    <dd>A structure field has the definition: 
      <pre>     structure fieldName
         fieldDef
         ...
      </pre>
      or 
      <pre>     xxx_t fieldName
         // if data object then following appear
         fieldDef
         ...
      </pre>
      For <span>structure fieldName</span> each
      <span>fieldDef</span> must have a unique
      <span>fieldName</span> within the <span
     >structure</span> For <span
     >"xxx_t fieldName"</span> xxx_t must be a
      previously structure definition of the form: 
      <pre>    structure xxx_t
        ...</pre>
    </dd>
  <dt>structureArray</dt>
    <dd>A structureArray field has the definition: 
      <pre>     structure[] fieldName
          structureDef
          ...
          </pre>
      <p>or</p>
      <pre>    xxx_t[] fieldName</pre>
      <pre>      </pre>
      <p>Thus a structure array is an array where each element is a structure
      but all elements have the same introspection interface. For introspection
      the structureDef appears once without any data valuies.</p>
    </dd>
</dl>

<p>The above is used to describe introspection objects. Data objects are
describe in a similar way but each scalar field and each array field has data
values. The definition of the data values depends on the type. For scalars the
data value is whatever is valid for the type. </p>
<dl>
  <dt>boolean</dt>
    <dd>The value must be <span>true</span> or
      <span>false</span> </dd>
  <dt>byte,...ulong</dt>
    <dd>Any valid integer or hex value, e.g. <span
     >3 and 0x0ff</span> are valid values</dd>
  <dt>float,double</dt>
    <dd>Any valid integer or real e.g. <span>3,
      3.0, and 3e0</span> are valid values</dd>
  <dt>string</dt>
    <dd>The value can be an alphanumeric value or any set of characters
      enclosed in <span>""</span> Within quotes a
      quote is expressed as <span>\"</span>
      Examples are <span>aValue "a value" "a\"
      xxx"</span> are valid values. </dd>
</dl>

<p>For scalar arrays the syntax is:</p>
<pre>      = [value,...,value]</pre>

<p>where each <span>value</span> is a valid
scalar data value depending on the type. Thus it is a comma separated set of
values enclosed in <span>[]</span> White space is
permitted surrounding each comma.</p>

<h3>Examples</h3>

<p>Define the following top level structure:</p>
<pre>structure timeStamp_t
    long secondsPastEpoch
    int nanoSeconds </pre>

<p>Then the following introspection objects can be defined:</p>
<pre>structure scalarDoubleExample // introspection object
    double value
    timeStamp_t timeStamp</pre>
or 
<pre>structure scalarDoubleExample // introspection object
    double value
    structure timeStamp
        long secondsPastEpoch
        int  nanoSeconds</pre>

<p>The following data objects can be defined:</p>
<pre>structure scalarDoubleExample // data object
    double value 1.0
    timeStamp_t timeStamp
         long secondsPastEpoch 0
         int  nanoSeconds 0</pre>
or 
<pre>scalar arrayDoubleExample
    double[] value  [1.0,2.0]
    structure timeStamp
         long secondsPastEpoch 0
         int  nanoSeconds 0</pre>

<p>If the following interface is defined:</p>
<pre>structure point_t
    double x
    double y</pre>

<p>Then the following introspection objects can be defined: </p>
<pre>structure lineExample
    point_t begin
    point_t end

structure pointArrayExample
    point_t[] points
    </pre>
or 
<pre>structure lineExample
    structure begin
        double x
        double y
    structure end
        double x
        double y

structure pointArrayExample
    structure[] points
        structure point
            double x
            double y</pre>

<p>And the following data objects can be defined:</p>
<pre>structure lineExample
    point_t begin
        double x 0.0
        double y 0.0
    point_t end
        double x 10
        double y 10

structure pointArrayExample
    point_t[] value
        structure point
            double x 0.0
            double y 0.0
        structure point
            double x 10.0
            double y 10.0</pre>

<p>or</p>
<pre>structure lineExample
    structure begin
        double x 0
        double y 0
    structure end
        double x 10
        double y 10

structure pointArrayExample
    structure[] value
        structure point
            double x 0.0
            double y 0.0
        structure point
            double x 10.0
            double y 10.0</pre>

<h2 >Interface Definitions</h2>
<p>This section gives a <b>brief</b> description of the pvData intospection and data interfaces.
In this section the methods are shown but not described. See org.epics.pvdata.pv below for a
description of each method.</p>

<h3>Types</h3>

<p>The following are the type definitions:</p>
<pre>enum Type {
    scalar,
    scalarArray,
    structure,
    structureArray;
}</pre>

<p>where</p>
<dl>
  <dt>scalar</dt>
    <dd>A field that has data with one of the scalarTypes.</dd>
  <dt>scalarArray</dt>
    <dd>A field that is an array where each element is the same scalarType.</dd>
  <dt>structure</dt>
    <dd>A field which has named subfields.</dd>
  <dt>structureArray</dt>
    <dd>A field that is an array of structures where each element has the same
      introspection interface, i.e. each element has the same structure.</dd>
</dl>
<pre>enum ScalarType {
    pvBoolean,
    pvByte,pvShort,pvInt,pvLong,
    pvUByte,pvUShort,pvUInt,pvULong,
    pvFloat,pvDouble,
    pvString;
    // The following are convenience methods
    public boolean isInteger();
    public boolean isUInteger();
    public boolean isNumeric();
    public boolean isPrimitive();
    public static ScalarType getScalarType(String type);
    public String toString();
}</pre>

<p>where</p>
<dl>
  <dt>boolean</dt>
    <dd>true or false</dd>
  <dt>byte</dt>
    <dd>An 8 bit signed byte</dd>
  <dt>short</dt>
    <dd>16 bit signed integer</dd>
  <dt>int</dt>
    <dd>32 bit signed integer</dd>
  <dt>long</dt>
    <dd>64 bit signed integer</dd>
  <dt>ubyte</dt>
    <dd>An 8 bit unsigned byte</dd>
  <dt>ushort</dt>
    <dd>16 bit unsigned integer</dd>
  <dt>uint</dt>
    <dd>32 bit unsigned integer</dd>
  <dt>ulong</dt>
    <dd>64 bit unsigned integer</dd>
  <dt>float</dt>
    <dd>32 bit IEEE float</dd>
  <dt>double</dt>
    <dd>64 bit IEEE float</dd>
  <dt>string</dt>
    <dd>An immutable string. The Java implementation is String. For other
      implementations the network representation must be the same as for Java.
      Note that a string is treated like it is a scaler.</dd>
</dl>
<p><b>NOTE:</b> Java does not support unsigned integers so the Java implementation
of each unsigned type is implemented as the corresponding signed type.
The only exception is the Convert facility. When it performs a widening
operation, e.g. from ubyte to short, it performs the correct conversion.</p>

<h3>Introspection Interfaces</h3>

<p>Field is the base introspection interface. It has only an id and a type.</p>
<pre>interface Field extends Serializable {
    String getId();
    Type getType();
    void toString(StringBuilder buf);
    void toString(StringBuilder buf,int indentLevel);
    String toString();
}

interface Scalar extends Field {
    ScalarType getScalarType();
}

interface ScalarArray extends Field {
    ScalarType getElementType();
}

interface Structure extends Field {
    Field getField(String fieldName);
    int getFieldIndex(String fieldName);
    Field[] getFields();
    Field getField(int fieldIndex);
    String[] getFieldNames();
    String getFieldName(int fieldIndex)
}

interface StructureArray extends Field {
    Structure getStructure();
}</pre>

<p>The introspection interfaces provide access to immutable objects. This
allows introspection interfaces to be freely shared between data objects. For
example the introspection interface for a timeStamp, which is a structure
containing two fields, can be shared by every record that has a time stamp.</p>

<h3>Data Interfaces</h3>

<p>PVField is the base interface for a data field:</p>
<pre>interface PVField extends Requester, Serializable {
    String getFieldName();
    void setRequester(Requester requester);
    int getFieldOffset();
    int getNextFieldOffset();
    int getNumberFields();
    PVAuxInfo getPVAuxInfo();
    boolean isImmutable();
    void setImmutable();
    Field getField();
    PVStructure getParent();
    void renameField(String newName);
    void postPut(); // calls PVRecordField.postPut if this is a field of a record
    void setPostHandler(PostHandler postHandler);
    void toString(StringBuilder buf);
    void toString(StringBuilder buf,int indentLevel);
    String toString();
}</pre>

<p>Each scalar type has an associated data interface: PVBoolean,
PVByte, PVShort, PVInt, PVLong,
PVUByte, PVUShort, PVUInt, PVULong,
PVFloat, PVDouble, and PVString. Each has a get and a
put method. For example:</p>
<pre>interface PVDouble extends PVScalar{
    double get();
    void put(double value);
}</pre>

<p>PVArray is the base class for arrays.</p>
<pre>interface PVArray extends PVField, SerializableArray {
    int getLength();
    void setLength(int length);
    int getCapacity();
    void setCapacity(int length);
    boolean isCapacityMutable();
    void setCapacityMutable(boolean isMutable);
}
</pre>

<p>PVScalarArray is the base class for scalar arrays.</p>
<pre>interface PVScalarArray extends PVArray {
    ScalarArray getScalarArray();
}</pre>

<p>For each scalar type an associated array data interface is defined. Each has
a get and put method. For example: </p>
<pre>public class DoubleArrayData {
    public double[] data;
    public int offset;
}

interface PVDoubleArray extends PVArray {
    int get(int offset, int len, DoubleArrayData data);
    int put(int offset,int len, double[] from, int fromOffset);
    void shareData(double[] from);
}</pre>

<p>PVStructureArray is the interface for an array of structures where each element
has the same iontrospection interface.</p>
<pre>public class StructureArrayData {
    public PVStructure[] data;
    public int offset;
}

interface PVStructureArray extends PVArray{
    StructureArray getStructureArray();
    int get(int offset, int length, StructureArrayData data);
    int put(int offset,int length, PVStructure[] from, int fromOffset);
    void shareData(PVStructure[] from);
}</pre>

<p>PVStructure is the data interface for a structure.</p>
<pre>
interface PVStructure extends PVField , BitSetSerializable{
    Structure getStructure();
    PVField[] getPVFields();
    PVField getSubField(String fieldName);
    PVField getSubField(int fieldOffset);
    void appendPVField(String fieldName,PVField pvField);
    void appendPVFields(String[] fieldNames,PVField[] pvFields);
    void removePVField(String fieldName);
    void replacePVField(PVField oldPVField,PVField newPVField);
    // The following are convenience methods
    PVBoolean getBooleanField(String fieldName);
    PVByte getByteField(String fieldName);
    PVShort getShortField(String fieldName);
    PVInt getIntField(String fieldName);
    PVLong getLongField(String fieldName);
    PVFloat getFloatField(String fieldName);
    PVDouble getDoubleField(String fieldName);
    PVString getStringField(String fieldName);
    PVScalarArray getScalarArrayField(String fieldName);
    PVStructureArray getStructureArrayField(String fieldName);
    PVStructure getStructureField(String fieldName);
    PVArray getArrayField(String fieldName,ScalarType elementType);
    String getExtendsStructureName();
    boolean putExtendsStructureName(String extendsStructureName);
    public boolean checkValid();
}</pre>

<h3>Introspection and Data creation</h3>

<p>The following interface creates introspection instances:</p>
<pre>public interface FieldCreate {
    Scalar createScalar(ScalarType scalarType);
    ScalarArray createScalarArray(ScalarType elementType);
    StructureArray createStructureArray(Structure elementStructure);
    Structure createStructure(String[] fieldNames, Field[] field);
    Structure createStructure(String id,String[] fieldNames, Field[] field);
    Structure appendField(Structure structure,String fieldName, Field field);
    Structure appendFields(Structure structure,String[] fieldNames, Field[] fields);
    Structure createStructure(Structure structToClone);
    Field deserialize(ByteBuffer buffer, DeserializableControl control);
}</pre>

<p>The following interface creates data instances:</p>
<pre>public interface PVDataCreate {
    PVField createPVField(Field field);
    PVField createPVField(PVField fieldToClone);
    PVScalar createPVScalar(Scalar scalar);
    PVScalar createPVScalar(ScalarType fieldType);
    PVScalar createPVScalar(PVScalar scalarToClone);
    PVScalarArray createPVScalarArray(ScalarArray array);
    PVScalarArray createPVScalarArray(ScalarType elementType);
    PVScalarArray createPVScalarArray(PVScalarArray arrayToClone;
    PVStructureArray createPVStructureArray(StructureArray structureArray);
    PVStructure createPVStructure(Structure structure);
    PVStructure createPVStructure(String[] fieldNames,Field[] fields);
    PVStructure createPVStructure(PVStructure structToClone);
    PVField[] flattenPVStructure(PVStructure pvStructure);
}</pre>

<h3>pvData Conversion</h3>

<p>An interface named Convert provides all reasonable conversions to/from
pvData.
The convert utility is also used to implement the toString methods of PVField.
See org.epics.pvdata.pv.Convert for details.</p>

<h2 >Package Summary</h2>

<p>This document describes everything via Java definitions. The initial
implementation is in Java but the functionality is also implemented in C++ (See pvDataCPP for details).</p>

<p>pvData is distributed as a sourceforge mercurial project named pvDataJava.
It consists of the following java packages:</p>

<h3>org.epics.pvdata.pv</h3>

<p>The Java enum, interface, and class definitions that define pvData. This
section provides a complete definition of what pvData is.</p>

<h3>org.epics.pvdata.factory</h3>

<p>Provides everything required for creating pvData. It provides the following
factories:</p>
<dl>
  <dt>FieldFactory</dt>
    <dd>Creates introspection interfaces.</dd>
  <dt>PVDataFactory</dt>
    <dd>Creates data interfaces for all of the supported data types.</dd>
  <dt>ConvertFactory</dt>
    <dd>Converts between support data types.</dd>
  <dt>StatusFactory</dt>
     <dd>Status is a class for communication status between code modules.</dd>
  <dt>StandardFieldFactory</dt>
     <dd>Creates introspection objects for "well known" data.</dd>
  <dt>StandardPVFieldFactory</dt>
     <dd>Creates data objects for "well known" data.</dd>
</dl>

<p>Although pvDataFactory can provide the implementation for all supported data
types, often it is desirable to provide other implementations. To make it easy
to create alternate implementations a set of abstract and base classes are
supplied.</p>

<h3>org.epics.pvdata.property</h3>

<p>Provides a way to associated properties with a field. </p>

<p>The basic idea is to associate properties with any field named "value". All
the fields in the structure that contains the value field are considered
properties of value with the field name being the property name. See that
package overview for details.</p>

<p>This package also provides support for "well known" field definitions like
timeStamp, alarm, display,etc. Code that uses pvData can be simplified by using
this support.</p>

<h3>org.epics.pvdata.misc</h3>

<p>This package provides support that is used by pvData factories and might
also be useful to software that uses pvData.</p>

<h3>org.epics.pvdata.monitor</h3>

<p>Provides the ability to monitor changes to an arbitrary subset of the fields
in a record.</p>

<h2 >Package org.epics.pvdata.pv</h2>

<h3>Overview</h3>

<p>This package has the complete set of enum, interface, and class definitions
that describe PVData. The implementation is provided in package
org.epics.pvdata.factory.</p>

<p>A PVStructure is a field that contains an array of subfields. Each field has
code for accessing the field. The interface for each field is PVField or an
interface that extends PVField. Each field also has an introspection interface,
which is Field or an extension of Field. This package overview describes the
complete set of data and introspection interfaces for pvData.</p>

<p>This package also describes an interface Convert, which provides a rich set
of methods for converting and copying data between field.</p>

<p>The interface FieldCreate creates the introspection interfaces. The
interface PVDataCreate creates the PVField interfaces. Between them they
provide the ability to create every type of Field and PVField, i.e. they
provide a complete implemenation of pvData. It is also possible for other code
to provide implementations.</p>

<p>The interface StandardField provides introspection objects for standard fields.
The interface StandardPVField provides data objects for standard fields.</p>
<p>The interface StatusCreate and class Status provide status object to pass between source
modules.</p>

<h3>Process Variable Reflection</h3>

<p>Given the introspection object it is
possible to introspect a field without requiring access to data. The
reflection and data interfaces are separate because the data may not be
available. For example when a PVAccess client connects to a PV, the client
library can obtain the reflection information without obtaining any data. Only
when a client issues an I/O request will data be available. This separation is
especially important for arrays and structures so that a client can discover
the type without requiring that a large array or structure be transported over
the network.</p>

<h4>Type</h4>

<p>The types are defined by the Java definitions:</p>
<pre>
enum Type {
    scalar,
    scalarArray,
    structure,
    structureArray;
}

enum ScalarType {
    pvBoolean,
    pvByte, pvShort, pvInt, pvLong,
    pvUByte, pvUShort, pvUInt, pvULong,
    pvFloat,pvDouble,
    pvString;

    //Convenience methods
    public boolean isInteger();   // pvByte,...,pvULong
    public boolean isUInteger();   // pvUByte,...,pvULong
    public boolean isNumeric();    // pvByte,...pvDouble
    public boolean isPrimitive();  // pvBoolean,...pvDouble
    public static ScalarType getScalarType(String type);
    public String toString();
}</pre>

<h4>Serializable</h4>

<p>The following interfaces are called by pvAccess for transporting data over
the network. The abstract and base classes ensure that these methods are
properly implemented. </p>
<pre>
interface Serializable {
    void serialize(ByteBuffer buffer,SerializableControl flusher);
    void deserialize(ByteBuffer buffer,DeserializableControl control);
}
</pre>
where
<dl>
  <dt>serialize</dt>
    <dd>Serialize into buffer. flusher is called when buffer is full.</dd>
  <dt>deserialize</dt>
    <dd>deserialize from byte buffer. control is called when more data is required.</dd>
</dl>
<pre>
interface SerializableControl {
    void flushSerializeBuffer();
    void ensureBuffer(int size);
    void alignBuffer(int alignment);
    void cachedSerialize(Field field, ByteBuffer buffer)
}
</pre>
where
<dl>
   <dt>flushSerializeBuffer</dt>
      <dd>Code that called serialize must empty the buffer.
       The call can block until the buffer is flushed.</dd>
   <dt>ensureBuffer</dt>
      <dd>Helper method. Ensures specified size of bytes, flushes if necessary.</dd>
   <dt>alignBuffer</dt>
      <dd>Align buffer.Note that this takes care only current buffer alignment. If streaming protocol is used,
        care must be taken that entire stream is aligned.</dd>
   <dt>cachedSerialize</dt>
      <dd>Serialize Field instance via cache.</dd> 
</dl>
<pre>
interface DeserializableControl {
    void ensureData(int size);
    void alignData(int alignment);
    Field cachedDeserialize(ByteBuffer buffer)
}
</pre>
where
<dl>
   <dt>ensureData</dt>
     <dd>Helper method. Ensures specified size of bytes, provides it if necessary.</dd>`
   <dt>alignData</dt>
      <dd>Align buffer.Note that this takes care only current buffer alignment. If streaming protocol is used,
        care must be taken that entire stream is aligned.</dd>
   <dt>cachedDeserialize</dt>
      <dd>Deserialize Field instance via cache.</dd> 
</dl>
<pre>
interface SerializableArray extends Serializable {
    void serialize(ByteBuffer buffer, SerializableControl flusher, int offset, int count);
}       
</pre>
where
<dl>
   <dt>serialize</dt>
     <dd>Serialize field into given buffer.</dd>
</dl>
<pre>
interface BitSetSerializable {
   void serialize(ByteBuffer buffer, SerializableControl flusher, BitSet bitSet);
   void deserialize(ByteBuffer buffer, DeserializableControl control, BitSet bitSet);
}
</pre>
where
<dl>
   <dt>serialize</dt>
     <dd>Serialize field into given buffer. The BitSet shows the fields to serialize.</dd>
   <dt>deserialize</dt>
     <dd>Deserialize field into given buffer. The BitSet shows the fields to serialize.</dd>
</dl>

<h4>Reflection</h4>

<p>This section defines the complete set of Java PV reflection interfaces.
Reflection consists of the following:</p>
<dl>
  <dt>Field</dt>
    <dd>A field has an ID and a type. It can be converted to a string. 
        The format is the metadata format
        described in the overview.</dd>
  <dt>Scalar</dt>
    <dd>A scalar has a scalarType</dd>
  <dt>ScalarArray</dt>
    <dd>The element type is a scalarType</dd>
  <dt>StructureArray</dt>
    <dd>The field holds PVStructure[]. Each element has the same Structure
      interspection interface. A client can only get/put entire PVStructure
      elements NOT subfields of array elements.</dd>
  <dt>Structure</dt>
    <dd>Has fields that can be any of the supported types.
      In addition it has a name for each field.</dd>
  <dt>FieldCreate</dt>
    <dd>This is an interface that provides methods to create introspection
      interfaces. A factory is provides to create FieldCreate.</dd>
</dl>
<h5>Field</h5>
<pre>    
interface Field extends Serializable {
    String getID();
    Type getType();
    void toString(StringBuilder buf));
    void toString(StringBuilder buf,int indentLevel);
    String toString();
} 
</pre>
where
<dl>
   <dt>getID</dt>
     <dd>Get the identification string.
      It can be empty.
      For scalar fields the ID is the metadata type, i.e. boolean, byte, etc.
      For scalarArray fields the ID is the metadata type, i.e. boolean[],
      byte[], etc.
      For structure fields the ID is determined by the argument specified
      when fieldCreate.createStructure is called.
      For structureArray fields the ID is XX[] where XX is the ID of the element structure.
     </dd>
   <dt>getType</dt>
     <dd>Get the field type.</dd>
   <dt>toString</dt>
     <dd>Create a String that shows the type.
      The format is the metadata syntax defined in the overview.</dd>
</dl>
<h5>Scalar</h5>
<pre>
interface Scalar extends Field {
    ScalarType getScalarType();
}
</pre>
where
<dl>
   <dt>getScalarType</dt>
     <dd>Return the ScalarType.</dd>
</dl>
<h5>ScalarArray</h5>
<pre>
interface ScalarArray extends Field{
    ScalarType getElementType();
}
</pre>
where
<dl>
   <dt>getElementType</dt>
     <dd>Return the ScalarType for each array element.</dd>
</dl>
<h5>Structure</h5>
<pre>
interface Structure extends Field{
    Field getField(String fieldName);
    int getFieldIndex(String fieldName);
    Field[] getFields();
    Field getField(int fieldIndex);
    String[] getFieldNames();
    String getFieldName(int fieldIndex);
}
</pre>
where
<dl>
   <dt>getField</dt>
     <dd>Return a field of the structure.
     The field can be requested by name or by index.</dd>
   <dt>getFieldIndex</dt>
     <dd>Return the index of the field with the specified fieldName.</dd>
   <dt>getFields</dt>
     <dd>Return the array of sub fields.</dd>
   <dt>getFieldNames</dt>
     <dd>Return the fieldNames for the fields.</dd>
   <dt>getFieldName</dt>
     <dd>Return the Field for the index.</dd>
</dl>
<h5>StructureArray</h5>
<pre>
interface StructureArray extends Field{
    Structure getStructure();
}
</pre>
where
<dl>
   <dt>getStructure</dt>
     <dd>Return the introspection interface for the array elements.</dd>
</dl>
<h5>FieldCreate</h5>
<p><b>Syntax for fieldName and id.</b>
<p>A <b>fieldName</b> must begin with a letter and must be a sequence of letters
and digits.
A letter is defined as 'A'-'Z', 'a'-'z','_', or any Unicode character
that denotes a letter in a language. Similarly digits are '0'-'9' and any
Unicode character that denotes a digit in a language.
Note that this is the same as the Java syntax for variable names.</p>
<p>The syntax for <b>id</b> is the same except the '.' is also allowed
after the initial letter.</p>
<pre>
interface FieldCreate {
    Scalar createScalar(ScalarType scalarType);
    ScalarArray createScalarArray(ScalarType elementType);
    StructureArray createStructureArray(Structure elementStructure);
    Structure createStructure(String[] fieldNames, Field[] fields);
    Structure createStructure(String id,String[] fieldNames, Field[] fields);
    Structure appendField(Structure structure,String fieldName, Field field);
    Structure appendFields(Structure structure,String[] fieldNames, Field[] fields);
    Structure createStructure(Structure structToClone);
    Field deserialize(ByteBuffer buffer, DeserializableControl control);
}
</pre>
where
<dl>
   <dt>createScalar</dt>
     <dd>Return the Scalar with the specified scalarType.
       Note that the implementation creates a single instance for
      each scalarType.</dd>
   <dt>createScalarArray</dt>
     <dd>Return the ScalarArray with the specified elementType.
       Note that the implementation creates a single instance for
      each elementType.</dd>
   <dt>createStructureArray</dt>
     <dd>Return a StructureArray with the specified introspection
     interface for each array element.</dd>
   <dt>createStructure</dt>
     <dd>Return a Structure. There are two methods.
     The first creates a structure with an empty ID.
     </dd>
   <dt>appendField</dt>
     <dd>Append a field to a structure.</dd>
   <dt>appendFields</dt>
     <dd>Append an array of fields to a structure.</dd>
   <dt>deserialize</dt>
     <dd>Deserialize a field from the the buffer.</dd>
</dl>


<h3>status</h3>

<p>Status provides a way to pass status back to client code. It is new and not
currently used by pvData but may be in the future. It is used by code that uses
pvData.</p>
<h4>Status</h4>
<pre>
interface Status extends Serializable  {
    public enum StatusType {OK,WARNING,ERROR,FATAL};
    StatusType getType();
    String getMessage();
    String getStackDump();
    boolean isOK();
    boolean isSuccess();
}
</pre>
where
<dl>
  <dt>StatusType</dt>
    <dd>An enum for the status type.</dd>
  <dt>getType</dt>
    <dd>Get the statusType.</dd>
  <dt>getMessage</dt>
    <dd>Get a message explaining the error.</dd>
  <dt>getStackDump</dt>
    <dd>Get a stack dump.</dd>
  <dt>isOK</dt>
     <dd>Is the status the singleton object for StatusType.OK?</dd>
  <dt>isSuccess</dt>
     <dd>Is the StatusType either OK or WARNING?</dd>
</dl>
<h4>StatusCreate</h4>
<pre>
interface StatusCreate {
    Status getStatusOK(); 
    Status createStatus(StatusType type, String message, Throwable cause);
    Status deserializeStatus(ByteBuffer buffer, DeserializableControl control);
}
</pre>
where
<dl>
  <dt>getStatusOK</dt>
    <dd>Get a singleton that returns StatusType.OK and a null message and
      stackDump.</dd>
  <dt>createStatus</dt>
    <dd>Create a new Status.</dd>
  <dt>deserializeStatus</dt>
    <dd>Use this method instead of Status.deserialize(), since this allows OK
      status optimization.</dd>
</dl>

<h3>PVField - Data Interfaces</h3>

<p>This section defines the Java Interfaces for accessing the data within
a top level PVStructure.</p>

<h4>PVField</h4>

<p>PVField is the base interface for accessing data. Every field of a
top level PVStructure has a PVField associated with it.
This includes the top level structure itself.
</p>
<pre>
interface PVField extends Serializable, Requester {
    String getFieldName();
    void setRequester(Requester requester);
    int getFieldOffset();
    int getNextFieldOffset();
    int getNumberFields();
    PVAuxInfo getPVAuxInfo();
    boolean isImmutable();
    void setImmutable();
    Field getField();
    PVStructure getParent();
    void renameField(String newName);
    void postPut();
    void setPostHandler(PostHandler postHandler);
    String toString();
    void toString(StringBuilder buf);
    void toString(StringBuilder buf,int indentLevel);
}
</pre>

<p>where</p>
<dl>
  <dt>getFieldName</dt>
     <dd>Get the field name for this field. This will be a empty string for
     the top level structure.</dd>
  <dt>setRequester</dt>
    <dd>Set a requester to receive messages sent to this field. A field can
      only have a single requester. An IllegalStateException is thrown if a
      requester is already attached.</dd>
  <dt>getFieldOffset</dt>
    <dd>Get offset of the PVField field within top level structure. Every field
      within the PVStructure has a unique offset. The top level structure has
      an offset of 0. The first field within the structure has offset equal to
      1. The other offsets are determined by recursively traversing each
      structure of the tree. </dd>
  <dt>getNextFieldOffset</dt>
    <dd>Get the next offset. If the field is a scalar or array field then this
      is just offset + 1. If the field is a structure it is the offset of the
      next field after this structure. Thus (nextOffset - offset) is always
      equal to the total number of fields within the field. </dd>
  <dt>getNumberFields</dt>
    <dd>Get the total number of fields in this field. This is nextFieldOffset -
      fieldOffset. </dd>
  <dt>getPVAuxInfo</dt>
    <dd>Get the PVAuxInfo for this field. PVAuxInfo is described below.</dd>
  <dt>isImmutable</dt>
    <dd>Is the field immutable?</dd>
  <dt>setImmutable</dt>
    <dd>Make the field immutable. Once a field is immutable it can never be
      changed since there is no method to again make it mutable. This is an
      important design decision because it allows immutable array fields to
      share the internal primitive data array.</dd>
  <dt>getField</dt>
    <dd>Get the reflection interface.</dd>
  <dt>getParent</dt>
    <dd>Get the interface for the parent or null if this is the top level
      PVStructure.</dd>
  <dt>renameField</dt>
    <dd>Rename the field name.</dd>
  <dt>postPut</dt>
    <dd>If this field is a field of a record pvRecordField.postPut() is called.
      If not a field of a record nothing happens.</dd>
  <dt>setPostHandler</dt>
     <dd>Set the handler for postPut. At most one handler can be set.</dd>
  <dt>toString</dt>
    <dd>Converts the field data to a string. This is mostly for debugging
      purposes. The format is the meta data format described in the pvData
      project overview.
      <b>Note:</b> The actual conversion is done by the Convert facility. </dd>
</dl>

<h4>Requester</h4>

<p>A PVField extends Requester. Requester is present so that when database
errors are found there is someplace to send a message.</p>
<p>In the pvIOCJava, PVRecord provides methods to register message requesters. Also a PVDatabase
provides an identical method. Thus when a message is generated for a field it
is propagated up to the record with the full field name attached and then
propagated to the PVDatabase which sends the messages to the registered
requesters.</p>
<pre>
enum MessageType {info,warning,error,fatalError}

interface Requester {
    String getRequesterName();
    void message(String message, MessageType messageType);
}
</pre>

<p>where</p>
<dl>
  <dt></dt>
  <dt>MessageType</dt>
    <dd>Type of message.</dd>
  <dt>Requester</dt>
    <dd>The default implementation is: 
      <ul>
        <li>getRequesterName<br />
          This is the full field name concatenated to the record name.</li>
        <li>message<br />
          For the default implementation, PVField prepends the full field name
          to the message and calls PVRecord.message. The default implementation
          for PVRecord either displays the message on stdout or stderr or gives
          the message to message requsters.</li>
      </ul>
    </dd>
</dl>

<h4>PVAuxInfo</h4>

<p>AuxInfo (Auxillary Information) is information about a field that is
application specific. It will not be available outside the application that
implements the database. In particular it will not be made available to Channel
Access. It is used by the database itself to override the default
implementation of fields. The JavaIOC uses it for attaching support code.
Database Configuration and other tools can use it for configuration
information. Each Field and each PVField can have have an arbitrary number of
auxInfos. An auxInfo is a (key,PVScalar) pair where key is a string.</p>
<pre>
public interface PVAuxInfo {
    PVField getPVField();
    PVScalar createInfo(String key,ScalarType scalarType);
    Map&lt;String,PVScalar&gt; getInfos();
    PVScalar getInfo(String key);
    void toString(StringBuilder buf);
    void toString(StringBuilder buf,int indentLevel);
}
</pre>

<p>where</p>
<dl>
  <dt>getPVField</dt>
    <dd>Get the PVField to which this PVAuxInfo is attached.</dd>
  <dt>createInfo</dt>
    <dd>Create a new PVScalar of type scalarType.</dd>
  <dt>getInfos</dt>
    <dd>Get a map of all the auxInfos.</dd>
  <dt>getInfo</dt>
    <dd>Get the PVScalar with the specified key.</dd>
  <dt>toString</dt>
    <dd>Print all the auxInfo data in metadata format.</dd>
</dl>

<h4>PVScalar and extensions</h4>
<pre>
interface PVScalar extends PVField {
    Scalar getScalar();
}
</pre>

<h5>Primitive PVField types</h5>

<p>The interfaces for primitive data types are:</p>
<pre>
interface PVBoolean extends PVScalar {
    boolean get();
    void put(boolean value);
}

interface PVByte extends PVScalar {
    byte get();
    void put(byte value);
}

interface PVShort extends PVScalar {
    short get();
    void put(short value);
}

interface PVInt extends PVScalar {
    int get();
    void put(int value);
}

interface PVLong extends PVScalar {
    long get();
    void put(long value);
}

interface PVUByte extends PVScalar {
    byte get();
    void put(byte value);
}

interface PVUShort extends PVScalar {
    short get();
    void put(short value);
}

interface PVUInt extends PVScalar {
    int get();
    void put(int value);
}

interface PVULong extends PVScalar {
    long get();
    void put(long value);
}

interface PVFloat extends PVScalar {
    float get();
    void put(float value);
}

interface PVDouble extends PVScalar {
    double get();
    void put(double value);
}
</pre>
<p><b>NOTE:</b> The implementation for each unsigned integer is the same as for the same signed type.
This is because Java does not implement unsigned primitive types.</p>

<h5>PVString</h5>

<p>The interface for string is:</p>
<pre>
interface PVString extends PVScalar, SerializableArray {
    String get();
    void put(String value);
}
</pre>

<h4>PVArray and Extensions</h4>

<p><span style="font-family: courier">PVArray</span> is the base interface for
all the other PV Array interfaces. It extends PVField and provides the
additional methods:</p>
<pre>
interface PVArray extends PVField, SerializableArray {
    int getLength();
    void setLength(int len);
    int getCapacity();
    void setCapacity(int len);
    boolean isCapacityMutable();
    void setCapacityMutable(boolean isMutable);
}
</pre>
<dl>
  <dt>getLength</dt>
<dd>Get the current length. This is less that or equal to the capacity.</dd>
  <dt>setLength</dt>
<dd>Set the length. If the PVField is not mutable then an exception is
  thrown. If this is greater than the capacity setCapacity is called.</dd>
  <dt>getCapacity</dt>
<dd>Get the capacity, i.e. this is the sized of the underlying data
array.</dd>
  <dt>setCapacity</dt>
<dd>Set the capacity. The semantics are implementation dependent but
  typical semantics are as follows: If the capacity is not mutable an
  exception is thrown. A new data array is created and data is copied from
  the old array to the new array. </dd>
  <dt>isCapacityMutable</dt>
<dd>Is the capacity mutable</dd>
  <dt>setCapacityMutable</dt>
<dd>Specify if the capacity can be changed.</dd>
</dl>

<h5>PVArray Extensions</h5>

<p>The interface for each array type has get and put methods which have the
same arguments except for the data type. For example PVDoubleArray is:</p>
<pre>
public class DoubleArrayData {
    public double[] data;
    public int offset;
}
interface PVDoubleArray extends PVScalarArray {
    int get(int offset, int len, DoubleArrayData data);
    int put(int offset, int len, double[]from, int fromOffset);
    void shareData(double[] from);
}i
</pre>

<p>Get "exposes" it's internal array by setting data.data and data.offset. The
caller is responsible for copying the array elements. This violates the
principle that objects should not expose their internal data but is done for
efficency. For example it makes it possible to copy between arrays with
identical element types via a call to System.arraycopy without requiring an
intermediate array.</p>

<p>Both get and put return the number of elements actually transfered. The
arguments are:</p>
<dl>
  <dt>offset</dt>
<dd>The offset in the PV array.</dd>
  <dt>len</dt>
<dd>The maximum number of elements to transfer. The number actually
  transfered will be less than or equal to this value.</dd>
  <dt>data</dt>
<dd>Get sets data.data to it's internal array and data.offset to the offset
  into the array. The caller is responsible for the actual data
transfer.</dd>
  <dt>from</dt>
<dd>The array from which the data is taken. This array is supplied by the
  caller</dd>
  <dt>fromOffset</dt>
<dd>The offset in <span>from</span></dd>
</dl>

<p>The caller must be prepared to make multiple calls to retrieve or put an
entire array. A caller should accept or put partial arrays. For example the
following reads an entire array:</p>
<pre>
double[] getArray(PVDoubleArray pv)
{
    int len = pv.getLength();
    double[] storage = new double[len];
    DoubleArrayData data = new DoubleArrayData();
    int offset = 0;
    while(offset &lt; len) {
        int num = pv.get(offset,(len-offset),data);
        System.arraycopy(data.data,data.offset,storage,offset,num);
        offset += num;
    }
    return storage;
}
</pre>

<p>shareData results in the PVArray using the primitive array that is passed to
this method. This is most useful for immutable arrays. In this case the caller
must set the PVArray to be immutable. If the PVArray is not immutable then 
the application is responsibility for coordinating access to the array.
This violates the principle that objects should not expose their internal data but
is important for immutable arrays. For example pvData and the javaIOC define
many enumerated structures where an enumerated structure has twofields: index
and choices. Choices is a PVStringArray that holds the enumerated choices.
Index is a PVInt that is the index of the currently selected choice. The
choices can be immutable. Allowing the choices internal String[] to be shared
between all the instances of an enumerated structure saves on storage. Another
reason for allowing shared data is so that an application which processes an
array can be separated into multiple modules that directly access the internal
data array of a PVArray. This can be required for minimizing CPU overhead. In
this case it is the applications responsibility to coordinate access to the
array.</p>

<h5>Complete set of PVArray Extensions</h5>
<pre>
interface PVScalarArray extends PVArray {
    ScalarArray getScalarArray();
}

public class BooleanArrayData {
    public boolean[] data;
    public int offset;
}
interface PVBooleanArray extends PVScalarArray {
    int get(int offset, int len, BooleanArrayData data);
    int put(int offset, int len, boolean[]from, int fromOffset);
    void shareData(boolean[] from);
}

public class ByteArrayData {
    public byte[] data;
    public int offset;
}
interface PVByteArray extends PVScalarArray {
    int get(int offset, int len, ByteArrayData data);
    int put(int offset, int len, byte[]from, int fromOffset);
    void shareData(byte[] from);
}
interface PVUByteArray extends PVScalarArray {
    int get(int offset, int len, ByteArrayData data);
    int put(int offset, int len, byte[]from, int fromOffset);
    void shareData(byte[] from);
}

public class ShortArrayData {
    public short[] data;
    public int offset;
}
interface PVShortArray extends PVScalarArray {
    int get(int offset, int len, ShortArrayData data);
    int put(int offset, int len, short[]from, int fromOffset);
    void shareData(short[] from);
}
interface PVUShortArray extends PVScalarArray {
    int get(int offset, int len, ShortArrayData data);
    int put(int offset, int len, short[]from, int fromOffset);
    void shareData(short[] from);
}

public class IntArrayData {
    public int[] data;
    public int offset;
}
interface PVIntArray extends PVScalarArray {
    int get(int offset, int len, IntArrayData data);
    int put(int offset, int len, int[]from, int fromOffset);
    void shareData(int[] from);
}
interface PVUIntArray extends PVScalarArray {
    int get(int offset, int len, IntArrayData data);
    int put(int offset, int len, int[]from, int fromOffset);
    void shareData(int[] from);
}

public class LongArrayData {
    public long[] data;
    public int offset;
}
interface PVLongArray extends PVScalarArray {
    int get(int offset, int len, LongArrayData data);
    int put(int offset, int len, long[]from, int fromOffset);
    void shareData(long[] from);
}
interface PVULongArray extends PVScalarArray {
    int get(int offset, int len, LongArrayData data);
    int put(int offset, int len, long[]from, int fromOffset);
    void shareData(long[] from);
}

public class FloatArrayData {
    public float[] data;
    public int offset;
}
interface PVFloatArray extends PVScalarArray {
    int get(int offset, int len, FloatArrayData data);
    int put(int offset, int len, float[]from, int fromOffset);
    void shareData(float[] from);
}

public class DoubleArrayData {
    public double[] data;
    public int offset;
}
interface PVDoubleArray extends PVScalarArray {
    int get(int offset, int len, DoubleArrayData data);
    int put(int offset, int len, double[]from, int fromOffset);
    void shareData(double[] from);
}

public class StringArrayData {
    public String[] data;
    public int offset;
}
interface PVStringArray extends PVScalarArray {
    int get(int offset, int len, StringArrayData data);
    int put(int offset, int len, String[]from, int fromOffset);
    void shareData(String[] from);
}

public class StructureArrayData {
    public PVStructure[] data;
    public int offset;
}

interface PVStructureArray extends PVArray {
    StructureArray getStructureArray();
    int get(int offset, int length, StructureArrayData data);
    int put(int offset,int length, PVStructure[] from, int fromOffset);
    void shareData(PVStructure[] from);
}
</pre>
<p><b>NOTES:</b></p>
<dl>
   <dt>Unsigned types</dt>
     <dd>The implementation for each unsigned integer is the same as for the same signed type.
     This is because Java does not implement unsigned primitive types.</dd>
   <dt>PVStructureArray</dt>
     <dd>A client can only access the data in the
       elements of the array via the get and put methods, i.e. it is not possible to
       access subfields indirectly. PVStructureArray.getNumberFields() returns 1, i.e.
       the field looks like a leaf field.</dd>
</dl>

<h4>PVStructure</h4>

<p>The interface for a structure is:</p>
<pre>
interface PVStructure extends PVField, BitSetSerializable {
    Structure getStructure();
    PVField[] getPVFields();
    PVField getSubField(String fieldName);
    PVField getSubField(int fieldOffset);
    void appendPVField(PVField pvField);
    void appendPVFields(PVField[] pvFields);
    void removePVField(String fieldName);
    void replacePVField(PVField oldPVField,PVField newPVField);
    // the following are convenience methods
    PVBoolean getBooleanField(String fieldName);
    PVByte getByteField(String fieldName);
    PVShort getShortField(String fieldName);
    PVInt getIntField(String fieldName);
    PVLong getLongField(String fieldName);
    PVFloat getFloatField(String fieldName);
    PVDouble getDoubleField(String fieldName);
    PVString getStringField(String fieldName);
    PVStructure getStructureField(String fieldName);
    PVScalarArray getScalarArrayField(String fieldName,ScalarType elementType);
    PVStructureArray getStructureArrayField(String fieldName);
    String getExtendsStructureName();
    boolean putExtendsStructureName(String extendsStructureName);
}
</pre>

<p>where</p>
<dl>
  <dt>getStructure</dt>
    <dd>Get the introspection interface for the structure.</dd>
  <dt>getPVFields</dt>
    <dd>Returns the array of subfields. The set of subfields must all have
      different field names.</dd>
  <dt>getSubField(String fieldName)</dt>
    <dd>Get a subField of a field. For a PVStructure a non-null result is
      returned if fieldName is a field of the PVStructure. The fieldName can be
      of the form name.name...</dd>
  <dt>getSubField(int fieldOffset)</dt>
    <dd>Get the field located a fieldOffset, where fieldOffset is relative to
      the top level structure. This returns null if the specified field is not
      located within this PVStructure.</dd>
  <dt>appendPVField</dt>
    <dd>Append pvField to the end of this PVStructure. This should NOT be
      called if any code is attached to any of the fields in the top level
      structure.</dd>
  <dt>appendPVFields</dt>
    <dd>Append an array of pvFields to the end of this structure. Note that if
      the original number of fields is 0 than pvFields replaces the original.
      Thus the caller must NOT reuse pvFields after calling this method. This
      should NOT be called if any code is attached to any of the fields in the
      top level structure</dd>
  <dt>removePVField</dt>
    <dd>Remove the specified field from this structure. This should NOT be
      called if any code is attached to any of the fields in the top level
      structure.</dd>
  <dt>replacePVField</dt>
     <dd>Replace a field with a new field.</dd>
  <dt>getBooleanField</dt>
    <dd>Look for fieldName. If found and it has the correct type return the
      interface. This and the following methods are convenience methods that
      allow a user to get the interface to a subfield without requiring
      introspection. fieldName can be of the form name.name...</dd>
  <dt>getByteField</dt>
    <dd>Look for fieldName. If found and it has the correct type return the
      interface.</dd>
  <dt>getShortField</dt>
    <dd>Look for fieldName. If found and it has the correct type return the
      interface.</dd>
  <dt>getIntField</dt>
    <dd>Look for fieldName. If found and it has the correct type return the
      interface.</dd>
  <dt>getLongField</dt>
    <dd>Look for fieldName. If found and it has the correct type return the
      interface.</dd>
  <dt>getFloatField</dt>
    <dd>Look for fieldName. If found and it has the correct type return the
      interface.</dd>
  <dt>getDoubleField</dt>
    <dd>Look for fieldName. If found and it has the correct type return the
      interface.</dd>
  <dt>getStringField</dt>
    <dd>Look for fieldName. If found and it has the correct type return the
      interface.</dd>
  <dt>getScalarArrayField</dt>
    <dd>Look for fieldName. If found and it has the correct type return the
      interface.</dd>
  <dt>getStructureArrayField</dt>
    <dd>Look for fieldName. If found and it has the correct type return the
      interface.</dd>
  <dt>getExtendsStructureName</dt>
    <dd>Get the name of structure that this structure extends.</dd>
  <dt>putExtendsStructureName</dt>
    <dd>Specify the structure that this structure extends.</dd>
</dl>

<h4>PVDataCreate</h4>

<p>PVDataCreate is an interface that provides methods that create PVField
interfaces. A factory is provided that creates PVDataCreate.</p>
<pre>interface PVDataCreate {
    PVField createPVField(Field field);
    PVField createPVField(PVField fieldToClone);
    PVScalar createPVScalar(Scalar scalar);
    PVScalar createPVScalar(ScalarType fieldType);
    PVScalar createPVScalar(PVScalar scalarToClone);
    PVScalarArray createPVScalarArray(ScalarArray array);
    PVScalarArray createPVScalarArray(ScalarType elementType);
    PVScalarArray createPVScalarArray(PVScalarArray arrayToClone);
    PVStructureArray createPVStructureArray(StructureArray structureArray);
    PVStructure createPVStructure(Structure structure);
    PVStructure createPVStructure(String[] fieldNames,PVField[] pvFields);
    PVStructure createPVStructure(PVStructure structToClone);
    PVField[] flattenPVStructure(PVStructure pvStructure);
}</pre>
where 
<dl>
  <dt>createPVField</dt>
    <dd>The PVField is created reusing the Field interface. Two methods are
      provided. Each calls the corresponding createPVScalar, createPVArray, or
      createPVStructure depending in the type of the argument.</dd>
  <dt>createPVScalar</dt>
    <dd>Creates an instance of a PVScalar. Three versions are supplied. The
      first is passed an introspection interface. The second provides the field
      name and the scalarType. The last provides a field name and a PVScalar to
      clone. The newly created PVScalar will have the same auxInfos as the
      original.</dd>
  <dt>createPVScalarArray</dt>
    <dd>Create an instance of a PVArray. Three versions are supplied. The first
      is passed an introspection interface. The second provides the field name
      and the elementType. The last provides a field name and a PVArray to
      clone. The newly created PVArray will have the same auxInfos as the
      original.</dd>
  <dt>createPVStructureArray</dt>
    <dd>Create a PVStructureArray. It must be passed a structureToClone. This
      will become the Structure interface for ALL elements of the
      PVStructureArray. It MUST be used to create any new array elements.</dd>
  <dt>createPVStructure</dt>
    <dd>Create an instance of a PVStructure. Three methods are provided. The
      first method uses a previously created structure introspection interface.
      The second uses a PVField[].
      The third initializes the subfields by cloning the fields contained in
      structToClone. The newly created sub-fields will have the same values and
      auxInfos as the original. If structToClone is null then the new structure
      is initialized to have 0 sub-fields.</dd>
  <dt>flattenPVStructure</dt>
    <dd>Create an array of PVFields for the fields in the PVStructure. The
      order is according to fieldOffset.</dd>
</dl>

<h3>Convert</h3>

<p><b>NOTE:</b> copying immutable array fields. If an entire immutable array
field is copied to another array that has the same elementType, both offsets
are 0, and the length is the length of the source array, then the shareData
method of the target array is called and the target array is set immutable.
Thus the source and target share the same primitive array.</p>

<p>This section describes the supported conversions between data types.</p>
<ul>
  <li>All supported types can be converted to a string. If you ask for a 100
    megabyte array to be converted to a string expect a lot of output.</li>
  <li>Conversion from a string to a scalar type.</li>
  <li>Conversion from an array of strings to an array of scalar types.</li>
  <li>Copy between the following types of scalar PVs 
    <ul>
      <li>Numeric type to another numeric type</li>
      <li>Both have the same type.</li>
      <li>Either is a string</li>
    </ul>
  </li>
  <li>Copy between PVArrays that satisfy one of the following. 
    <ul>
      <li>Numeric to numeric</li>
      <li>Both have the same type.</li>
      <li>Either is a string.</li>
    </ul>
  </li>
  <li>Conversions between numeric scalar types.</li>
  <li>Conversions between arrays of numeric type.</li>
  <li>Conversion between compatible structures.</li>
  <li>Support for unsigned integers. Because Java does primitive unsigned
   integers the only support is in "widening" operations.
   For example if a PVUByte is converted to short then the proper conversion will
   be done.</li>
  <li>A utility method the returns the full field name of a field.</li>
</ul>
<pre>
interface Convert {
    void getFullFieldName(StringBuilder builder,PVField pvField)
    void getString(StringBuilder buf,PVField pv, int indentLevel);
    void getString(StringBuilder buf,PVField pv);
    void fromString(PVScalar pv,String from);
    void fromString(PVScalarArray pv,String from);
    int fromStringArray(PVScalarArray pv,
         int offset, int len, String[]from, int fromOffset);
    int toStringArray(PVScalarArray pv,
         int offset, int len, String[]to, int toOffset);
    boolean isCopyCompatible(Field from, Field to);
    void copy(PVField from,PVField to);
    boolean isCopyScalarCompatible(Field from, Field to);
    void copyScalar(PVField from, PVField to);
    boolean isCopyScalarArrayCompatible(ScalarArray from, ScalarArray to);
    int copyScalarArray(PVScalarArray from, int offset,
         PVScalarArray to, int toOffset, int len);
    boolean isCopyStructureCompatible(Structure from, Structure to);
    void copyStructure(PVStructure from, PVStructure to);
    boolean isCopyStructureArrayCompatible(StructureArray from, StructureArray to);
    void copyStructureArray(PVStructureArray from, PVStructureArray to);
    // For the following the pv Type must be PVByte, ...., PVDouble
    byte toByte(PVField pv);
    short toShort(PVField pv);
    int   toInt(PVField pv);
    long  toLong(PVField pv);
    float toFloat(PVField pv);
    double toDouble(PVField pv);
    String toString(PVScalar pv);
    void  fromByte(PVField pv, byte from);
    void  fromShort(PVField pv, short from);
    void  fromInt(PVField pv, int from);
    void  fromLong(PVField pv, long from);
    void  fromUByte(PVField pv, byte from);
    void  fromUShort(PVField pv, short from);
    void  fromUInt(PVField pv, int from);
    void  fromULong(PVField pv, long from);
    void  fromFloat(PVField pv, float from);
    void  fromDouble(PVField pv, double from);
// For the following the element type must be pvByte, ...., pvDouble
    int toByteArray(PVScalarArray pv,
        int offset, int len, byte[]to, int toOffset);
    int toShortArray(PVScalarArray pv,
        int offset, int len, short[]to, int toOffset);
    int toIntArray(PVScalarArray pv,
        int offset, int len, int[]to, int toOffset);
    int toLongArray(PVScalarArray pv,
        int offset, int len, long[]to, int toOffset);
    int toFloatArray(PVScalarArray pv,
        int offset, int len, float[]to, int toOffset);
    int toDoubleArray(PVScalarArray pv,
        int offset, int len, double[]to, int toOffset);
    int fromByteArray(PVScalarArray pv,
        int offset, int len, byte[]from, fromOffset);
    int fromShortArray(PVScalarArray pv,
        int offset, int len, short[]from, fromOffset);
    int fromIntArray(PVScalarArray pv,
        int offset, int len, int[]from, fromOffset);
    int fromLongArray(PVScalarArray pv,
        int offset, int len, long[]from, fromOffset);
    int fromUByteArray(PVScalarArray pv,
        int offset, int len, byte[]from, fromOffset);
    int fromUShortArray(PVScalarArray pv,
        int offset, int len, short[]from, fromOffset);
    int fromUIntArray(PVScalarArray pv,
        int offset, int len, int[]from, fromOffset);
    int fromULongArray(PVScalarArray pv,
        int offset, int len, long[]from, fromOffset);
    int fromFloatArray(PVScalarArray pv,
        int offset, int len, float[]from, fromOffset);
    int fromDoubleArray(PVScalarArray pv,
        int offset, int len, double[]from, fromOffset);
    void newLine(StringBuilder builder, int indentLevel);
}
</pre>

<p>The array methods all return the number of elements copied or converted.
This can be less than <span>len</span> if the
PVField array contains less than len elements.</p>

<p><span>newLine</span> is a convenience method
for code that implements <span>toString</span> It
generates a newline and inserts blanks at the beginning of the newline.</p>

<p>The getString methods dump the data in the metadata syntax described in the
pvData project overview. Note that the toString methods of PVField are
implemented by calling these convert methods.</p>

<h3>StandardField and StandardPVField</h3>
<p><b>Warning:</b>
The concept of Standard Field is closely related to property which is described below.
The section on property provides details about alarm,
timeStamp, display, control, and enumerated.
That section should be read in conjuction with this section.</p>
<p>A standard field is a field that tools know how to use.
pvData defines and provides support for the following standard fields.</p>
<dl>
  <dt>enumerated</dt>
    <dd>This is a structure that has two subfields: index, and choices</dd>
  <dt>value</dt>
   <dd>This is any field with the name "value".
    It can be any type.
    The other standard fields can provide "properties" for the value field.
   </dd>
  <dt>timeStamp</dt>
    <dd>Encodes a time stamp. It can be a standalone field or be a property
    if a value field, in which case it should be a sub field of the same structure
    as the value field.</dd>
  <dt>alarm</dt>
    <dd>Encodes an alarm. It is normally a property
    if a value field, in which case it should be a sub field of the same structure
    as the value field.</dd>
  <dt>display</dt>
    <dd>Encodes a set of information for displaying a scalar or scalarArray value.
     It is normally a property
    if a value field, in which case it should be a sub field of the same structure
    as the value field.</dd>
  <dt>control</dt>
    <dd>Encodes a set of information for limits for a scalar or scalarArray value.
     It is normally a property
    if a value field, in which case it should be a sub field of the same structure
    as the value field.</dd>
  <dt>valueAlarm</dt>
    <dd>Defines a set of values for setting alarm values for a scalar value.
     It has separate definitions for booleanAlarm, byteAlarm, shortAlarm,
     intAlarm, longAlarm, floatAlarm, and doubleAlarm.
     There is also an enumeratedAlarm for an enumerated value field.</dd>
</dl>
<h4>StandardField</h4>
<pre>
interface StandardField {
    Structure scalar(ScalarType scalarType,String properties);
    Structure scalarArray(ScalarType elementType, String properties);
    Structure structureArray(Structure structure,String properties);
    Structure enumerated();
    Structure enumerated(String properties);
    Structure alarm();
    Structure timeStamp();
    Structure display();
    Structure control();
    Structure booleanAlarm();
    Structure byteAlarm();
    Structure shortAlarm();
    Structure intAlarm();
    Structure longAlarm();
    Structure floatAlarm();
    Structure doubleAlarm();
    Structure enumeratedAlarm();
}
</pre>
where
<dl>
   <dt>scalar</dt>
     <dd>Create a Structure that has a scalar field named value and with the
      specfied scalarType.
     The structure can have aditional fields that are properties of the value field.
     properties is some combination of
     alarm, timeStamp, display, control, and valueAlarm.</dd>
   <dt>scalarArray</dt>
     <dd>Create a Structure that has a scalarArray field named value and with the
      specfied elementType,.
     The structure can have aditional fields that are properties of the value field.
     properties is some combination of
     alarm, timeStamp, display, and control.</dd>
   <dt>structureArray</dt>
     <dd>Create a Structure that has a structureArray field named value and with the
      specfied structure as the introspection interface for each array element,.
     The structure can have aditional fields that are properties of the value field.
     properties is some combination of alarm and timeStamp.</dd>
   <dt>enumerated()</dt>
      <dd>Create an enumerated Structure</dd>
   <dt>enumerated(String properties)</dt>
     <dd>Create a Structure that has an enumerated structure field named value.
      The structure can have aditional fields that are properties of the value field.
     properties is some combination of
     alarm, timeStamp, and enumeratedAlarm.</dd>
   <dt>alarm</dt>
     <dd>Create an alarm Structure.</dd>
   <dt>timeStamp</dt>
     <dd>Create a timeStamp Structure.</dd>
   <dt>display</dt>
     <dd>Create an display Structure.</dd>
   <dt>control</dt>
     <dd>Create a control Structure.</dd>
   <dt>booleanAlarm</dt>
     <dd>Create a booleanAlarm Structure.</dd>
   <dt>byteAlarm</dt>
     <dd>Create a byteAlarm Structure.</dd>
   <dt>shortAlarm</dt>
     <dd>Create a shortAlarm Structure.</dd>
   <dt>intAlarm</dt>
     <dd>Create a intAlarm Structure.</dd>
   <dt>longAlarm</dt>
     <dd>Create a longAlarm Structure.</dd>
   <dt>floatAlarm</dt>
     <dd>Create a floatAlarm Structure.</dd>
   <dt>doubleAlarm</dt>
     <dd>Create a doubleAlarm Structure.</dd>
   <dt>enumeratedAlarm</dt>
     <dd>Create a enumearatedAlarm Structure.</dd>
</dl>
<h4>StandardPVField</h4>
<pre>
interface StandardPVField {
    PVStructure scalar(ScalarType type,String properties);
    PVStructure scalarArray(ScalarType elementType, String properties);
    PVStructure structureArray(Structure structure,String properties);
    PVStructure enumerated(String[] choices);
    PVStructure enumerated(String[] choices,String properties);
}
</pre>
where
<dl>
   <dt>scalar</dt>
     <dd>Create a PVStructure that has a scalar field named value and with the
      specfied scalarType.
     The structure can have aditional fields that are properties of the value field.
     properties is some combination of
     alarm, timeStamp, display, control, and valueAlarm.</dd>
   <dt>scalarArray</dt>
     <dd>Create a PVStructure that has a scalarArray field named value and with the
      specfied elementType,.
     The structure can have aditional fields that are properties of the value field.
     properties is some combination of
     alarm, timeStamp, display, and control.</dd>
   <dt>structureArray</dt>
     <dd>Create a PVStructure that has a structureArray field named value and with the
      specfied structure as the introspection interface for each array element,.
     The structure can have aditional fields that are properties of the value field.
     properties is some combination of alarm and timeStamp.</dd>
   <dt>enumerated(String[] choices)</dt>
      <dd>Create an enumerated PVStructure.
       The choices field is initialized with choices and set immutable.
      </dd>
   <dt>enumerated(String[] choices,String properties)</dt>
     <dd>Create a PVStructure that has an enumerated structure field named value.
       The choices field of value is initialized with choices and set immutable.
      The structure can have aditional fields that are properties of the value field.
     properties is some combination of
     alarm, timeStamp, and enumeratedAlarm.</dd>
</dl>
<h3>Examples</h3>

<h4>Accessing PVData</h4>

<p>Assume that code wants to access two fields from a PVStructure:</p>
<dl>
  <dt>value</dt>
    <dd>Must be a PVDouble.</dd>
  <dt>timeStamp</dt>
    <dd>Just look for field with this name.</dd>
</dl>

<p>The following code uses introspection to get the desired information.</p>
<pre>String getValueAndTimeStamp(PVStructure pvStructure) {
   PVField valuePV = pvStructure.getSubField("value");
   if(valuePV==null) {
       return "value field not found";
   }
   if(valuePV.getField.getType!=Type.scalar) {
       return "value field is not a scalar";
   }
   Scalar scalar = (Scalar)valuePV.getField();
   if(scalar.getScalarType!=ScalarType.pvDouble) {
       return "value field is not a double";
   }
   PVDouble pvDouble = (PVDouble)valuePV;
   PVField timeStampPV = pvStructure.getSubField("timeStamp");
   if(timeStampPV==null) {
       return "timeStamp field not found";
   }
   double value = valuePV.get();
   return value + " timeStamp " + timeStampPV.toString();
}</pre>

<h4>Creating PVData</h4>

<p>Example of creating a scalar field.</p>
<pre>
PVDataCreate pvDataCreate = PVDataFactory.getPVDataCreate();
PVDouble pvValue = pvDataCreate.createPVScalar(ScalarType.pvDouble);
</pre>

<p>Create a structure.</p>
<pre>    
FieldCreate fieldCreate = FieldFactory.getFieldCreate();
PVDataCreate pvDataCreate = PVDataFactory.getPVDataCreate();

PVStructure create() {
    Field[] fields = new Field[2];
    String[] fieldNames = new String[2];
    fields[0] = fieldCreate.createScalar(ScalarType.pvLong);
    fields[1] = fieldeCreate.createScalar(ScalarType.pvInt);
    fieldNames[0] = "a";
    fieldNames[1] = "b";
    PVStructure pvStructure = pvDataCreate.createPVStructure(
        fieldNames,fields);
    return(pvStructure);
}
</pre>

<p>StandardPVField provides and easy way to create fields. For example:</p>
<pre>
StandardPVField standardPVField = StandardPVFieldFactory.getStandardPVField();
PVStructure pvStructure = standardPVField.scalar(
    ScalarType.pvDouble,
    "alarm,timeStamp.display,control,valueAlarm");
</pre>

<h2 >Package org.epics.pvdata.factory</h2>

<h3>Overview</h3>

<p>This package provides factories and classes to implement everything defined
in package org.epics.pvdata.pv</p>

<h3>Factory</h3>

<h4>FieldFactory</h4>
<pre>
public final class FieldFactory {
    public static FieldCreate getFieldCreate();
}
</pre>

<p>FieldFactory automatically creates a single instance of FieldCreate and
provides a method to get the interface.</p>

<h4>PVDataFactory</h4>
<pre>
public class PVDataFactory {
    public static PVDataCreate getPVDataCreate();
}
</pre>

<p>PVDataFactory automatically creates a single instance of PVDataCreate and
provides a method to get the interface.</p>

<h4>ConvertFactory</h4>
<pre>
public final class ConvertFactory {
    public static Convert getConvert();
}
</pre>

<p>ConvertFactory automatically creates a single instance of Convert and
provides a method to get the interface.</p>

<h4>StatusFactory</h4>
<pre>
public final class StatusFactory {
    public static StatusCreate getStatusCreate();
}
</pre>

<p>This provides a singleton that implements StatusCreate.</p>

<h4>StandardFieldFactory</h4>
<pre>
public final class StandardFieldFactory {
    public static StandardField getStandardField();
}
</pre>
<p>This provides a singleton that implements StandardField.</p>

<h4>StandardPVFieldFactory</h4>
<pre>
public final class StandardPVFieldFactory {
    public static StandardPVField getStandardPVField();
}
</pre>
<p>This provides a singleton that implements StandardPVField.</p>

<h3>Base Introspection Classes</h3>

<p>This section describes base classes for implementing Field instances , i.e.
introspection instances. For many applications they provide a complete
introspection implementation but they could be extended if necessary. </p>
<h4>BaseField</h4>
<pre>    
    public class BaseField implements Field {
        public BaseField(String fieldName, Type type);
        // all Field methods
    }
</pre>
<h4>BaseScalar</h4>
<pre>
    public class BaseScalar extends BaseField implements Scalar {
        public BaseScalar(String fieldName,ScalarType scalarType);
        // all Scalar methods
    }
</pre>
<h4>BaseStructure</h4>
<pre>
    public class BaseStructure extends BaseField implements Structure {
        public BaseStructure(String fieldName,Field[] field);
        // all Structure methods
    }
</pre>
<h4>BaseScalarArray</h4>
<pre>
    public class BaseScalarArray extends BaseField implements ScalarArray {
        public BaseScalarArray(String fieldName,ScalarType elementType);
        // all ScalarArray methods  
    }
</pre>
<h4>BaseStructureArray</h4>
<pre>
    public class BaseStructureArray extends BaseArray implements StructureArray {
        public BaseStructureArray(String fieldName,Field[] fields);
        // all StructureArray methods
    }
}</pre>

<h3>Abstract and Base Classes for PVField</h3>

<h4>BasePVAuxInfo</h4>

<p>This is a complete implementation of PVAuxInfo.</p>
<pre>public class BasePVAuxInfo implements PVAuxInfo {
    public BasePVAuxInfo(PVField pvField);
    // All PVAuxInfo methods
}</pre>

<h4>AbstractPVField</h4>

<p>This is an abstract base class for implementing PVField interfaces. It MUST
be the base class for any class that extends PVField. </p>
<pre>public abstract class AbstractPVField implements PVField{
    protected static Convert convert = ConvertFactory.getConvert();
    protected AbstractPVField(Field field);
    // All public methods of PVField
}</pre>

<p>The public methods are described in package org.epics.pvdata.pv. The
protected methods are: </p>
<dl>
  <dt>convert</dt>
    <dd>A convenience for derived classes since implementations often need
      access to the conversion facility.</dd>
  <dt>AbstractPVField</dt>
    <dd>The constructor which must be called by any derived class.</dd>
</dl>

<h3>Classes For PVStructure</h3>

<h4>BasePVStructure</h4>

<p>The following is a base class for any code that implements PVStructure. Any
code that implements PVStructure MUST extend this class.</p>
<pre>public class BasePVStructure extends AbstractPVField implements PVStructure
    public BasePVStructure(Structure structure);
    // all public methods of PVStructure
}</pre>

<h3>Classes For PVScalar</h3>

<h4>AbstractPVScalar</h4>

<p>The following is an abstract base class for implementing PVScalar. It MUST
be the base class for any code that implements an extension of PVScalar.</p>
<pre>public class AbstractPVScalar extends AbstractPVField implements PVScalar {
    protected AbstractPVScalar(Scalar scalar);
    public Scalar getScalar();
}</pre>

<h4>BasePVBoolean</h4>
<pre>public class BasePVBoolean extends AbstractPVScalar implements PVBoolean
{
    protected boolean value = false;
    public BasePVBoolean(Scalar scalar);
    // public methods of PVBoolean
}</pre>

<h4>BasePVByte</h4>
<pre>public class BasePVByte extends AbstractPVScalar implements PVByte
{
    protected byte value;
    public BasePVByte(Scalar scalar);
    // public methods of PVByte
}</pre>

<h4>BasePVShort</h4>
<pre>public class BasePVShort extends AbstractPVScalar implements PVShort
{
    protected short value;
    public BasePVShort(Scalar scalar);
    // public methods of PVShort
}</pre>

<h4>BasePVInt</h4>
<pre>public class BasePVInt extends AbstractPVScalar implements PVInt
{
    protected int value;
    public BasePVInt(Scalar scalar);
    // public methods of PVInt
}</pre>

<h4>BasePVLong</h4>
<pre>public class BasePVLong extends AbstractPVScalar implements PVLong
{
    protected long value;
    public BasePVLong(Scalar scalar);
    // public methods of PVLong
}</pre>
<h4>BasePVBUyte</h4>
<pre>public class BasePVUyte extends AbstractPVScalar implements PVUyte
{
    protected byte value;
    public BasePVUyte(Scalar scalar);
    // public methods of PVUyte
}</pre>

<h4>BasePVUShort</h4>
<pre>public class BasePVUhort extends AbstractPVScalar implements PVUhort
{
    protected short value;
    public BasePVUhort(Scalar scalar);
    // public methods of PVUhort
}</pre>

<h4>BasePVUInt</h4>
<pre>public class BasePVUnt extends AbstractPVScalar implements PVUnt
{
    protected int value;
    public BasePVUnt(Scalar scalar);
    // public methods of PVUnt
}</pre>

<h4>BasePVULong</h4>
<pre>public class BasePVUong extends AbstractPVScalar implements PVUong
{
    protected long value;
    public BasePVUong(Scalar scalar);
    // public methods of PVUong
}</pre>

<h4>BasePVFloat</h4>
<pre>public class BasePVFloat extends AbstractPVScalar implements PVFloat
{
    protected float value;
    public BasePVFloat(Scalar scalar);
    // public methods of PVFloat
}</pre>

<h4>BasePVDouble</h4>
<pre>public class BasePVDouble extends AbstractPVScalar implements PVDouble
{
    protected double value;
    public BasePVDouble(Scalar scalar);
    // public methods of PVDouble
}</pre>

<h4>BasePVString</h4>
<pre>public class BasePVString extends AbstractPVScalar implements PVString
{
    protected String value;
    public BasePVString(Scalar scalar);
    // public methods of PVString
}</pre>

<h3>Classes for PVArray</h3>

<h4>AbstractPVArray</h4>

<p>The following is a abstract class for creating array fields. Any code that
implements any extension of PVArray must extend this class.</p>
<pre>public abstract class AbstractPVArray extends AbstractPVField implements PVArray{
    protected int length = 0;
    protected int capacity;
    protected boolean capacityMutable = true;
    
    protected AbstractPVArray(Array array);
    abstract public void setCapacity(int capacity);
    // public methods of PVArray
}</pre>

<h4>AbstractPVScalarArray</h4>
<p>The following is an abstract class for creating scalar arrays.
All implementations of scalar arrays should extend this class.</p>
<pre>
public abstract class AbstractPVScalarArray
   extends AbstractPVArray implements PVScalarArray
{
    protected AbstractPVScalarArray(ScalarArray array);
    public ScalarArray getScalarArray();
}
</pre>
<p>For each ScalarType there is a base class for implementing the corresponding
array type. For most uses it is not necessary to extend these classes.</p>

<h4>BasePVBooleanArray</h4>
<pre>public class BasePVBooleanArray extends AbstractPVArray implements PVBooleanArray
{
    protected boolean[] value;
    // implements all PVBooleanArray methods
}</pre>

<h4>BasePVByteArray</h4>
<pre>public class BasePVByteArray extends AbstractPVArray implements PVByteArray
{
    protected byte[] value;
    // implements all PVByteArray methods
}</pre>

<h4>BasePVShortArray</h4>
<pre>public class BasePVShortArray extends AbstractPVArray implements PVShortArray
{
    protected short[] value;
    // implements all PVShortArray methods
}</pre>

<h4>BasePVIntArray</h4>
<pre>public class BasePVIntArray extends AbstractPVArray implements PVIntArray
{
    protected int[] value;
    // implements all PVIntArray methods
}</pre>

<h4>BasePVLongArray</h4>
<pre>public class BasePVLongArray extends AbstractPVArray implements PVLongArray
{
    protected long[] value;
    // implements all PVLongArray methods
}</pre>

<h4>BasePVUByteArray</h4>
<pre>public class BasePVUByteArray extends AbstractPVArray implements PVUByteArray
{
    protected byte[] value;
    // implements all PVUByteArray methods
}</pre>

<h4>BasePVUShortArray</h4>
<pre>public class BasePVUShortArray extends AbstractPVArray implements PVUShortArray
{
    protected short[] value;
    // implements all PVUShortArray methods
}</pre>

<h4>BasePVUIntArray</h4>
<pre>public class BasePVUIntArray extends AbstractPVArray implements PVUIntArray
{
    protected int[] value;
    // implements all PVUIntArray methods
}</pre>

<h4>BasePVULongArray</h4>
<pre>public class BasePVULongArray extends AbstractPVArray implements PVULongArray
{
    protected long[] value;
    // implements all PVULongArray methods
}</pre>

<h4>BasePVFloatArray</h4>
<pre>public class BasePVFloatArray extends AbstractPVArray implements PVFloatArray
{
    protected float[] value;
    // implements all PVFloatArray methods
}</pre>

<h4>BasePVDoubleArray</h4>
<pre>public class BasePVDoubleArray extends AbstractPVArray implements PVDoubleArray
{
    protected double[] value;
    // implements all PVDoubleArray methods
}</pre>

<h4>BasePVStringArray</h4>
<pre>public class BasePVStringArray extends AbstractPVArray implements PVStringArray
{
    protected String[] value;
    // implements all PVStringArray methods
}</pre>

<h4>BasePVStructureArray</h4>
<pre>public class BasePVStructureArray  extends AbstractPVArray implements PVStructureArray
{
   // implements all PVStructureArray methods
}</pre>

<h2 >Package org.epics.pvdata.property</h2>

<h3>Definition of Property</h3>

<p>Only fields named "value" have properties. A record can have multiple value
fields, which can appear in the top level structure of a record or in a
substructure. All other fields in the structure containing a value field are
considered properties of the value field. The fieldname is also the property
name. The value field can have any type, i.e. scalar, scalarArray, or
structure. Typical property fields are timeStamp, alarm, display, control, and
history. The timeStamp is a special case. If it appears anywhere in the
structure hieraracy above a value field it is a property of the value field.</p>

<p>For example the following top level structure has a single value field. The
value field has properties alarm, timeStamp, and display.</p>
<pre>
structure counterOutput
    double value
    alarm_t
        int severity 0
        int status 0
        string message
    double value
    display_t
        double limitLow 0.0
        double limitHigh 10.0
        string description "Sample Description"
        string format "%f"
        string units volts
</pre>

<p>The following example has three value fields each with properties alarm and
timeStamp. Voltage, Current, and Power each have a different alarms but all
share the timeStamp.</p>
<pre>structure powerSupplyValue
    double value
    alarm_t
        int severity 0
        int status 0
        string message

structure powerSupplySimple
    alarm_t
        int severity 0
        int status 0
        string message
    timeStamp_t
        long secondsPastEpoch
        int nanoSeconds
        int userTag
    powerSupplyValue_t voltage
        double value
        alarm_t
            int severity 0
            int status 0
            string message
    powerSupplyValue_t power
        double value
        alarm_t
            int severity 0
            int status 0
            string message
    powerSupplyValue_t current
        double value
        alarm_t
            int severity 0
            int status 0
            string message
</pre>

<h3>Standard Properties</h3>

<p>The following field names have special meaning, i.e. support properties for
general purpose clients.</p>
<dl>
  <dt>value</dt>
    <dd>This is normally defined since most general purpose clients access this
      field. All other fields in the structure support or describe the value
      field. The type can any supported type but is usually one of the
      following: 
      <dl>
        <dt>scalar</dt>
          <dd>Any of the scalar types.</dd>
        <dt>scalarArray</dt>
          <dd>An array with the elementType being a scalar type</dd>
        <dt>enumerated structure</dt>
          <dd>A structure that includes fields named index and
            choices. index is an int that selects a choice.
            choices is an array of strings that
            defines the complete set of choices.</dd>
        <dt>other</dt>
          <dd>Other structure or array types can also be defined if clients and
            support code agree on the meaning. Some examples are: 1) A
            structure defining a 2D matrix, 2) A structure defining an image,
            3) A structure that simulates a remote method, ...</dd>
      </dl>
    </dd>
  <dt>timeStamp</dt>
    <dd>The timeStamp. The type MUST be a timeStamp structure. Also if the
      PVData structure does not have a timeStamp then a search up the parent
      tree is made to find a timeStamp.</dd>
  <dt>alarm</dt>
    <dd>The alarm. The type MUST be an alarm structure. </dd>
  <dt>display</dt>
    <dd>A display structure as described below. It provides display
      characteristics for the value field.</dd>
  <dt>control</dt>
    <dd>A control structure as described below. It provides control
      characteristics for the value field.</dd>
  <dt>history</dt>
    <dd>Provides a history buffer for the value field. Note that currently
      PVData does not define history suppoprt.</dd>
  <dt>other</dt>
    <dd>Other standard properties can be defined.</dd>
</dl>

<p>In addition a structure can have additional fields that support the value
field but are not recognized by most general purpose client tools. Typical
examples are:</p>
<dl>
  <dt>input</dt>
    <dd>A field with support that changes the value field. This can be
      anything. It can be a channel access link. It can obtain a value from
      hardware. Etc.</dd>
  <dt>valueAlarm</dt>
    <dd>A field with support that looks for alarm conditions based on the
    value.</dd>
  <dt>output</dt>
    <dd>A field with support that reads the current value and sends it
      somewhere else. This can be anything. It can be a channel access link. It
      can write a value to hardware. Etc.</dd>
</dl>

<p>The model allows for device records. A device record has structure fields
that that support the PVData data model. For example a powerSupport record can
have fields power, voltage, current that each support the PVData data model.
</p>

<h3>PVProperty Interfaces and Classes</h3>
<h4>PVProperty</h4>
<p>Interface and factory for finding a field within a structure.</p>
<pre>
interface PVProperty {
    PVField findProperty(PVField pvField,String fieldName);
    PVField findPropertyViaParent(PVField pvField,String propertyName);
    String[] getPropertyNames(PVField pvField);
}
</pre>
where
<dl>
  <dt>findProperty</dt>
    <dd>Find a field that is a subfield or property of this PVField. The fieldName
    is of the form name.name... The pvField must be named value or it does not
    have properties. </dd>
  <dt>findPropertyViaParent</dt>
    <dd>Find a property by searching up the parent tree. The property name is
    expected to match the name of a field. The return value is the interface to
    the first field found that is not a null structure or null if not found.</dd>
  <dt>getPropertyNames</dt>
    <dd>Get a String array that holds the names of the properties for this field.</dd>
</dl>
<h4>PVPropertyFactory</h4>
<pre>
public class PVPropertyFactory {
     public static PVProperty getPVProperty();
}
</pre>

<h3>Standard Properties</h3>

<p>This section has structure definitions that support standard properties.
These definitions are defined in project javaIOC.</p>

<h4>timeStamp</h4>

<p>A timeStamp is represented by the following structure</p>
<pre>
structure timeStamp
    long secondsPartEpoch
    int nanoSeconds
    int userTag
</pre>

<p>The Epoch is the POSIX epoch, i.e. Jan 1, 1970 00:00:00 UTC. Both the
seconds and nanoSeconds are signed integers and thus can be negative. Since the
seconds is kept as a 64 bit integer, it allows for a time much greater than the
present age of the universe. Since the nanoSeconds portion is kept as a 32 bit
integer it is subject to overflow if a value that corresponds to a value that
is greater than a little more than 2 seconds of less that about -2 seconds. The
support code always adjust seconds so that the nanoSecconds part is normalized,
i. e. it has is 0&lt;=nanoSeconds&lt;nanoSecPerSec..</p>
<h5>TimeStamp</h5>
<p>The Java definition of a timeStamp is:</p>
<pre>interface TimeStamp {
    static final long milliSecPerSec = 1000;
    static final long microSecPerSec = milliSecPerSec*milliSecPerSec;
    static final long nanoSecPerSec = milliSecPerSec*microSecPerSec;
    static final long  posixEpochAtEpicsEpoch = 631152000;
    void normalize();
    long getSecondsPastEpoch();
    long getEpicsSecondsPastEpoch();
    int getNanoSeconds();
    int getUserTag();
    void setUserTag(int userTag);
    void put(long secondsPastEpoch,int nanoSeconds);
    long getMilliSeconds();
    void put(long milliSeconds);
    void getCurrentTime();
    boolean equals(TimeStamp other);
    boolean lt(TimeStamp other);
    boolean le(TimeStamp other);
    void add(long seconds);
    void add(double seconds);
    double diff(TimeStamp a,TimeStamp b);
}</pre>

<p>where:</p>
<dl>
  <dt>normalize</dt>
    <dd>Adjust secondsPastEpoch and nanoSeconds so that 0&lt;=nanoSeconds&lt;
      nanoSecPerSec.</dd>
  <dt>getSecondsPastEpoch</dt>
    <dd>Get the seconds part of timeStamp</dd>
  <dt>getEpicsSecondsPastEpoch</dt>
    <dd>Get seconds relative to the EPICS epoch. The epics epoch starts on Jan
      1 1990 00:00:00 UTC.</dd>
  <dt>getNanoSeconds</dt>
    <dd>Get the nanoSeconds part of timeStamp.</dd>
  <dt>getUserTag</dt>
    <dd>Get the userTag</dd>
  <dt>setUserTag</dt>
    <dd>Set the userTag</dd>
  <dt>put(long secondsPastEpoch,int nanoSeconds)</dt>
    <dd>Put a value into the timeStamp.</dd>
  <dt>getMilliSeconds</dt>
    <dd>Get bthe number of milliseconds since the epoch.</dd>
  <dt>put(long milliSeconds);</dt>
    <dd>Put a value into the timeStamp given the number of milliSeconds since
      the epoch.</dd>
  <dt>getCurrentTime</dt>
    <dd>Get the curent time.</dd>
  <dt>equals</dt>
    <dd>Is this time equal other?</dd>
  <dt>lt</dt>
    <dd>Is this time less than other.</dd>
  <dt>le</dt>
    <dd>Is this time less that or equal to other.</dd>
  <dt>add(long seconds)</dt>
    <dd>Add the specified number of seconds.</dd>
  <dt>add(double seconds)</dt>
    <dd>Add the specified number of seconds.</dd>
  <dt>diff</dt>
    <dd>Compute a-b. The result is in seconds.</dd>
</dl>

<p>The TimeStamp class provides arithmetic and comparison methods for time
stamps. The result is always kept in normalized form, which means that the nano
second portion is 0&le;=nano&lt;nanoSecPerSec. Note that it is OK to have
timeStamps for times previous to the epoch.</p>
<h5>TimeStampFactory</h5>
<pre>
class TimeStampFactory implements TimeStamp {
    public static TimeStamp create();
}
</pre>
<h5>PVTimeStamp</h5>
<pre>
interface PVTimeStamp {
    boolean attach(PVField pvField);
    void detach();
    boolean isAttached();
    void get(TimeStamp timeStamp);
    boolean set(TimeStamp timeStamp);
}
</pre>
where
<dl>
  <dt>attach</dt>
    <dd>Attempts to attach to <span
     >pvField</span> It returns (false,true) if a
      timeStamp structure is found. It looks first at pvField itself and if is
      not an appropriate pvData structure but the field name is value it looks
      up the parent structure tree.</dd>
  <dt>detach</dt>
    <dd>Detach from the pvData structure.</dd>
  <dt>isAttached</dt>
    <dd>Is there an attachment to a timeStamp structure?</dd>
  <dt>get</dt>
    <dd>Copies data from the pvData structure to a TimeStamp. An exception is
      thrown if not attached to a pvData structure. </dd>
  <dt>set</dt>
    <dd>Copies data from TimeStamp to the pvData structure. An exception is
      thrown if not attached to a pvData structure. </dd>
</dl>
<h5>PVTimeStampFactory</h5>
<pre>
class PVTimeStampFactory implements PVTimeStamp {
    public static PVTimeStamp create();
}</pre>

<h4>alarm</h4>

<p>An alarm structure is defined as follows:</p>
<pre>
structure alarm
    int severity
    int status
    string message
</pre>

<p>Note that severity and status are NOT defined as enumerated structures.
The reason is performance, i. e. prevent passing the array of choice strings everywhere.
The AlarmStatus and AlarmSeverity provide the equivalent of choices for an
enumerated structure.</p>
<h5>AlarmSeverity</h5>
<p>Alarm Severity defines the possible alarm severities</p>
<pre>
enum AlarmSeverity {
 NONE,MINOR,MAJOR,INVALID,UNDEFINED;

    public static AlarmSeverity getSeverity(int value);
    private static final String[] alarmSeverityNames;
    public static String[] getSeverityNames() { return alarmSeverityNames;}
}
</pre>
where
<dl>
  <dt>getSeverity</dt>
    <dd>Get the alarm severity corresponding to the integer value.</dd>
  <dt>getSeverityNames</dt>
    <dd>Get the array of severity choices.</dd>
</dl>
<h5>AlarmStatus</h5>
<p>Alarm Status defines the possible alarm status conditions</p>
<pre>
enum AlarmStatus {
    NONE,DEVICE,DRIVER,RECORD,DB,CONF,UNDEFINED,CLIENT;

    public static AlarmStatus getStatus(int value);
    private static final String[] alarmStatusNames;
    public static String[] getStatusNames() { return alarmStatusNames;}
}
</pre>
where
<dl>
  <dt>getStatus</dt>
    <dd>Get the alarm status corresponding to the integer value.</dd>
  <dt>getStatusNames</dt>
    <dd>Get the array of status choices.</dd>
</dl>
<h5>Alarm</h5>
<pre>
class Alarm {
    public Alarm();
    public String getMessage();
    public void setMessage(String message);
    public AlarmSeverity getSeverity();
    public void setSeverity(AlarmSeverity alarmSeverity);
    public AlarmStatus getStatus();
    public void setStatus(AlarmStatus alarmStatus);
}</pre>
where
<dl>
  <dt>Alarm</dt>
    <dd>The constructor. It sets the severity to no alarm and the message to
    "".</dd>
  <dt>getMessage</dt>
    <dd>Get the message.</dd>
  <dt>setMessage</dt>
    <dd>Set the message.</dd>
  <dt>getSeverity</dt>
    <dd>Get the severity.</dd>
  <dt>setSeverity</dt>
    <dd>Set the severity.</dd>
  <dt>getStatus</dt>
    <dd>Get the status.</dd>
  <dt>setStatus</dt>
    <dd>Set the status.</dd>
</dl>

<h5>PVAlarm</h5>
<pre>interface PVAlarm {
    boolean attach(PVField pvField);
    void detach();
    boolean isAttached();
    void get(Alarm alarm);
    boolean set(Alarm alarm);
}
</pre>
<p>where</p>
<dl>
  <dt>PVAlarm</dt>
    <dd>The default constructor. Attach must be called before get or set can be
      called.</dd>
  <dt>attach</dt>
    <dd>Attempts to attach to <span
     >pvField</span> It returns (false,true) if
      it found an appropriate pvData structure. It looks first a pvField itself
      and if is not an appropriate pvData structure but the field name is value
      it looks to see if the parent structure has an appropriate sub
    structure.</dd>
  <dt>detach</dt>
    <dd>Just detaches from the pvData structure.</dd>
  <dt>isAttached</dt>
    <dd>Is there an attachment to an alarm structure?</dd>
  <dt>get</dt>
    <dd>Copies data from the pvData structure to an Alarm. An exception is
      thrown if not attached to a pvData structure. </dd>
  <dt>set</dt>
    <dd>Copies data from Alarm to the pvData structure. An exception is thrown
      if not attached to a pvData structure. </dd>
</dl>
<h5>PVAlarmFactory</h5>
<pre>
class PVAlarmFactory implements PVAlarm{
    public static PVAlarm create();
}</pre>

<h4>control</h4>

<p>Control information is represented by the following structure</p>
<pre>
structure control
    double limitLow
    double limitHigh
    double minStep
</pre>
<h5>Control</h5>
The java definition for Control is: 
<pre>class Control {
    Control();
    double getLow();
    double getHigh();
    void setLow(double value);
    void setHigh(double value);
}</pre>

<p>where</p>
<dl>
  <dt>Control</dt>
    <dd>The default constructure.</dd>
  <dt>getLow</dt>
    <dd>Get the low limit.</dd>
  <dt>getHigh</dt>
    <dd>Get the high limit.</dd>
  <dt>setLow</dt>
    <dd>Set the low limit.</dd>
  <dt>setHigh</dt>
    <dd>Set the high limit.</dd>
</dl>

<h5>PVControl</h5>
<pre>interface PVControl {
    boolean attach(PVField pvField);
    void detach();
    boolean isAttached();
    void get(Control control);
    boolean set(Control control);
}
</pre>
<p>where</p>
<dl>
  <dt>attach</dt>
    <dd>Attempts to attach to <span
     >pvField</span> It returns (false,true) if
      it found an appropriate pvData structure. It looks first a pvField itself
      and if is not an appropriate pvData structure but the field name is value
      it looks to see if the parent structure has an appropriate sub
    structure.</dd>
  <dt>detach</dt>
    <dd>Just detaches from the pvData structure.</dd>
  <dt>isAttached</dt>
    <dd>Is there an attachment to a control structure?</dd>
  <dt>get</dt>
    <dd>Copies data from the pvData structure to a Control. An exception is
      thrown if not attached to a pvData structure. </dd>
  <dt>set</dt>
    <dd>Copies data from Control to the pvData structure. An exception is
      thrown if not attached to a pvData structure. </dd>
  <dt>create</dt>
    <dd>Create a PVControl instance. Attach must be called before get or set
      can be called.</dd>
</dl>
<h5>PVControlFactory</h5>
<pre>
class PVControlFactory{
    public static PVControl create();
}</pre>

<h4>Display</h4>

<p>Display information is represented by the following structure</p>
<pre>
structure display
    double limitLow
    double limitHigh
    string description
    string format
    string units
</pre>
<h5>Display</h5>
<pre>class Display {
    Display();
    double getLow();
    double getHigh();
    void setLow(double value);
    void setHigh(double value);
    String getDescription();
    void setDescription(String value);
    String getFormat();
    void setFormat(String value);
    String getUnits();
    void setUnits(String value);
}</pre>

<p>where</p>
<dl>
  <dt>Control</dt>
    <dd>The default constructure.</dd>
  <dt>getLow</dt>
    <dd>Get the low limit.</dd>
  <dt>getHigh</dt>
    <dd>Get the high limit.</dd>
  <dt>setLow</dt>
    <dd>Set the low limit.</dd>
  <dt>setHigh</dt>
    <dd>Set the high limit.</dd>
  <dt>getDescription</dt>
    <dd>Get the description.</dd>
  <dt>setDescription</dt>
    <dd>Set the description.</dd>
  <dt>getFormat</dt>
    <dd>Get the format.</dd>
  <dt>setFormat</dt>
    <dd>Set the format.</dd>
  <dt>getUnits</dt>
    <dd>Get the units.</dd>
  <dt>setUnits</dt>
    <dd>Set the units.</dd>
</dl>

<h5>PVDisplay</h5>
<pre>interface PVDisplay {
    boolean attach(PVField pvField);
    void detach();
    boolean isAttached();
    void get(Display display);
    boolean set(Display display);
}
</pre>

<p>where</p>
<dl>
  <dt>attach</dt>
    <dd>Attempts to attach to <span
     >pvField</span> It returns (false,true) if
      it found an appropriate pvData structure. It looks first a pvField itself
      and if is not an appropriate pvData structure but the field name is value
      it looks to see if the parent structure has an appropriate sub
    structure.</dd>
  <dt>detach</dt>
    <dd>Just detaches from the pvData structure.</dd>
  <dt>isAttached</dt>
    <dd>Is there an attachment to a display structure?</dd>
  <dt>get</dt>
    <dd>Copies data from the pvData structure to a Display. An exception is
      thrown if not attached to a pvData structure.</dd>
  <dt>set</dt>
    <dd>Copies data from Display to the pvData structure. An exception is
      thrown if not attached to a pvData structure. </dd>
  <dt>create</dt>
    <dd>Create a PVDisplay instance. Attach must be called before get or set
      can be called.</dd>
</dl>
<h5>PVDisplayFactory</h5>
<pre>
class PVDisplayFactory implements PVDisplay{
    public static PVDisplay create()
}</pre>

<h4>enumerated structure</h4>

<p>An enumerated structure is a structure that has fields:</p>
<pre>structure
    int index
    string[] choices</pre>

<h5>PVEnumerated</h5>
<pre>interface PVEnumerated {
    boolean attach(PVField pvField);
    void detach();
    boolean isAttached();
    boolean setIndex(int index);
    int getIndex();
    String getChoice();
    boolean choicesMutable();
    String[] getChoices();
    boolean setChoices(String[] choices);
}
</pre>

<p>where</p>
<dl>
  <dt>PVEnumerated</dt>
    <dd>The default constructor. Attach must be called before any get or set
      method can be called.</dd>
  <dt>attach</dt>
    <dd>Attempts to attach to <span
     >pvField</span> It returns (false,true) if
      pvField (is not, is) an enumerated structure.</dd>
  <dt>detach</dt>
    <dd>Just detaches from the pvData structure.</dd>
  <dt>isAttached</dt>
    <dd>Is there an attachment to an enemerated structure?</dd>
  <dt>setIndex</dt>
    <dd>Set the index field in the pvData structure. An exception is thrown if
      not attached to a pvData structure. </dd>
  <dt>getIndex</dt>
    <dd>Get the index field in the pvData structure. </dd>
  <dt>getChoice</dt>
    <dd>Get the String value corresponding to the current index field in the
      pvData structure. An exception is thrown if not attached to a pvData
      structure. </dd>
  <dt>choicesMutable</dt>
    <dd>Can the choices be changed? Note that this is often true. An exception
      is thrown if not attached to a pvData structure. </dd>
  <dt>getChoices</dt>
    <dd>Get the array of choices. An exception is thrown if not attached to a
      pvData structure. </dd>
  <dt>getNumberChoices</dt>
    <dd>Get the number of choices. An exception is thrown if not attached to a
      pvData structure. </dd>
  <dt>setChoices</dt>
    <dd>Change the choices. An exception is thrown if not attached to a pvData
      structure. </dd>
</dl>

<h5>PVEnumeratedFactory</h5>
<pre>
class PVEnumeratedFactory{
    PVEnumerated create();
}</pre>
<h3>multiChoice</h3>

<p>NOTE: This is not currently used by anything.
Bob sees it as an important facility in the future.
</p>
<p>MultiChoice is support for a multiChoice structure,
which is a structure containing two fields:</p>
<dl>
   <dt>choices</dt>
     <dd>An array of strings</dd>
   <dt>bitMask</dt>
     <dd>A bitMask that selects a subset of the choices.</dd>
</dl>

<h4>MultiChoice</h4>
<pre>
    public interface MultiChoice {
        interface Choices {
            String[] getChoices();
            int getNumberChoices();
        }
        byte[] getBitMask();
        String[] getChoices();
        Choices getSelectedChoices();
        void setBit(int index);
        void clear();
        int registerChoice(String choice);
    }
</pre>
<p>where</p>
<dl>
  <dt>getBitMask</dt>
    <dd>Returns the bitMask.</dd>
  <dt>getChoices</dt>
    <dd>Returns the complete set of choices..</dd>
  <dt>getSelectedChoices</dt>
    <dd>Returns the interface for getting the selected choices..</dd>
  <dt>setBit</dt>
    <dd>Select the choice for specified bit..</dd>
  <dt>clear</dt>
    <dd>Clear the bitMask, i.e. no choices are selected..</dd>
  <dt>registerChoice</dt>
    <dd>Register a new choice. If thed choice already exists then it''s index
      is returned. If not it is appended to the choices.</dd>
</dl>
<h4>MultiChoiceFactory</h4>
<pre>
    public class MultiChoiceFactory{
         public static MultiChoice getMultiChoice(PVField pvField);
    }
</pre>

<h2 >Package org.epics.pvdata.misc</h2>

<h3>Overview</h3>

<p>This package provides utility code:</p>
<dl>
  <dt>BitSet</dt>
    <dd>An implementation of BitSet that can be serialized.</dd>
  <dt>MessageQueue</dt>
    <dd>Support for queuing messages for requesters.</dd>
  <dt>Thread</dt>
    <dd>ThreadCreate and Executor</dd>
  <dt>TimeFunction</dt>
    <dd>Time how long a function call requires.</dd>
  <dt>LinkedList</dt>
    <dd>A douuble linked list facility that requires the user to allocate a
      node. It is more efficient that ArrayList and does not require the
      implementation to allocate storage for the nodes.</dd>
  <dt>Timer</dt>
    <dd>An implementation of Timer that does not require an object to be
      created for each timer request.</dd>
  <dt>Queue</dt>
    <dd>A queue implementation.</dd>
  <dt>Destroyable</dt>
    <dd>A base interface for destroy.</dd>
  <dt>Serialize</dt>
    <dd>A helper for serialization.</dd>
</dl>


<h3>bitSet</h3>
<h4>BitSet</h4>
<p>This is adapted from the java.util.BitSet. It adds serializable. See
java.util.BitSet for a description. This implementation adds the following
additional methods:</p>
<pre>    public boolean getAndSet(int bitIndex);
    public void set(BitSet src);
    public void or_and(BitSet set1, BitSet set2);</pre>

<p>where</p>
<dl>
  <dt>getAndSet</dt>
    <dd>gets and sets the bit at bitIndex.</dd>
  <dt>set</dt>
    <dd>fast copy operation from src to this bitSet</dd>
  <dt>or_and</dt>
    <dd>The result is the or of the current bitSet with the value of set1.and
      set2. The number of bits is the
    Math.max(set1.bitsInUse,set2.bitsInUse);</dd>
</dl>

<p>This is an implementation of BitSet that supports serialization, which the
standard Jave implementation does not allow.</p>

<h4>BitSetUtil</h4>
<pre>interface BitSetUtil {
    boolean compress(BitSet bitSet,PVStructure pvStructure);
}
</pre>

<p>This provides functions that operate of a BitSet for a PVStructure. It
currently has only one method:</p>
<dl>
  <dt>compress</dt>
    <dd>Compress the bits in a BitSet related to a structure.<br />
      For each structure: 
      <ol>
        <li>If the bit for the structure is set then the bit for all subfields
          of the structure are cleared. </li>
        <li>If the bit for the structure is not set but all immediate subfields
          have their bit set then the bit for the structure is set and the bits
          for all subfields are cleared. </li>
      </ol>
      Note that this is a recursive algorithm. That is if every immediate
      subfield has it's offset bit set then the bits for ALL fields that reside
      in the structure will be cleared.</dd>
    <dd>Channel Access can call this before sending data. It can then pass
      entire structures if the structure offset bit is set. </dd>
</dl>
<h4>BitSetUtilFactory</h4>
<pre>
class BitSetUtilFactory {
    public static BitSetUtil getCompressBitSet();
}</pre>

<h3>message Queue</h3>

<h4>MessageNode</h4>
<pre>
public class MessageNode {
    public String message;
    public MessageType messageType;
}
</pre>
<h4>MessageQueue</h4>
<pre>
public interface MessageQueue {
    MessageNode get();
    boolean put(String message,MessageType messageType,boolean replaceLast);
    boolean isEmpty();
    boolean isFull();
    int getClearOverrun();
}
</pre>
<p>This is for use by code that wants to handle messages without blocking
higher priority threads.</p>

<p>A messageNode is a class with two public data members:</p>
<dl>
  <dt>message</dt>
<dd>The message.</dd>
  <dt>messageType</dt>
<dd>The message type.</dd>
</dl>

<p>A messageQueue is an interface with methods:</p>
<dl>
  <dt>put</dt>
<dd>Put a new message into the queue. False is returned if the queue was
  full and true otherwise.</dd>
  <dt>isEmpty</dt>
<dd>Is the queue empty?</dd>
  <dt>isFull</dt>
<dd>Is the queue full?</dd>
  <dt>getClearOverrun</dt>
<dd>Get the number of times replaceFirst or replaceLast have been called
  since the last call to getClearOverrun. The internal counter is reset to
  0.</dd>
</dl>
<h4>MessageQueueFactory</h4>
<pre>
public class MessageQueueFactory {
    public static MessageQueue create(int size);
}</pre>
where
<dl>
  <dt>create</dt>
    <dd>Create a MessageQueue and return the interface.</dd>
</dl>

<h3>thread</h3>

<h4>ThreadPriority</h4>
<pre>
public enum ThreadPriority {
    lowest,
    lower,
    low,
    middle,
    high,
    higher,
    highest;
    
    public static final int[] javaPriority;
    public int getJavaPriority();
    public static int getJavaPriority(ThreadPriority threadPriority);
}
</pre>

<h4>ThreadReady</h4>
<pre>
interface ThreadReady {
    void ready();
}
</pre>
<h4>RunnableReady</h4>
<pre>
interface RunnableReady {
    void run(ThreadReady threadReady);
}
</pre>
<h4>ThreadCreate</h4>
<pre>
interface ThreadCreate {
    Thread create(String name, int priority, RunnableReady runnableReady);
    Thread[] getThreads();
}
</pre>
<h4>ThreadCreateFactory</h4>
<pre>
public class ThreadCreateFactory {
    public static ThreadCreate getThreadCreate();
}</pre>

<p>ThreadCreate provides two features:</p>
<ol>
  <li>Create does not return until ReadyRunnable.run calls
  ThreadReady.ready().</li>
  <li>A list of all active threads is kept. getThreads provides access to the
list.</li>
</ol>

<h4>executor</h4>

<p>An Executor is a thread that can execute any object that implements the Java
Runnable interface. The user can request that a single command be executed. If
the command is already in the list of commands to be executed it is NOT added
to the list when add is called.</p>
<h5>ExecutorNode</h5>
<pre>
public interface ExecutorNode {}
</pre>
<h5>Executor</h5>
<pre>
public interface Executor {
    ExecutorNode createNode(Runnable command);
    void execute(ExecutorNode executorNode);
    void stop();
}
</pre>
<h5>ExecutorFactory</h5>
<pre>
public class ExecutorFactory {
    static public Executor create(String name,ScanPriority priority);
}</pre>
where 
<dl>
  <dt>createNode</dt>
<dd>Create a ExecutorNode that can be passed to execute.</dd>
  <dt>execute</dt>
<dd>Request that command be executed. If it is already on the run list
  nothing is done.</dd>
  <dt>stop</dt>
<dd>Stop the thread and refuse additional execute requests.</dd>
</dl>

<h3>time a function call</h3>

<p>TimeFunction is a facility that measures the average number of seconds a
function call requires. When timeCall is called, it calls function in a loop.
It starts with a loop of one iteration. If the total elapsed time is less then
.1 seconds it increases the number of iterrations by a factor of 10. It keeps
repeating until the elapsed time is greater than .1 seconds. It returns the
average number of seconds per call.</p>
<h4>TimeFunctionRequester</h4>
<pre>
public interface TimeFunctionRequester {
    void function();
}
</pre>
<h4>TimeFunction</h4>
<pre>
public interface TimeFunction {
    double timeCall();
}
</pre>
<h4>TimeFunctionFactory</h4>
<pre>
public class TimeFunctionFactory {
    public static TimeFunction create(TimeFunctionRequester requester);
}</pre>

<h3>linked list</h3>

<p>LinkedList implements a double linked list that requires a user to allocate
the nodes. It is more efficent that ArrayList for implementing stacks and
queues. For lists that are traversed while new elements can be added or
removed, LinkedListArray provides a way to get an array of the currrent
elements without allocating a new array each time the array is traversed.</p>

<p>LinkedListArray converts a LinkedList to an LinkNode array. The
implementation provided by LinkedListFactory only creates a new LinkNode array
w.en the number of elements in the linkedList passed to setNodes is greater
than the length of the current LinkNode array.</p>
<h4>LinkedListNode</h4>
<pre>
public interface LinkedListNode&lt;T&gt; {
    public T getObject();
    boolean isOnList();
} 
</pre>
<h4>LinkedList</h4>
<pre>
public interface LinkedList {
    void addTail(LinkedListNode&lt;T&gt; listNode);
    void addHead(LinkedListNode&lt;T&gt; listNode);
    void insertAfter(LinkedListNode&lt;T&gt; listNode,LinkedListNode&lt;T&gt; addNode);
    void insertBefore(LinkedListNode&lt;T&gt; listNode,LinkedListNode&lt;T&gt; addNode);
    LinkedListNode&lt;T&gt; removeTail();
    LinkedListNode&lt;T&gt; removeHead();
    void remove(LinkedListNode&lt;T&gt; listNode);
    void remove(T object);
    LinkedListNode&lt;T&gt; getHead();
    LinkedListNode&lt;T&gt; getTail();
    LinkedListNode&lt;T&gt; getNext(LinkedListNode&lt;T&gt; listNode);
    LinkedListNode&lt;T&gt; getPrev(LinkedListNode&lt;T&gt; listNode);
    boolean isEmpty();
    boolean contains(T object);
}
</pre>
<h4>LinkedListArray</h4>
<pre>
public interface LinkedListArray&lt;T&gt; {
    void setNodes(LinkedList&lt;T&gt; linkedList);
    LinkedListNode&lt;T&gt;[] getNodes();
    int getLength();
    void clear();
}
</pre>
<h4>LinkedListCreate</h4>
<pre>
public class LinkedListCreate&lt;T&gt; {
    public static LinkedList&lt;T&gt; create();
    public static LinkedListNode&lt;T&gt; createNode(Object object);
    public static LinkedListArray&lt;T&gt; createArray();
}</pre>

<p>LinkedListCreate is created as follows:</p>
<pre>
LinkedListCreate&lt;SomeObject&gt; linkedListCreate = new LinkedListCreate&lt;SomeObject&gt;();</pre>

<p>Then a linked list can be created as follows:</p>
<pre>
LinkedList&lt;SomeObject&gt; linkedList = linkedListCreate.create();</pre>

<p>The only way a node can be allocated is by calling
linkedListCreate.createNode(SomeObject object). The object passed to createNode
is what is returned by LinkedList.getObject. For example:</p>
<pre>
private static class SomeObject {
    private LinkedListNode&lt;SomeObject&gt; listNode = null;
    // other definitions


    private Node(/* arguments*/) {
        listNode = linkedListCreate.createNode(this);
    }

    LinkedListNode&lt;SomeObject&gt; getListNode() {return listNode};
}

// then

SomeObject someObject = new SomeObject(/* args */);
linkedList.addTail(someObject);</pre>

<p>A node can only be on one list at a time but can be put, at different times,
on different lists as long as they all hold the same type of objects.</p>

<p>The class does not provide a lock but the user can synchronized via calls
like:</p>
<pre>
synchronized(linkedList) {
    linkedList.addTail(listNode);
}</pre>

<p>The following is an example of how to use LinkedListArray.</p>
<pre>
    LinkedListNode&lt;SomeObject&gt;[] nodes = null;
    int length = 0;
    synchronized(linkedList) {
        linkedListArray.setNodes(linkedList);
        nodes = linkedListArray.getNodes();
        length = linkedListArray.getLength();
    }
    for(int i=0; i&lt;length; i++) {
        SomeObject object = nodes[i].getObject();
        // do something with object
    }</pre>

<h3>timer</h3>

<p>This provides a general purpose timer. It provides the following features
not provided by java.util.Timer and java.util.TimerTask:</p>
<ol>
  <li>Priority<br />
    The java.util implementation does not allow the user to specify the
    priority of the timer thread. This implementation does.</li>
  <li>TimerNode<br />
    A java.util.TimerTask is not reusable. Once a timerTask has been canceled
    or a delay timerTask has run, the TimerTask can not be reused. Instead a
    new TimerTask must be created. A TimerNode can be reused.</li>
</ol>

<h4>Timer</h4>
<pre>
interface Timer {
    interface TimerCallback {
        void callback();
        void timerStopped();
    }
    interface TimerNode {
        void cancel();
        boolean isScheduled();
    }
    void scheduleAfterDelay(TimerNode timerNode,double delay);
    void schedulePeriodic(TimerNode timerNode,double delay,double period);
    void stop();
}
</pre>
<p>This is the interface for scheduling a timer callback. A timer is created by
calling TimerFactory.create. It has the methods:</p>
<dl>
  <dt>scheduleAfterDelay</dt>
    <dd>A request to schedule a callback after a delay specified in seconds. If
      stop has been called then TimerCallback.timerStopped is called
      immediately.</dd>
  <dt>schedulePeriodic</dt>
    <dd>Schedule a periodic callback. If stop has been called then
      TimerCallback.timerStopped is called immediately.</dd>
  <dt>stop</dt>
    <dd>Stop the timer. The queue is emptied and TimerCallback.timerStopped is
      called for each element of the queue. Further schedule calls result in a
      call to TimerCallback.timerStopped. Once stopped a timer is no longer
      useful. A new timer must be created.</dd>
</dl>
<h4>TimerFactory</h4>
<pre>
class TimerFactory {
    static public Timer create(String threadName, ThreadPriority priority);
    static public TimerNode createNode(TimerCallback timerCallback);
}</pre>
<p>This is the factory that implements the Timer and TimerNode interfaces. It
has the methods:</p>
<dl>
  <dt>create</dt>
    <dd>Create a new Timer.</dd>
  <dt>createNode</dt>
    <dd>Create a TimerNode. A timerNode can be used to schedule any timer but a
      timeNode can only be on a single timer queue and only once on a given
      timer queue.</dd>
</dl>

<h4>TimerCallback</h4>

<p>This is an interface that must be implemented by the user. It has the
following methods: </p>
<dl>
  <dt>callback</dt>
    <dd>This is called when a timer expires. This is called with no locks held.
      When called a delay timer is no longer on the queue but a periodioc timer
      is on a queue. Thus the callback for a delay timer can issue a new
      schedule request but a periodic timer must not. Note the explaination of
      TimerNode.cancel below.</dd>
  <dt>timerStopped</dt>
    <dd>Timer.stop was called when a timer request was queued. or if the timer
      is stopped and a schedule request is made.</dd>
</dl>

<h4>TimerNode</h4>

<p>This is an interface implemented by TimerFactory. It is allocated by calling
TimerFactory.createNode. It is passed as an argument when scheduling a
callback. It has the single method:</p>
<dl>
  <dt>cancel</dt>
    <dd>This is called to cancel a timer request. If a callback has been
      dequeued but the callback not called when cancel is called then a
      callback may still happen. New schedule requests can be made after a
      cancel request has been made.</dd>
  <dt>isScheduled</dt>
    <dd>Is this node in the timerQueue.</dd>
</dl>

<h3>queue</h3>

<p>This provides a queue which has an immutable capacity, which is specified
when the queue is created. When the queue is full the user code is expected to
keep using the current el;ement until a new free element becomes avalable. This
is used by pvData.monitor.</p>
<h4>QueueCreate</h4>
<pre>
public class QueueCreate&lt;T&gt; {
    public Queue&lt;T&gt; create(QueueElement&lt;T&gt;[] queueElements) {
        return new QueueImpl&lt;T&gt;(queueElements);
    }

    public QueueElement&lt;T&gt; createQueueElement(T object) {
        return new QueueElementImpl&lt;T&gt;(object);
    }
}
</pre>
<h4>QueueElement</h4>
<pre>
public interface QueueElement&lt;T&gt; {
    public T getObject();
}
</pre>
<h4>Queue</h4>
<pre>
public interface Queue&lt;T&gt; {
    void clear();
    int getNumberFree();
    int capacity();
    QueueElement&lt;T&gt; getFree();
    void setUsed(QueueElement&lt;T&gt; queueElement);
    QueueElement&lt;T&gt; getUsed();
    void releaseUsed(QueueElement&lt;T&gt; queueElement);
}</pre>

<p>The queue methods are:</p>
<dl>
  <dt>clear</dt>
    <dd>Make the queue empty.</dd>
  <dt>getNumberFree</dt>
    <dd>Get the number of fee elements in the queue.</dd>
  <dt>capacity</dt>
    <dd>Get the capacity, i.e. the maximun number of elements the queue can
      hold.</dd>
  <dt>getFree</dt>
    <dd>Get the next free element. Null is returned if no free elements are
      available. If a non null value is returned then the element belongs to
      the caller until setUsed is called.</dd>
  <dt>setUsed</dt>
    <dd>Set a queue element used. This <span
      style="font-weight:bold;">must</span> be the element returned by the last
      call to getFree. </dd>
  <dt>getUsed</dt>
    <dd>Get the next used element of null if no more used elements are
      available.</dd>
  <dt>releaseUsed</dt>
    <dd>Set a queue element free. This must be the element returned by the last
      call to getUsed. </dd>
</dl>

<p>A queueCreate instance is created via a call like the following:</p>
<pre> QueueCreate&lt;MyObject&gt; queueCreate = new QueueCreate&lt;MyObject&gt;();</pre>

<p>Once a queueCreate is available a queue instance is created via code like
the following:</p>
<pre>Queue&lt;MyObject&gt; queue create(MyObject[] myObjects) {
    QueueElement&lt;MyObject&gt;[] queueElements = new QueueElement[length];
    for(int i=0; i&lt;length; i++) {
        QueueElement&lt;MonitorElement&gt; queueElement =
                 queueCreate.createQueueElement(myObjects[i);
        queueElements[i] = queueElement;
    }
    return queueCreate.create(queueElements);
}</pre>

<p>A producer calls getFree and setUsed via code like the following:</p>
<pre>
   MyObject getFree() {
       QueueElement&lt;MyObject&gt; queueElement = queue.getFree();
       if(queueElement==null) return null;
       return queueElement.getObject();
  }</pre>

<p>A consumer calls getUsed and releaseUsed via code like the following:</p>
<pre>
     while(true) {
         QueueElement&lt;MyObject&gt; queueElement = queue.getUsed();
         if(queueElement==null) break;
         MyObject myObject = queueElement.getObject();
         // do something with myObject
         queue.releaseUsed(queueElement);
     }</pre>

<h3>Destroyable</h3>

<p>This is a base interface used by many other interfaces.</p>
<pre>interface Destroyable  {
    void destroy();
}</pre>

<p>where</p>
<dl>
  <dt>destroy</dt>
    <dd>Destroy the object.</dd>
</dl>

<h3>SerializeHelper</h3>

<p>This is a helper class for serialization, which is required for sending and
receiving pvData over the nerwork.</p>
<pre>class SerializeHelper {
    static void writeSize(final int s, ByteBuffer buffer);
    static int readSize(ByteBuffer buffer);
    static void serializeString(final String value, ByteBuffer buffer);
    static void serializeSubstring(final String value,
         int offset, int length, ByteBuffer buffer);
    static String deserializeString(ByteBuffer buffer);
}</pre>

<p>where</p>
<dl>
  <dt>writeSize</dt>
    <dd>Serialize the size.</dd>
  <dt>readSize</dt>
    <dd>Deserialize the size.</dd>
  <dt>serializeString</dt>
    <dd>Serialize a String.</dd>
  <dt>serializeSubstring</dt>
    <dd>Serialize a substring.</dd>
  <dt>deserializeString</dt>
    <dd>Deserialize a string.</dd>
</dl>

<h2 >Package org.epics.pvdata.monitor</h2>

<h3>Overview</h3>

<p>Project javaIOC provides the ability to monitor changes to an arbitrary
subset of the fields in a record. The next section describes how a client
specifies monitor options. The rest of this package description is of interest
to developers. Although this package does not implement monitors it does
describe what the client and what pvAccess needs to know about monitors. </p>

<p>A client can monitor an arbitrary subset of the fields in a record instance.
Each field has an associated monitor algorithm which decides if changes to that
field should cause a monitor. The algorithms defined by this package are:
onPut, onChange, and deadband. The set of algorithms is extensible.</p>

<p>The basic interface for monitoring is interface Monitor, which has four
methods: start, stop, poll, and release. Code that implements the client side
for monitors has code like the following:</p>
<pre>
    //somewhere the following request is issued
    monitor.start();
    //somewhere the following is done:
    while(true) {
       MonitorElement monitorElement = monitor.poll();
       if(monitorElement==null) {
          // no elements in the queue. Do something.
       } else {
          // got a monitor. Handle the element and then
          monitor.release(monitorElement);
       }
    }</pre>

<p>This package provides the following support for monitors:</p>
<ol>
  <li>How a client specifies monitor options<br />
  </li>
  <li>Implementing new monitoring algorithms.</li>
  <li>Monitor Queues<br />
    This package provides a complete implementation of montor queues for
    pvData. </li>
</ol>

<p>Developers who need to understand or implement monitor algorithms will be
interested in this package. For example it is used by pvAccess to implement
monitors. The interfaces can be implemented by other servers, for example the
javaIOC (org.epics.ioc.caV3) implements a version of interface Monitor that
links to a version 3 EPICS IOC.</p>

<p>This package defines the following monitor algorithms:</p>
<dl>
  <dt>onPut</dt>
    <dd>A monitor is issued whenever a put is issued to the field. This is the
      default unless the record defines deadbands for a field. An exception is
      the top level timeStamp which by default is made onChange and monitor
      will not be raised.</dd>
  <dt>onChange</dt>
    <dd>This provides two options: 1) A monitor is raised whenever a field
      changes value, and 2) A monitor will never be raised for the field.</dd>
  <dt>deadband</dt>
    <dd>The field must be a numeric scalar. Whenever the absolute or percentage
      value of the field changes by more than a deadband a monitor is issued.
      The record instance can also define deadbands.</dd>
  <dt>periodic</dt>
    <dd>A monitor is issued at a periodic rate if a put was issued to any field
      being monitored.</dd>
</dl>

<p>The monitor queue implementation provides support for the following queue
sizes greater than or equal to two.</p>

<h3>Standard Monitor Requests</h3>

<p>This section describes that monitor support provided by project javaIOC. Two
issues are discussed: record options and field options.</p>

<h4>Record Options</h4>

<p>The options that apply to an entire record are:</p>
<dl>
  <dt>periodic</dt>
    <dd>A record can ask to be monitored periodically by specifying a periodic
      rate. A monitor will be issued no faster that the rate specified. A
      periodic monitor does not use a monitor queue. </dd>
  <dt>queueSize</dt>
    <dd>Queue size can be specified to be &gt;=1. A size of 1 means no queue
      but just keep a single copy of the data. A size of 2 is the default.</dd>
</dl>

<h4>Field Options</h4>

<p>The following options are supported for all fields:</p>
<dl>
  <dt>shareData</dt>
    <dd>Has a value of true or false and specifies if the server just transfer
      data from the record keep a copy. This option can save memory for array
      fields. Note that it is implemented by PVCopy.</dd>
</dl>

<p>For each field the following monitor algorithms are supported:</p>
<dl>
  <dt>onPut</dt>
    <dd>A monitor is issued when a put is issued to the field. This is the
      default if no algorithm is specified and the field is not the top level
      timeStamp.</dd>
  <dt>onChange</dt>
    <dd>This has two features depending on the value of causeMonitor. If
      causeMomitor is true (the default) then a monitor is raised only if the
      value has changed since the last monitor. If causeMonitor is false then
      this field will never cause a monitor. An example is a top level
      timeStamp field. If a client monitors the top level timeStamp then unless
      the client requests causeMonitor to be false, if the only change is to
      the timeStamp field no monitior will be issued.</dd>
  <dt>deadband</dt>
    <dd>This can only be specified for a numeric scalar field. Details
    follow:</dd>
</dl>

<h4>Monitor Request Options</h4>

<p>The examples will use the syntax supported by calling:</p>
<pre>   PVStructure pvRequest = org.epics.ca.client.CreateRequestFactory.createRequest(request);</pre>

<p>The request string has the following:</p>
<pre>   "record[option=value,...]field(fieldDef,...)"</pre>

<p>The standard record options are:</p>
<dl>
  <dt>queueSize</dt>
    <dd>The value must be &gt;=1.</dd>
  <dt>periodicRate</dt>
    <dd>The value is the maximum rate in seconds for monitors.</dd>
</dl>

<p>Each fieldDef is either of the form:</p>
<pre>    fullRecordName</pre>

<p>Where fullRecordName is the full name of the field in the record. The name
in the structure the client will get is the field name from the record. Or
fieldDef has the form:</p>
<pre>    fieldName{fieldDef,...}
    </pre>

<p>Each fieldDef is of the form:</p>
<pre>    fullFieldName[option=value,...]</pre>

<p>where <span style="font-family: Courier">fullFieldName</span> is of the full
field name of the record field and the options define the monitor options.</p>

<p>Monitor options are identified via the following option.</p>
<pre>    algorithm=name
    </pre>

<p>where <span style="font-family: Courier">name</span> is the algorithm name.
For the algorithms implemented by pvData this is one of: <span
style="font-family: Courier">onPut, onChange, or deadband.</span> </p>

<p><span style="font-family: Courier">onPut</span> is the default so it does
not have to be specified.</p>

<p><span style="font-family: Courier">onChange</span> accepts one additional
option:</p>
<pre>    causeMonitor=value</pre>

<p>where value must be "true" or "false". The default is true.</p>

<p><span style="font-family: Courier">deadband</span> accepts the following
additional options:</p>
<pre>    deadband=deadbandValue
    type=typeValue
    isPercent=isPercentValue</pre>

<p>where</p>
<dl>
  <dt>deadbandValue</dt>
    <dd>The change in value (or percentage change) that causes a monitor. If
      not specified the deadband is taken from the record if the record defines
      it. If specified and the record also defines it the minimum value is
      taken. </dd>
  <dt>typeValue</dt>
    <dd>Must be "display" or "archive". This says if the record deadband is
      taken from display or from archive. The default is display.</dd>
  <dt>isPercentValue</dt>
    <dd>Must be true or false. The default is false. If true the deadband is a
      percentage change otherwise it is an absolute change.</dd>
</dl>

<h4>Record Deadband</h4>

<p>NOTE: This applys to records in a javaIOC.</p>

<p>Any numeric scalar field in a record instance can optionally have an
associated deadband structure, which is defined as follows:</p>
<pre>&lt;structure structureName = "deadband"&gt;
    &lt;structure name = "display"&gt;
         &lt;scalar name = "isPercent" scalarType = "boolean"/&gt;
         &lt;!-- if true than percentage change. If false than absolute change --&gt;
         &lt;scalar name = "value" scalarType = "double"/&gt;
         &lt;!-- the deadband for display --&gt;
    &lt;/structure&gt;
    &lt;structure name = "archive"&gt;
         &lt;scalar name = "isPercent" scalarType = "boolean"/&gt;
         &lt;!-- if true than percentage change. If false than absolute change --&gt;
         &lt;scalar name = "value" scalarType = "double"/&gt;
         &lt;!-- the deadband for archive --&gt;
    &lt;/structure&gt;
&lt;/structure&gt;</pre>

<p>As an example:</p>
<pre>&lt;record name = "example"&gt;
    &lt;scalar name = "value" scalarType = "double"&gt;
    &lt;structure name = "deadband" extends = "deadband"&gt;
       &lt;structure name = "display"&gt;
          &lt;deadband&gt;.1&lt;/deadband&gt;
       &lt;/structure&gt;
       &lt;structure name = "archive"&gt;
          &lt;deadband&gt;.3&lt;/deadband&gt;
       &lt;/structure
    &lt;/structure&gt;
    &lt;!-- other stuff --&gt;
&lt;/record&gt;</pre>

<p>NOTE: If an algorithm is not defined by the user for a field and a deadband
is defined for the record than the algorithm is made to be deadband and the
display deadband is used as the deadband.</p>

<h4>Examples</h4>

<p>The following:</p>
<pre>    String request = "alarm,timeStamp,power.value";
    PVStructure pvRequest = org.epics.ca.client.CreateRequestFactory.createRequest(request);</pre>

<p>Creates a pvRequest that monitors the alarm, timeStamp, and power.value
fields of a record. The client will receive a structure with the fields named
alarm,timeStamp, and value. Since the client has not specified any options the
defaults will be used. This means:</p>
<ul>
  <li>Any change in alarm will cause a monitor.</li>
  <li>A change in time stamp will NOT cause a monitor because a top level
    timeStamp is a special case.</li>
  <li>If power.value has an associated deadband structure than the display
    deadband will be used and the algorithm will be deadband. If power.value
    does not have an associated deadband than any put to power.value will cause
    a monitor.</li>
</ul>

<p>The following:</p>
<pre>    String request = "timeStamp[algorithm=onChange,causeMonitor=true]";
    PVStructure pvRequest = org.epics.ca.client.CreateRequestFactory.createRequest(request);</pre>

<p>Will cause monitior whenever the timeStamp is changed. This is a way to be
notified whenever a javaIOC record is processed because this is normally the
only time the timeStamp is changed.</p>

<p>The following:</p>
<pre>    String request =
        "alarm,timeStamp,value{power.value[algortithm=deadband,isPercent=true,deadband=1.0}";
    PVStructure pvRequest = org.epics.ca.client.CreateRequestFactory.createRequest(request);</pre>

<p>This requests a monitor whenever and alarm is raised or when the power.value
changes by at least 1 percent.</p>

<h3>Monitor Interfaces</h3>

<h4>Monitor</h4>

<p>This is the interface implemented by a factory that implements a monitoring
algorithm</p>
<pre>interface Monitor extends Destroyable {
    void start();
    void stop();
    MonitorElement poll();
    void release(MonitorElement monitorElement);
}</pre>

<p>where</p>
<dl>
  <dt>destroy</dt>
    <dd>destroy the monitor, i.e. release whatever resources are used by the
      implementation.</dd>
  <dt>start</dt>
    <dd>Start monitoring. An initial monitor with all data modified must be
      generated.</dd>
  <dt>stop</dt>
    <dd>Stop monitoring.</dd>
  <dt>poll</dt>
    <dd>Called to get modified data. If no data has been modified since the
      last poll null is returned. </dd>
  <dt>release</dt>
    <dd>release the element returned by the most recent poll request.</dd>
</dl>

<h4>MonitorElement</h4>

<p>This is the interface returned by a call to poll.</p>
<pre>interface MonitorElement  {
    PVStructure getPVStructure();
    BitSet getChangedBitSet();
    BitSet getOverrunBitSet();
}</pre>

<p>where</p>
<dl>
  <dt>getPVStructure</dt>
    <dd>The data structure.</dd>
  <dt>getChangedBitSet</dt>
    <dd>The bitSet showing which fields of the PVStructure have changed since
      the previous poll request.</dd>
  <dt>getOverrunBitSet</dt>
    <dd>the bitSey which shows which fields have been modified more than once
      since the last poll request.</dd>
</dl>

<h4>MonitorRequester</h4>

<p>This is the interface implemented by the code that request a monitor.</p>
<pre>interface MonitorRequester extends Requester {
    void monitorConnect(Monitor monitor, Structure structure);
    void monitorEvent(Monitor monitor);
    void unlisten();
}</pre>

<p>where</p>
<dl>
  <dt>monitorConnect</dt>
    <dd>The monitor has connected to a PVRecord.</dd>
  <dt>monitorEvent</dt>
    <dd>A monitor event has occured. Monitor.poll is called to get the
    data.</dd>
  <dt>unlisten</dt>
    <dd>The server has been told to disconnect from the record. The
      MonitorRequster can no longer issue any requests except destroy until
      monitorConnect is again called.</dd>
</dl>

<h4>MonitorAlgorithm</h4>

<p>The following are implemented by code that implements a monitor
algorithm.</p>
<pre>interface MonitorAlgorithm  {
    String getAlgorithmName();
    boolean causeMonitor();
    void monitorIssued();
}</pre>

<p>where</p>
<dl>
  <dt>getAlgorithmName</dt>
    <dd>return the name of the algorithm.</dd>
  <dt>causeMonitor</dt>
    <dd>Called to see if a change to this field should cause a monitor</dd>
  <dt>monitorIssued</dt>
    <dd>Called after a monitor has been issued.</dd>
</dl>

<h4>MonitorQueue</h4>

<p>This is the interface implemented by MonitorQueueFactory.</p>
<pre>interface MonitorQueue  {
    void clear();
    int getNumberFree();
    int capacity();
    MonitorElement getFree();
    void setUsed(MonitorElement monitorElement);
    MonitorElement getUsed();
    void releaseUsed(MonitorElement monitorElement);
}
</pre>
<h4>MonitorQueueFactory</h4>
<pre>
class MonitorQueueFactory {
    static MonitorQueue create(MonitorElement[] monitorElements);
}</pre>

<p>where</p>
<dl>
  <dt>clear</dt>
    <dd>Set all elements of the queue free.</dd>
  <dt>getNumberFree</dt>
    <dd>Get the number of free queue elements.</dd>
  <dt>capacity</dt>
    <dd>Get the number of queue elements.</dd>
  <dt>getFree</dt>
    <dd>Get a free queue element. If no free elements null is returned.</dd>
  <dt>setUsed</dt>
    <dd>Set the latest element returned by getFree to used.</dd>
  <dt>getUsed</dt>
    <dd>Get the oldest used element. Null is returned when there are no more
      used elements.</dd>
  <dt>releaseUsed</dt>
    <dd>release the element returned by the latest call to getUsed.</dd>
</dl>

</div>
</body>
</html>
