<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
      "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="content-type" content="text/html; charset=iso-8859-1" />
  <title>EPICS pvData</title>
</head>

<body>
<h1 style="text-align: center">EPICS pvData<br />
Overview<br />
2010.08.28</h1>
CONTENTS 

<div class="toc">
<ul>
  <li><a href="#Introducti">Introduction</a></li>
  <li><a href="#Interface">Interface Definitions</a>
    <ul>
      <li><a href="#Types">Types</a></li>
      <li><a href="#Introspect">Introspection Interfaces</a></li>
      <li><a href="#Data">Data Interfaces</a></li>
      <li><a href="#Introspect1">Introspection and Data creation</a></li>
      <li><a href="#pvData">pvData Conversion</a></li>
    </ul>
  </li>
  <li><a href="#Package">Package Summary</a>
    <ul>
      <li><a href="#L264">{@link org.epics.pvData.pv}</a></li>
      <li><a href="#L268">{@link org.epics.pvData.factory}</a></li>
      <li><a href="#L290">{@link org.epics.pvData.property}</a></li>
      <li><a href="#L298">{@link org.epics.pvData.misc}</a></li>
    </ul>
  </li>
  <li><a href="#License">License Agreement</a></li>
</ul>
</div>
<hr />

<h2 style="text-align: center" id="Introducti">Introduction</h2>
<hr />

<p>This product is available via the <a href="#LicenseAgreement">open source
license</a> described at the end of this document.</p>

<p>pvData is one of a set of related projects. It describes and implements
the data that the other projects support. Thus it is not useful by itself but
understanding pvData is required in order to understand the other projects.
The reader should also become familar with projects pvAccess and javaIOC,
which are located via the same sourceforge site as this project.</p>

<p>pvData (Process Variable Data) defines and implements an efficent way to
store, access, and transmit memory resident structured data.</p>
<dl>
  <dt>definition</dt>
    <dd>Package org.epics.pvData.pv has Java interface definitions that
      define pvData. Although defined with Java syntax they also document
      what is required for implementation in other languages such as C++.</dd>
  <dt>implementation</dt>
    <dd>The set of packages provides by this project provide a complete Java
      implementation of pvData. Project pvAccess is the network support for
      pvData, i.e. it provides a channel access client and server that fully
      support pvData. Project javaIOC provides an IOC (Input Output
      Controller) that supports pvData and provides record processing..</dd>
  <dt>efficient</dt>
    <dd>Small memory footprint, low cpu overhead, and concise code base.</dd>
  <dt>data storage</dt>
    <dd>pvData defines separate introspection and data interfaces. The
      introspection interfaces provide access to immutable objects, which
      allows introspection instances to be freely shared. The introspection
      interface for a process variable can be accessed without requiring
      access to the data.</dd>
  <dt>data access</dt>
    <dd>Client code can access pvData via the introspection and data
      interfaces. For "well known" data, e.g. timeStamp, specialized
      interfaces can be provided without requiring any changes to the core
      software.</dd>
  <dt>data transfer</dt>
    <dd>The separation of introspection and data interfaces allows for
      efficient network data transfer. At connection time introspection
      information can be passed from server to client. Each side can create a
      data instance. The data is transferred between these instances. The
      data in the network buffers does not have to be self describing since
      each side has the introspection information.</dd>
  <dt>memory resident</dt>
    <dd>pvData only defines memory resident data.</dd>
  <dt>structured data</dt>
    <dd>pvData has three types: scalar, array, and structure. A scalar can be
      one of the following: boolean, byte, short, int, long, float, double,
      string. An array is a one dimensional array with the element type being
      a scalar. A structure is an ordered set of fields where each field has
      a name and type. Since a field can have type structure complex
      structures are supported. No other types are needed since structures
      can be defined that simulate types.</dd>
</dl>

<p>The javaIOC implements a Process Variable (PV) Database, which is a memory
resident database holding pvData, has the following features:</p>
<ul>
  <li>A database has records.</li>
  <li>Each record has a unique record name.</li>
  <li>A record has a top level PVStructure, which is a structured set of data
    as defined by this project.</li>
  <li>A PVStructure has an array of PVFields.</li>
  <li>A PVField contains data of one of the following types: 
    <ul>
      <li>scalar : boolean, byte, short, int, long, float, double, string,
        structure</li>
      <li>array: a 1-dim array with the elementType being any scalar
      type.</li>
      <li>structure: a subStructure with each field being any of the
        supported types.</li>
    </ul>
  </li>
</ul>

<p>pvData was initially created to support the javaIOC and was part of the
javaIOC project. It is now a separate project that is used by the javaIOC. In
addition to the javaIOC, pvData is intended for use by 1) channel access
clients, 2) Interface between client and network, 3) Interface between
network and channel access server, 4) Interface between server and IOC
database. Since it is an interface to data, it could also be used by other
systems, e.g. TANGO, TINE, etc. A high level Physics application can hold
data as pvData. By starting a channel access server, the data can made
available to network clients.</p>

<p>pvData contains everything required to support Channel Access and Channel
Access clients and servers. </p>
<hr />

<h2 style="text-align: center" id="Interface">Interface Definitions</h2>
<hr />

<h3 id="Types">Types</h3>

<p>The following are the type definitions:</p>
<pre>enum Type {
    scalar,
    scalarArray,
    structure,
    structureArray;
}</pre>

<p>where</p>
<dl>
  <dt>scalar</dt>
    <dd>A field that has data with one of the scalarTypes.</dd>
  <dt>scalarArray</dt>
    <dd>A field that is an array where each element is the same
    scalarType.</dd>
  <dt>structure</dt>
    <dd>A field which has named subfields.</dd>
  <dt>structureArray</dt>
    <dd>A field that is an array of structures where each element has the
      same introspection interface, i.e. each element has the same
    structure.</dd>
</dl>
<pre>enum ScalarType {
    pvBoolean,
    pvByte,pvShort,pvInt,pvLong,
    pvFloat,pvDouble,
    pvString;
    // The following are convenience methods
    public boolean isInteger();
    public boolean isNumeric()
    public boolean isPrimitive() 
    public static ScalarType getScalarType(String type);
}</pre>

<p>where</p>
<dl>
  <dt>boolean</dt>
    <dd>true or false</dd>
  <dt>byte</dt>
    <dd>An 8 bit signed byte</dd>
  <dt>short</dt>
    <dd>16 bit signed integer</dd>
  <dt>int</dt>
    <dd>32 bit signed integer</dd>
  <dt>long</dt>
    <dd>64 bit signed integer</dd>
  <dt>float</dt>
    <dd>32 bit IEEE float</dd>
  <dt>double</dt>
    <dd>64 bit IEEE float</dd>
  <dt>string</dt>
    <dd>An immutable string. The Java implementation is String. For other
      implementations the network representation must be the same as for
      Java. Note that a string is treated like it is a scaler.</dd>
</dl>

<h3 id="Introspect">Introspection Interfaces</h3>

<p>The complete set of introspection interfaces are:</p>
<pre>interface Field {
    String getFieldName();
    Type getType();
    String toString();
    String toString(int indentLevel);
}

interface Scalar extends Field{
    ScalarType getScalarType();
}

interface ScalarArray extends Field{
    ScalarType getElementType();
}

interface Structure extends Field{
    String[] getFieldNames();
    Field getField(String fieldName);
    int getFieldIndex(String fieldName);
    Field[] getFields();
}

interface StructureArray extends Field{
    Structure getStructure();
}</pre>

<p>The introspection interfaces provide access to immutable objects. This
allows introspection interfaces to be freely shared between data objects. For
example the introspection interface for a timeStamp, which is a structure
containing two fields, can be shared by every record that has a time
stamp.</p>

<h3 id="Data">Data Interfaces</h3>

<p>PVField is the base interface for a data field:</p>
<pre>enum MessageType {info,warning,error,fatalError}

interface Requester {
    String getRequesterName();
    void message(String message, MessageType messageType);
}


interface Serializable {
    void serialize(ByteBuffer buffer, SerializableControl flusher);
    void deserialize(ByteBuffer buffer, DeserializableControl control);
}

interface PVAuxInfo {
    PVField getPVField();
    PVScalar createInfo(String key,ScalarType scalarType);
    Map&lt;String,PVScalar&gt; getInfos();
    PVScalar getInfo(String key);
    String toString();
    String toString(int indentLevel);
}

interface PVField extends Requester, Serializable {
    int getFieldOffset();
    int getNextFieldOffset();
    int getNumberFields();
    Field getField();
    PVStructure getParent();
    String getFullFieldName(); 
    String getFullName();
    PVAuxInfo getPVAuxInfo(); //auxillary information
    boolean isMutable();
    void setImmutable();
    void replacePVField(PVField newPVField);
    void renameField(String newName);
    void postPut(); // calls PVRecordField.postPut if this is a field of a record
    String toString();
    String toString(int indentLevel);
}</pre>

<p>Each scalar type has an associated data interface: PVBoolean, PVByte,
PVShort, PVInt, PVLong, PVFloat, PVDouble, and PVString. Each has a get and a
put method. For example:</p>
<pre>public interface PVDouble extends PVScalar{
    double get();
    void put(double value);
}</pre>

<p>PVArray is the base class for arrays.</p>
<pre>interface SerializableArray extends Serializable {
    void serialize(ByteBuffer buffer, SerializableControl flusher, int offset, int count);
}

interface PVArray extends PVField, SerializableArray{
    int getLength();
    void setLength(int len);
    int getCapacity();
    void setCapacity(int len);
    boolean isCapacityMutable();
    void setCapacityMutable(boolean isMutable);
}</pre>

<p>PVScalarArray is the base class for scalar arrays.</p>
<pre>interface PVScalarArray extends PVArray {
    ScalarArray getScalarArray();
}</pre>

<p>For each scalar type an associated array data interface is defined. Each
has a get and put method. For example: </p>
<pre>public class DoubleArrayData {
    public double[] data;
    public int offset;
}

interface PVDoubleArray extends PVArray {
    int get(int offset, int len, DoubleArrayData data);
    int put(int offset,int len, double[] from, int fromOffset);
    void shareData(double[] from);
}</pre>

<p>PVScalarArray is the interface for an array of structures where each
element has the same iontrospection interface.</p>
<pre>interface PVStructureArray extends PVArray{
    StructureArray getStructureArray();
    int get(int offset, int length, StructureArrayData data);
    int put(int offset,int length, PVStructure[] from, int fromOffset);
    void shareData(PVStructure[] from);
}</pre>

<p>PVStructure is the data interface for a structure.</p>
<pre>interface BitSetSerializable {
    void serialize(ByteBuffer buffer, SerializableControl flusher, BitSet bitSet);
    void deserialize(ByteBuffer buffer, DeserializableControl control, BitSet bitSet);
}

interface PVStructure extends PVField , BitSetSerializable{
    Structure getStructure();
    PVField[] getPVFields();
    PVField getSubField(String fieldName);
    PVField getSubField(int fieldOffset);
    void replacePVField(String fieldName,PVField newPVField);
    void appendPVField(PVField pvField);
    void removePVField(String fieldName);
    void updateInternal();
    // The following are convenience methods
    PVBoolean getBooleanField(String fieldName);
    PVByte getByteField(String fieldName);
    PVShort getShortField(String fieldName);
    PVInt getIntField(String fieldName);
    PVLong getLongField(String fieldName);
    PVFloat getFloatField(String fieldName);
    PVDouble getDoubleField(String fieldName);
    PVString getStringField(String fieldName);
    PVStructureScalar getStructureScalarField(String fieldName);
    PVStructure getStructureField(String fieldName);
    PVArray getArrayField(String fieldName,ScalarType elementType);
    PVStructureArray getStructureArrayField(String fieldName);
    String getExtendsStructureName();
    boolean putExtendsStructureName(String extendsStructureName);
}</pre>

<h3 id="Introspect1">Introspection and Data creation</h3>

<p>The following interface creates introspection instances:</p>
<pre>public interface FieldCreate {
    Field create(String fieldName,Field field);
    Scalar createScalar(String fieldName,ScalarType scalarType);
    ScalarArray createScalarArray(String fieldName,ScalarType elementType);
    StructureArray createStructureArray(String fieldName,Structure elementStructure);
    Structure createStructure(String fieldName, Field[] field);
}</pre>

<p>The following interface creates data instances:</p>
<pre>public interface PVDataCreate {
    PVField createPVField(PVStructure parent, Field field);
    PVField createPVField(PVStructure parent,String fieldName,PVField fieldToClone);
    PVScalar createPVScalar(PVStructure parent,Scalar scalar);
    PVScalar createPVScalar(PVStructure parent,String fieldName,ScalarType fieldType);
    PVScalar createPVScalar(PVStructure parent,String fieldName,PVScalar scalarToClone);
    PVStructureScalar createPVStructureScalar(PVStructure parent,StructureScalar structureScalar);
    PVStructureScalar createPVStructureScalar(PVStructure parent,String fieldName,PVStructure structureToClone);
    PVArray createPVArray(PVStructure parent,Array array);
    PVArray createPVArray(PVStructure parent,String fieldName,ScalarType elementType);
    PVArray createPVArray(PVStructure parent,String fieldName,PVArray arrayToClone);
    PVStructureArray createPVStructureArray(PVStructure parent,StructureArray structureArray);
    PVStructure createPVStructure(PVStructure parent,String fieldName,Field[] fields);
    PVStructure createPVStructure(PVStructure parent,String fieldName,PVStructure structToClone);
    PVField[] flattenPVStructure(PVStructure pvStructure);
}</pre>

<h3 id="pvData">pvData Conversion</h3>

<p>An interface named Convert provides all reasonable conversions to/from
pvData. See org.epics.pvData.pv.Convert for details.</p>
<hr />

<h2 style="text-align: center" id="Package">Package Summary</h2>
<hr />

<p>This document describes everything via Java definitions. The initial
implementation is in Java but the functionality could also be implemented in
other languages such as C++.</p>

<p>pvData is distributed as a eclipse Java Project named pvData. This project
consists of the following java packages:</p>

<h3 id="L264">{@link org.epics.pvData.pv}</h3>

<p>The Java enum, interface, and class definitions that define pvData. This
section provides a complete definition of what pvData is. This package
completely describes how pvData is accessed.</p>

<h3 id="L268">{@link org.epics.pvData.factory}</h3>

<p>Java Facilities for creating a PV Database and pvData. It provides
everything required for creating pvData. It provides the following
factories:</p>
<dl>
  <dt>FieldFactory</dt>
    <dd>Creates introspection interfaces.</dd>
  <dt>PVDataFactory</dt>
    <dd>Creates data interfaces for all of the supported data types.</dd>
  <dt>ConvertFactory</dt>
    <dd>Converts between support data types.</dd>
</dl>

<p>Although pvDataFactory can provide the implementation for all supported
data types, often it is desirable to provide other implementations. To make
it easy to create alternate implementations a set of abstract and base
classes are supplied.</p>

<h3 id="L290">{@link org.epics.pvData.property}</h3>

<p>Provides a way to associated properties with a field. </p>

<p>The basic idea is to associate properties with any field named "value".
All the fields in the structure that contains the value field are considered
properties of value with the field name being the property name. See that
package overview for details.</p>

<p>This package also provides support for "well known" field definitions like
timeStamp, alarm, display,etc. Code that uses pvData can be simplified by
using this support.</p>

<h3 id="L298">{@link org.epics.pvData.misc}</h3>

<p>This package provides support that is used by pvData factories and might
also be useful to software that uses pvData.</p>

<h2 style="text-align: center" id="License">License Agreement</h2>
<pre>Copyright (c) 2008 Martin R. Kraimer
Copyright (c) 2006 The University of Chicago, as Operator of Argonne
     National Laboratory.
Copyright (c) 2006 Deutsches Elektronen-Synchroton,
     Member of the Helmholtz Association, (DESY), HAMBURG, GERMANY.
Copyright (c) 2007 Control System Laboratory,
    (COSYLAB) Ljubljana Slovenia


Permission is hereby granted, free of charge, to any person
obtaining a copy of this software and associated documentation
files (the "Software"), to deal in the Software without
restriction, including without limitation the rights to use,
copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the
Software is furnished to do so, subject to the following
conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.

________________________________________________________________________

This software is in part copyrighted by the University of Chicago (UofC)

In no event shall UofC be liable to any party for direct, indirect,
special, incidental, or consequential damages arising out of the use of
this software, its documentation, or any derivatives thereof, even if
UofC has been advised of the possibility of such damage.

UofC specifically disclaims any warranties, including, but not limited
to, the implied warranties of merchantability, fitness for a particular
purpose, and non-infringement.  This software is provided on an "as is"
basis, and UofC has no obligation to provide maintenance, support,
updates, enhancements, or modifications.

________________________________________________________________________

This software is in part copyrighted by the BERLINER SPEICHERRING
GESELLSCHAFT FUER SYNCHROTRONSTRAHLUNG M.B.H. (BESSY), BERLIN, GERMANY.

In no event shall BESSY be liable to any party for direct, indirect,
special, incidental, or consequential damages arising out of the use of
this software, its documentation, or any derivatives thereof, even if
BESSY has been advised of the possibility of such damage.

BESSY specifically disclaims any warranties, including, but not limited
to, the implied warranties of merchantability, fitness for a particular
purpose, and non-infringement.  This software is provided on an "as is"
basis, and BESSY has no obligation to provide maintenance, support,
updates, enhancements, or modifications.

________________________________________________________________________

This software is in part copyrighted by the Deutsches Elektronen-Synchroton,
    Member of the Helmholtz Association, (DESY), HAMBURG, GERMANY.

In no event shall DESY be liable to any party for direct, indirect,
special, incidental, or consequential damages arising out of the use of
this software, its documentation, or any derivatives thereof, even if
DESY has been advised of the possibility of such damage.

DESY specifically disclaims any warranties, including, but not limited
to, the implied warranties of merchantability, fitness for a particular
purpose, and non-infringement.  This software is provided on an "as is"
basis, and DESY has no obligation to provide maintenance, support,
updates, enhancements, or modifications.
________________________________________________________________________</pre>
</body>
</html>
