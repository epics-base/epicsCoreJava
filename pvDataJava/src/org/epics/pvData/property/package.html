<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
      "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="content-type" content="text/html; charset=iso-8859-1" />
  <title>EPICS PVData: property</title>
</head>

<body>
<h1 style="text-align: center">EPICS PVData: property<br />
package: org.epics.pvData.property<br />
2008.12.24</h1>
CONTENTS 

<div class="toc">
<ul>
  <li><a href="#Data">Data Model</a></li>
  <li><a href="#PVData">PVData Structures</a></li>
  <li><a href="#PVProperty">PVProperty</a></li>
  <li><a href="#Structure">Structure Definitions</a>
    <ul>
      <li><a href="#Enumerated">Enumerated</a></li>
      <li><a href="#TimeStamp">TimeStamp</a></li>
      <li><a href="#Alarm">Alarm</a></li>
      <li><a href="#Limits">Limits</a></li>
      <li><a href="#Display">Display</a></li>
      <li><a href="#Control">Control</a></li>
    </ul>
  </li>
</ul>
</div>
<hr />

<h2 style="text-align: center" id="Data">Data Model</h2>
<hr />

<p>The Data Model supports general purpose client tools. A record supports
the data model if it follows a few simple guidelines.</p>

<p>The model can briefly be described as follows: Clients access a field
named value, which may be a field in the top level structure of a record or
in a substructure. All other fields in the structure are considered propertys
of the value field. The fieldname is the property name. The value is usually
a data field, i.e. a scalar type or an array with the elementType being
scalar. All other fields of the structure support the value. Typical property
fields are timeStamp, alarm, display, control, and history.</p>

<p>The timeStamp is a special case. It it appears anywhere in the structure
hieraracy above the value field it is considered a property</p>

<p>For example the following record has a single value field. The value field
has propertys alarm, timeStamp, and display.</p>
<pre>&lt;record name = "counterOutput" &gt;
    &lt;structure name = "alarm" type = "alarm" /&gt;
    &lt;structure name = "timeStamp" type = "timeStamp" /&gt;
    &lt;scalar name = "value" type = "double" /&gt;
    &lt;structure name = "display" type = "display" &gt;
        &lt;scalar name = "description"&gt;Sample Description&lt;/scalar&gt;
        &lt;scalar name = "format"&gt;%f&lt;/scalar&gt;
        &lt;scalar name = "resolution"&gt;1&lt;/scalar&gt;
        &lt;scalar name = "units"&gt;volts&lt;/scalar&gt;
        &lt;structure name = "limit"&gt;
            &lt;scalar name ="low"&gt;0.0&lt;/scalar&gt;
            &lt;scalar name ="high"&gt;10.0&lt;/scalar&gt;
        &lt;/structure&gt;
    &lt;/structure&gt;
&lt;/record&gt;</pre>

<p>The following example has three value fields each with propertys alarm and
timeStamp.</p>
<pre>&lt;record name = "psSimple"&gt;
    &lt;structure name = "alarm" type = "alarm" /&gt;
    &lt;structure name = "timeStamp" type = "timeStamp" /&gt;
    &lt;voltage type = "structure"&gt;
        &lt;scalar name = "value" type = "double" /&gt;
        &lt;alarm structureName = "alarm" /&gt;
    &lt;/voltage&gt;
    &lt;current type = "structure"&gt;
        &lt;scalar name = "value" type = "double" /&gt;
        &lt;structure name = "alarm" type = "alarm" /&gt;
    &lt;/current&gt;
    &lt;power type = "structure"&gt;
        &lt;scalar name = "value" type = "double" /&gt;
        &lt;structure name = "alarm" type = "alarm" /&gt;
    &lt;/power&gt;
&lt;/record&gt;</pre>

<p>A client could ask for power.value, current.value, or voltage.value.</p>

<p>This data model supports existing EPICS V3 channel access clients. In the
future it is expected that more powerfull or special purpose client will be
developed that can handle structured data. Such clients could access a
structure. For example a client could ask for an entire record. </p>
<hr />

<h2 style="text-align: center" id="PVData">PVData Structures</h2>
<hr />

<p>A PVData structure follows the PVData Data Model if it has a set of fields
that have names and types that support the data model. It can have additional
fields, that can also be considered properties. The following field names
have special meaning, i.e. are properties for general purpose clients.</p>
<dl>
  <dt>value</dt>
    <dd>This is normally defined since most general purpose clients access
      this field. All other fields in the structure support or describe the
      value field. The type can any supported type but is usually one of the
      following: 
      <dl>
        <dt>scalar</dt>
          <dd>One of boolean, byte, short, int, long, float, double, or
          string</dd>
        <dt>scalar array</dt>
          <dd>An array with the elementType being a scalar type</dd>
        <dt>enumerated structure</dt>
          <dd>A structure that includes fields named index, choice, and
            choices. index is an int that selects a choice. choice is the
            currently selected choice. choices is an array of strings that
            defines the complete set of choices.</dd>
        <dt>other</dt>
          <dd>Other structure or array types can also be defined if clients
            and support code agree on the meaning. Some examples are: 1) A
            structure defining a 2D matrix, 2) A structure defining an image,
            3) A structure that simulates a remote method, ...</dd>
      </dl>
    </dd>
  <dt>timeStamp</dt>
    <dd>The timeStamp. The type MUST be a timeStamp structure. Also if the
      PVData structure does not have a timeStamp then a search up the parent
      tree is made to find a timeStamp.</dd>
  <dt>alarm</dt>
    <dd>The alarm. The type MUST be an alarm structure. </dd>
  <dt>display</dt>
    <dd>A display structure as described below. It provides display
      characteristics for the value field.</dd>
  <dt>control</dt>
    <dd>A control structure as described below. It provides control
      characteristics for the value field.</dd>
  <dt>history</dt>
    <dd>Provides a history buffer for the value field. Note that currently
      PVData does not define history suppoprt.</dd>
  <dt>other</dt>
    <dd>Other standard properties can be defined.</dd>
</dl>

<p>In addition the PVData structure can have additional fields that support
the value field but are not recognized by most general purpose client tools.
Typical examples are:</p>
<dl>
  <dt>input</dt>
    <dd>A field with support that changes the value field. This can be
      anything. It can be a channel access link. It can obtain a value from
      hardware. Etc.</dd>
  <dt>valueAlarm</dt>
    <dd>A field with support that looks for alarm conditions based on the
      value.</dd>
  <dt>output</dt>
    <dd>A field with support that reads the current value and sends it
      somewhere else. This can be anything. It can be a channel access link.
      It can write a value to hardware. Etc.</dd>
</dl>

<p>The model allows for device records. A device record has fields that are
structures that support the PVData data model. For example a powerSupport
record can have fields power, voltage, current that each support the PVData
data model. </p>
<hr />

<h2 style="text-align: center" id="PVProperty">PVProperty</h2>
<hr />

<p>Interface and factory for finding a field within a structure.</p>
<pre>    public interface PVProperty {
        PVField findProperty(PVField pvField,String fieldName);
        PVField findPropertyViaParent(PVField pvField,String propertyName);
        String[] getPropertyNames(PVField pvField);
    }

    public class PVPropertyFactory {
         public static PVProperty getPVProperty();
    }</pre>
<ul>
  <li>findProperty<br />
    Find a field that is a subfield or property of this PVField. The
    fieldName is of the form item.item... where item is name or name[index].
    The algorithm implemented by findProperty is: 
    <ul>
      <li>Start with the leftmost item and find it.</li>
      <li>find the next leftmost item and find it.</li>
      <li>Continue until all items have been found or a search fails.</li>
      <li>Return the interface for the last item or null if a search
      fails.</li>
    </ul>
    An item is found as follows: 
    <ul>
      <li>Find the name part of item. If no [index] is present then fail.</li>
      <li>If [index] is present than field must be a structure with
        elementType structure or array. If so then make sure the index
        element is found. If so it is the field.</li>
      <li>fail</li>
    </ul>
    A name is found as follows: 
    <ol>
      <li>If the Field for the current PVField is named "value" back up one
        level in parent tree.</li>
      <li>The current PV must be a structure. If not fail.</li>
      <li>If the current PVField is type structure with a fieldName=name then
        use it.</li>
      <li>If the fieldName is not timeStamp than fail.</li>
      <li>If the parent tree is null then fail.</li>
      <li>Back up one level in the parent tree and go to 2).</li>
    </ol>
  </li>
  <li>findPropertyViaParent<br />
    Find a property by searching up the parent tree. The property name is
    expected to match the name of a field. The return value is the interface
    to the first field found that is not a null structure or null if not
    found. </li>
  <li>getPropertyNames<br />
    Get a String array that holds the names of the properties for this field.
    A property name is the field name. If this PVfield is a structure then
    every field except null structures is a property. If this PVField is the
    value field the parent is the starting point and the properties will not
    include the value field itself. In addition a search up the parent tree
    is made for the timeStamp.</li>
  <li>getPVProperty<br />
    Get the single instance of PVProperty. </li>
</ul>
<hr />

<h2 style="text-align: center" id="Structure">Structure Definitions</h2>
<hr />

<p>This section has structure definitions that support standard
properties.</p>

<h3 id="Enumerated">Enumerated</h3>
<pre>&lt;structure name = "enumeratedFactory"&gt;
  &lt;scalar name = "pvReplaceFactory" type = "string"&gt;
    org.epics.pvData.misc.EnumeratedFactory&lt;/scalar&gt;
&lt;/structure&gt;

&lt;structure name = "enumerated"&gt;
  &lt;auxInfo name = "pvReplaceFactory" type = "string"&gt;enumeratedFactory&lt;/auxInfo&gt;
  &lt;scalar name = "index" type = "int" /&gt;
  &lt;scalar name = "choice" type = "string" /&gt;
  &lt;array name = "choices" type = "string" /&gt;
&lt;/structure&gt;
</pre>

<h3 id="TimeStamp">TimeStamp</h3>
<pre>&lt;structure name = "timeStamp"&gt;
  &lt;scalar name = "secondsPastEpoch" type = "long" /&gt;
  &lt;scalar name = "nanoSeconds" type = "int" /&gt;
&lt;/structure&gt;</pre>

<h3 id="Alarm">Alarm</h3>
<pre>&lt;structure name = "alarmSeverity"&gt;
  &lt;auxInfo name = "pvReplaceFactory" type = "string"&gt;enumeratedFactory&lt;/auxInfo&gt;
  &lt;scalar name = "index" type = "int" /&gt;
  &lt;scalar name = "choice" type = "string" /&gt;
  &lt;array name = "choices" type = "string"&gt;
    none,minor,major,invalid&lt;/array&gt;
&lt;/structure&gt;

&lt;structure name = "alarm" supportName = "alarm" &gt;
  &lt;auxInfo name = "supportFactory" type = "string"&gt;alarmFactory&lt;/auxInfo&gt;
  &lt;structure name = "severity" type = "alarmSeverity" /&gt;
  &lt;scalar name = "message" type = "string" /&gt;
  &lt;scalar name = "ackTransient" type = "boolean" /&gt;
  &lt;structure name = "ackSeverity" type = "alarmSeverity" /&gt;
&lt;/structure&gt;</pre>

<h3 id="Limits">Limits</h3>
<pre>&lt;structure name = "byteLimit"&gt;
    &lt;scalar name = "low" type = "byte" /&gt;
    &lt;scalar name = "high" type = "byte" /&gt;
&lt;/structure&gt;

&lt;structure name = "shortLimit"&gt;
    &lt;scalar name = "low" type = "short" /&gt;
    &lt;scalar name = "high" type = "short" /&gt;
&lt;/structure&gt;

&lt;structure name = "intLimit"&gt;
    &lt;scalar name = "low" type = "int" /&gt;
    &lt;scalar name = "high" type = "int" /&gt;
&lt;/structure&gt;

&lt;structure name = "longLimit"&gt;
    &lt;scalar name = "low" type = "long" /&gt;
    &lt;scalar name = "high" type = "long" /&gt;
&lt;/structure&gt;

&lt;structure name = "floatLimit"&gt;
    &lt;scalar name = "low" type = "float" /&gt;
    &lt;scalar name = "high" type = "float" /&gt;
&lt;/structure&gt;

&lt;structure name = "doubleLimit"&gt;
    &lt;scalar name = "low" type = "double" /&gt;
    &lt;scalar name = "high" type = "double" /&gt;
&lt;/structure&gt;
</pre>

<h3 id="Display">Display</h3>
<pre>&lt;structure name = "display"&gt;
    &lt;scalar name = "description" type = "string" /&gt;
    &lt;scalar name = "format" type = "string" /&gt;
    &lt;scalar name = "units" type = "string" /&gt;
    &lt;scalar name = "resolution" type = "int" /&gt;
    &lt;structure name = "limit" type = "doubleLimit" /&gt;
&lt;/structure&gt;</pre>

<h3 id="Control">Control</h3>
<pre>&lt;structure name = "controlLimitFactory"&gt;
  &lt;scalar name = "pvReplaceFactory" type = "string"&gt;
    org.epics.pvData.misc.ControlLimitFactory&lt;/scalar&gt;
&lt;/structure&gt;

&lt;structure name = "control"&gt;
    &lt;structure name = "limit" type = "doubleLimit" /&gt;
    &lt;scalar name = "minStep" type = "double" /&gt;
&lt;/structure&gt;</pre>
</body>
</html>
