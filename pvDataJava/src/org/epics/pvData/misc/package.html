<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
      "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="content-type" content="text/html; charset=iso-8859-1" />
  <title>EPICS PVData: misc</title>
</head>

<body>
<h1 style="text-align: center">EPICS PVData : misc<br />
package: org.epics.pvData.misc<br />
2008.12.24</h1>
CONTENTS 

<div class="toc">
<ul>
  <li><a href="#Overview">Overview</a></li>
  <li><a href="#Enumeratio">Enumeration</a></li>
  <li><a href="#Message">Message Support</a>
    <ul>
      <li><a href="#Definition">Definitions</a></li>
      <li><a href="#MessageQue">MessageQueue</a></li>
    </ul>
  </li>
  <li><a href="#Thread">Thread Support</a>
    <ul>
      <li><a href="#ThreadPrio">ThreadPriority</a></li>
      <li><a href="#ThreadCrea">ThreadCreate</a></li>
      <li><a href="#Executor">Executor</a></li>
    </ul>
  </li>
</ul>
</div>
<hr />

<h2 style="text-align: center" id="Overview">Overview</h2>
<hr />

<p>This package provides utility code:</p>
<dl>
  <dt>Enumerated Support</dt>
    <dd>Support for an enumerated structure, which is a structure containing
      fields index, choice, and choices.</dd>
  <dt>Message Support</dt>
    <dd>Support for queuing messages to give to requesters.</dd>
  <dt>Thread Support</dt>
    <dd>ThreadCreate and IOCExecutor</dd>
</dl>
<hr />

<h2 style="text-align: center;" id="Enumeratio">Enumeration</h2>
<hr />

<p>Enumerated is a convenience interface for a structure that happens to be
an enumerated structure, which is a structure that has fields index, choice,
and choices. Index is an integer, choice is a string, and choices is an array
of strings. Both index and choice select one of the choices.</p>
<pre>    public interface Enumerated {
        PVInt getIndex();
        PVString getChoice();
        PVStringArray getChoices();
        PVStructure getPV();
    }

    public class EnumeratedFactory {
        public static void replacePVField(PVField pvField);
        public static Enumerated getEnumerated(PVField pvField);
    }</pre>

<p>where</p>
<dl>
  <dt>getIndex</dt>
    <dd>Returns the interface for field index.</dd>
  <dt>getChoice</dt>
    <dd>Returns the interface for field choice.</dd>
  <dt>getChoices</dt>
    <dd>Returns the interface for field choices.</dd>
  <dt>getPV</dt>
    <dd>Returns the interface for the PVStructure for the enumerated
      structure.</dd>
  <dt>replacePVField</dt>
    <dd>Replace the PVField implementation. The new implementation implements
      interface Enumerated and also replaces the implementations of fields
      index, choice, and choices. The new implementation updates index when
      choice is changed and choice when index is changed. If choices is
      changed the index is set to 0.</dd>
  <dt>getEnumerated</dt>
    <dd>If the field is an enumerated structure and replacePVField was called
      for the field then interface Enumerated is returned.</dd>
</dl>
<hr />

<h2 style="text-align: center;" id="Message">Message Support</h2>
<hr />

<h3 id="Definition">Definitions</h3>
<pre>    public class MessageNode {
        public String message;
        public MessageType messageType;
    }

    public interface MessageQueue {
        void lock();
        void unlock();
        MessageNode get();
        boolean put(String message,MessageType messageType);
        boolean isEmpty();
        boolean isFull();
        void replaceFirst(String message,MessageType messageType);
        void replaceLast(String message,MessageType messageType);
        int getClearOverrun();
    }
    
    public class MessageQueueFactory {
        public static MessageQueue create(int size);
    }</pre>

<h3 id="MessageQue">MessageQueue</h3>

<p>This is for use by code that wants to handle messages without blocking
higher priority threads.</p>

<p>A messageNode is a class with two public data members:</p>
<dl>
  <dt style="font-family: courier;">message</dt>
    <dd>The message.</dd>
  <dt style="font-family: courier;">messageType</dt>
    <dd>The message type.</dd>
</dl>

<p>A messageQueue is an interface with methods:</p>
<dl>
  <dt style="font-family: courier;">lock</dt>
  <dt style="font-family: courier;">unlock</dt>
    <dd>lock/unlock must surround all calls to the other methods.</dd>
  <dt style="font-family: courier;">put</dt>
    <dd>Put a new message into the queue. False is returned if the queue was
      full and true otherwise.</dd>
  <dt style="font-family: courier;">isEmpty</dt>
    <dd>Is the queue empty?</dd>
  <dt style="font-family: courier;">isFull</dt>
    <dd>Is the queue full?</dd>
  <dt style="font-family: courier;">replaceFirst</dt>
    <dd>Replace the oldest member in the queue.</dd>
  <dt style="font-family: courier;">replaceLast</dt>
    <dd>Replace the newest member in the queue.</dd>
  <dt style="font-family: courier;">getClearOverrun</dt>
    <dd>Get the number of times replaceFirst or replaceLast have been called
      since the last call to getClearOverrun. The internal counter is reset
      to 0.</dd>
</dl>

<p>MessageQueueFactory provides the public method:</p>
<dl>
  <dt style="font-family: courier;">create</dt>
    <dd>Create a MessageQueue and return the interface.</dd>
</dl>

<p>An example is:</p>
<pre>    public void message(final String message, MessageType messageType) {
        boolean execute = false;
        messageQueue.lock();
        try {
            if(messageQueue.isEmpty()) execute = true;
            if(messageQueue.isFull()) {
                messageQueue.replaceLast(message, messageType);
            } else {
                messageQueue.put(message, messageType);
            }
        } finally {
            messageQueue.unlock();
        }
        if(syncExec) {
            iocExecutor.execute(this);
        }
    }
    ...
    public run() { // handle messages
        while(true) {
            String message = null;
            int numOverrun = 0;
            messageQueue.lock();
            try {
                MessageNode messageNode = messageQueue.get();
                numOverrun = messageQueue.getClearOverrun();
                if(messageNode==null &amp;&amp; numOverrun==0) break;
                message = messageNode.message;
            } finally {
                messageQueue.unlock();
            }
            if(numOverrun&gt;0) {
                System.out.printf(String.format("%n%d missed messages&amp;n", numOverrun));
            }
            if(message!=null) {
               System.out.printf(String.format("%s%n",message));
            }
        }
    }</pre>
<hr />

<h2 style="text-align: center;" id="Thread">Thread Support</h2>
<hr />

<h3 id="ThreadPrio">ThreadPriority</h3>
<pre>    public enum ThreadPriority {
        lowest,
        lower,
        low,
        middle,
        high,
        higher,
        highest;
        
        public static final int[] javaPriority;
    
        public int getJavaPriority();
        public static int getJavaPriority(ThreadPriority scanPriority);
    }</pre>

<h3 id="ThreadCrea">ThreadCreate</h3>
<pre>    interface ThreadReady {
        void ready();
    }

    interface 
 {
        void run(ThreadReady threadReady);
    }

    interface ThreadCreate {
        Thread create(String name, int priority, RunnableReady runnableReady);
        Thread[] getThreads();
    }
    
    public class ThreadCreateFactory {
        public static ThreadCreate getThreadCreate();
    }</pre>

<p>ThreadCreate provides two features:</p>
<ol>
  <li>Create does not return until ReadyRunnable.run calls
    ThreadReady.ready().</li>
  <li>A list of all active threads is kept. getThreads provides access to the
    list.</li>
</ol>

<h3 id="Executor">Executor</h3>
<pre>    public interface Executor {
        void execute(Runnable command);
    }
    public class ExecutorFactory {
        static public Executor create(String name,ScanPriority priority);
    }</pre>

<p>An Executor is a thread that can execute any object that implements the
Java Runnable interface. The user can request that a single command be
executed. If the command is already in the list of commands to be executed it
is NOT added to the list.</p>
</body>
</html>
