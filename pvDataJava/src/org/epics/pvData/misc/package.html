<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
      "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="content-type" content="text/html; charset=iso-8859-1" />
  <title>EPICS PVData: misc</title>
</head>

<body>
<h1 style="text-align: center">EPICS PVData : misc<br />
package: org.epics.pvData.misc<br />
2010.11.24</h1>
CONTENTS 

<div class="toc">
<ul>
  <li><a href="#Overview">Overview</a></li>
  <li><a href="#MultiChoic">MultiChoice</a></li>
  <li><a href="#BitSet">BitSet</a></li>
  <li><a href="#Message">Message Queue</a>
    <ul>
      <li><a href="#Definition">Definitions</a></li>
      <li><a href="#MessageQue">MessageQueue</a></li>
    </ul>
  </li>
  <li><a href="#Thread">Thread</a>
    <ul>
      <li><a href="#ThreadPrio">ThreadPriority</a></li>
      <li><a href="#ThreadCrea">ThreadCreate</a></li>
      <li><a href="#Executor">Executor</a></li>
    </ul>
  </li>
  <li><a href="#Time">Time Function Call</a></li>
  <li><a href="#Linked">Linked List</a></li>
  <li><a href="#Timer">Timer</a>
    <ul>
      <li><a href="#Java">Java Definitions</a></li>
      <li><a href="#TimerCallb">TimerCallback</a></li>
      <li><a href="#TimerNode">TimerNode</a></li>
      <li><a href="#Timer1">Timer</a></li>
      <li><a href="#TimerFacto">TimerFactory</a></li>
    </ul>
  </li>
  <li><a href="#BitSet1">BitSet</a></li>
  <li><a href="#Queue">Queue</a></li>
  <li><a href="#Destroyabl">Destroyable</a></li>
  <li><a href="#Serialize">Serialize</a></li>
</ul>
</div>
<hr />

<h2 style="text-align: center" id="Overview">Overview</h2>
<hr />

<p>This package provides utility code:</p>
<dl>
  <dt>multiChoice</dt>
    <dd>Support for a multiChoice structre, which is a structure containing
      two fields: choices and bitMask. choices is an array of strings and
      bitMask selects a subset of the choices.</dd>
  <dt>Message Queue</dt>
    <dd>Support for queuing messages to give to requesters.</dd>
  <dt>Thread</dt>
    <dd>ThreadCreate and Executor</dd>
  <dt>TimeFunction</dt>
    <dd>Time how long a function call requires.</dd>
  <dt>LinkedList</dt>
    <dd>A douuble linked list facility that requires the user to allocate a
      node. It is more efficient that ArrayList and does not require the
      implementation to allocate storage for the nodes.</dd>
  <dt>Timer</dt>
    <dd>An implementation of Timer that does not require an object to be
      created for each timer request.</dd>
  <dt>BitSet</dt>
    <dd>An implementation of BitSet that can be serialized.</dd>
  <dt>Queue</dt>
    <dd>A queue implementation.</dd>
  <dt>Destroyable</dt>
    <dd>A base interface for destroy.</dd>
  <dt>Serialize</dt>
    <dd>A helper for serialization.</dd>
</dl>
<hr />

<h2 style="text-align: center;" id="MultiChoic">MultiChoice</h2>
<hr />

<p>NOTE: This is not currently used by anything.</p>

<p>A MultiChoice consists of an array of strings and a bot set that selects
an arbitrary set of the choices.</p>
<pre>    public interface MultiChoice {
        interface Choices {
            String[] getChoices();
            int getNumberChoices();
        }
        byte[] getBitMask();
        String[] getChoices();
        Choices getSelectedChoices();
        void setBit(int index);
        void clear();
        int registerChoice(String choice);
    }

    public class MultiChoiceFactory{
         public static MultiChoice getMultiChoice(PVField pvField);
    }</pre>

<p>where</p>
<dl>
  <dt style="font-family: courier;">getBitMask</dt>
    <dd>Returns the bitMask.</dd>
  <dt style="font-family: courier;">getChoices</dt>
    <dd>Returns the complete set of choices..</dd>
  <dt style="font-family: courier;">getSelectedChoices</dt>
    <dd>Returns the interface for getting the selected choices..</dd>
  <dt style="font-family: courier;">setBit</dt>
    <dd>Select the choice for specified bit..</dd>
  <dt style="font-family: courier;">clear</dt>
    <dd>Clear the bitMask, i.e. no choices are selected..</dd>
  <dt style="font-family: courier;">registerChoice</dt>
    <dd>Register a new choice. If thed choice already exists then it''s index
      is returned. If not it is appended to the choices.</dd>
</dl>
<hr />

<h2 style="text-align: center;" id="BitSet">BitSet</h2>
<hr />

<p>This is an implementation of BitSet that supports serialization, which the
standard Jave implementation does not allow.</p>

<p>The following is also provided:</p>
<pre>interface BitSetUtil {
    boolean compress(BitSet bitSet,PVStructure pvStructure);
}

class BitSetUtilFactory {
    public static BitSetUtil getCompressBitSet();
}</pre>

<p>This provides functions that operate of a BitSet for a PVStructure. It
currently has only one method:</p>
<dl>
  <dt><span style="font-family: Courier">compress</span></dt>
    <dd>Compress the bits in a BitSet related to a structure.<br />
      For each structure: 
      <ol>
        <li>If the bit for the structure is set then the bit for all
          subfields of the structure are cleared. </li>
        <li>If the bit for the structure is not set but all immediate
          subfields have their bit set then the bit for the structure is set
          and the bits for all subfields are cleared. </li>
      </ol>
      Note that this is a recursive algorithm. That is if every immediate
      subfield has it's offset bit set then the bits for ALL fields that
      reside in the structure will be cleared.</dd>
    <dd>Channel Access can call this before sending data. It can then pass
      entire structures if the structure offset bit is set. </dd>
</dl>
<hr />

<h2 style="text-align: center;" id="Message">Message Queue</h2>
<hr />

<h3 id="Definition">Definitions</h3>
<pre>    public class MessageNode {
        public String message;
        public MessageType messageType;
    }

    public interface MessageQueue {
        MessageNode get();
        boolean put(String message,MessageType messageType);
        boolean isEmpty();
        boolean isFull();
        int getClearOverrun();
    }
    
    public class MessageQueueFactory {
        public static MessageQueue create(int size);
    }</pre>

<h3 id="MessageQue">MessageQueue</h3>

<p>This is for use by code that wants to handle messages without blocking
higher priority threads.</p>

<p>A messageNode is a class with two public data members:</p>
<dl>
  <dt style="font-family: courier;">message</dt>
    <dd>The message.</dd>
  <dt style="font-family: courier;">messageType</dt>
    <dd>The message type.</dd>
</dl>

<p>A messageQueue is an interface with methods:</p>
<dl>
  <dt style="font-family: courier;">put</dt>
    <dd>Put a new message into the queue. False is returned if the queue was
      full and true otherwise.</dd>
  <dt style="font-family: courier;">isEmpty</dt>
    <dd>Is the queue empty?</dd>
  <dt style="font-family: courier;">isFull</dt>
    <dd>Is the queue full?</dd>
  <dt style="font-family: courier;">getClearOverrun</dt>
    <dd>Get the number of times replaceFirst or replaceLast have been called
      since the last call to getClearOverrun. The internal counter is reset
      to 0.</dd>
</dl>

<p>MessageQueueFactory provides the public method:</p>
<dl>
  <dt style="font-family: courier;">create</dt>
    <dd>Create a MessageQueue and return the interface.</dd>
</dl>
<hr />

<h2 style="text-align: center;" id="Thread">Thread</h2>
<hr />

<h3 id="ThreadPrio">ThreadPriority</h3>
<pre>    public enum ThreadPriority {
        lowest,
        lower,
        low,
        middle,
        high,
        higher,
        highest;
        
        public static final int[] javaPriority;
        public int getJavaPriority();
        public static int getJavaPriority(ThreadPriority threadPriority);
    }</pre>

<h3 id="ThreadCrea">ThreadCreate</h3>
<pre>    interface ThreadReady {
        void ready();
    }

    interface RunnableReady {
        void run(ThreadReady threadReady);
    }

    interface ThreadCreate {
        Thread create(String name, int priority, RunnableReady runnableReady);
        Thread[] getThreads();
    }
    
    public class ThreadCreateFactory {
        public static ThreadCreate getThreadCreate();
    }</pre>

<p>ThreadCreate provides two features:</p>
<ol>
  <li>Create does not return until ReadyRunnable.run calls
    ThreadReady.ready().</li>
  <li>A list of all active threads is kept. getThreads provides access to the
    list.</li>
</ol>

<h3 id="Executor">Executor</h3>

<p>An Executor is a thread that can execute any object that implements the
Java Runnable interface. The user can request that a single command be
executed. If the command is already in the list of commands to be executed it
is NOT added to the list when add is called.</p>
<pre>    public interface ExecutorNode {}

    public interface Executor {
        ExecutorNode createNode(Runnable command);
        void execute(ExecutorNode executorNode);
        void stop();
    }
    public class ExecutorFactory {
        static public Executor create(String name,ScanPriority priority);
    }</pre>
where 
<dl>
  <dt style="font-family: courier;">createNode</dt>
    <dd>Create a ExecutorNode that can be passed to execute.</dd>
  <dt style="font-family: courier;">execute</dt>
    <dd>Request that command be executed. If it is already on the run list
      nothing is done.</dd>
  <dt style="font-family: courier;">stop</dt>
    <dd>Stop the thread and refuse additional execute requests.</dd>
</dl>
<hr />

<h2 style="text-align: center;" id="Time">Time Function Call</h2>
<hr />

<p>TimeFunction is a facility that measures the average number of seconds a
function call requires. When timeCall is called, it calls function in a loop.
It starts with a loop of one iteration. If the total elapsed time is less
then .1 seconds it increases the number of iterrations by a factor of 10. It
keeps repeating until the elapsed time is greater than .1 seconds. It returns
the average number of seconds per call.</p>
<pre>    public interface TimeFunctionRequester {
        void function();
    }

    public interface TimeFunction {
        double timeCall();
    }

    public class TimeFunctionFactory {
        public static TimeFunction create(TimeFunctionRequester requester);
    }</pre>
<hr />

<h2 style="text-align: center;" id="Linked">Linked List</h2>
<hr />

<p>LinkedList implements a double linked list that requires a user to
allocate the nodes. It is more efficent that ArrayList for implementing
stacks and queues. For lists that are traversed while new elements can be
added or removed, LinkedListArray provides a way to get an array of the
currrent elements without allocating a new array each time the array is
traversed.</p>

<p>LinkedListArray converts a LinkedList to an LinkNode array. The
implementation provided by LinkedListFactory only creates a new LinkNode
array w.en the number of elements in the linkedList passed to setNodes is
greater than the length of the current LinkNode array.</p>
<pre>    public interface LinkedListNode&lt;T&gt; {
        public T getObject();
        boolean isOnList();
    }   
    
    public interface LinkedList {
        void addTail(LinkedListNode&lt;T&gt; listNode);
        void addHead(LinkedListNode&lt;T&gt; listNode);
        void insertAfter(LinkedListNode&lt;T&gt; listNode,LinkedListNode&lt;T&gt; addNode);
        void insertBefore(LinkedListNode&lt;T&gt; listNode,LinkedListNode&lt;T&gt; addNode);
        LinkedListNode&lt;T&gt; removeTail();
        LinkedListNode&lt;T&gt; removeHead();
        void remove(LinkedListNode&lt;T&gt; listNode);
        void remove(T object);
        LinkedListNode&lt;T&gt; getHead();
        LinkedListNode&lt;T&gt; getTail();
        LinkedListNode&lt;T&gt; getNext(LinkedListNode&lt;T&gt; listNode);
        LinkedListNode&lt;T&gt; getPrev(LinkedListNode&lt;T&gt; listNode);
        boolean isEmpty();
        boolean contains(T object);
    }

    public interface LinkedListArray&lt;T&gt; {
        void setNodes(LinkedList&lt;T&gt; linkedList);
        LinkedListNode&lt;T&gt;[] getNodes();
        int getLength();
        void clear();
    }
    
    public class LinkedListCreate&lt;T&gt; {
        public static LinkedList&lt;T&gt; create();
        public static LinkedListNode&lt;T&gt; createNode(Object object);
        public static LinkedListArray&lt;T&gt; createArray();
    }</pre>

<p>LinkedListCreate is created as follows:</p>
<pre>    LinkedListCreate&lt;SomeObject&gt; linkedListCreate = new LinkedListCreate&lt;SomeObject&gt;();</pre>

<p>Then a linked list can be created as follows:</p>
<pre>    LinkedList&lt;SomeObject&gt; linkedList = linkedListCreate.create();</pre>

<p>The only way a node can be allocated is by calling
linkedListCreate.createNode(SomeObject object). The object passed to
createNode is what is returned by LinkedList.getObject. For example:</p>
<pre>    private static class SomeObject {
        private LinkedListNode&lt;SomeObject&gt; listNode = null;
        // other definitions


        private Node(/* arguments*/) {
            listNode = linkedListCreate.createNode(this);
        }

        LinkedListNode&lt;SomeObject&gt; getListNode() {return listNode};
    }

    // then

    SomeObject someObject = new SomeObject(/* args */);
    linkedList.addTail(someObject);</pre>

<p>A node can only be on one list at a time but can be put, at different
times, on different lists as long as they all hold the same type of
objects.</p>

<p>The class does not provide a lock but the user can synchronized via calls
like:</p>
<pre>    synchronized(linkedList) {
        linkedList.addTail(listNode);
    }</pre>

<p>The following is an example of how to use LinkedListArray.</p>
<pre>        LinkedListNode&lt;SomeObject&gt;[] nodes = null;
        int length = 0;
        synchronized(linkedList) {
            linkedListArray.setNodes(linkedList);
            nodes = linkedListArray.getNodes();
            length = linkedListArray.getLength();
        }
        for(int i=0; i&lt;length; i++) {
            SomeObject object = nodes[i].getObject();
            // do something with object
        }</pre>
<hr />

<h2 style="text-align: center;" id="Timer">Timer</h2>
<hr />

<p>This provides a general purpose timer. It provides the following features
not provided by java.util.Timer and java.util.TimerTask:</p>
<ol>
  <li>Priority<br />
    The java.util implementation does not allow the user to specify the
    priority of the timer thread. This implementation does.</li>
  <li>TimerNode<br />
    A java.util.TimerTask is not reusable. Once a timerTask has been canceled
    or a delay timerTask has run, the TimerTask can not be reused. Instead a
    new TimerTask must be created. A TimerNode can be reused.</li>
</ol>

<h3 id="Java">Java Definitions</h3>
<pre>interface Timer {
    interface TimerCallback {
        void callback();
        void timerStopped();
    }
    interface TimerNode {
        void cancel();
        boolean isScheduled();
    }
    void scheduleAfterDelay(TimerNode timerNode,double delay);
    void schedulePeriodic(TimerNode timerNode,double delay,double period);
    void stop();
}

class TimerFactory {
    static public Timer create(String threadName, ThreadPriority priority);
    static public TimerNode createNode(TimerCallback timerCallback);
}</pre>

<h3 id="TimerCallb">TimerCallback</h3>

<p>This is an interface that must be implemented by the user. It has the
following methods: </p>
<dl>
  <dt style="font-family: courier;">callback</dt>
    <dd>This is called when a timer expires. This is called with no locks
      held. When called a delay timer is no longer on the queue but a
      periodioc timer is on a queue. Thus the callback for a delay timer can
      issue a new schedule request but a periodic timer must not. Note the
      explaination of TimerNode.cancel below.</dd>
  <dt style="font-family: courier;">timerStopped</dt>
    <dd>Timer.stop was called when a timer request was queued. or if the
      timer is stopped and a schedule request is made.</dd>
</dl>

<h3 id="TimerNode">TimerNode</h3>

<p>This is an interface implemented by TimerFactory. It is allocated by
calling TimerFactory.createNode. It is passed as an argument when scheduling
a callback. It has the single method:</p>
<dl>
  <dt style="font-family: courier;">cancel</dt>
    <dd>This is called to cancel a timer request. If a callback has been
      dequeued but the callback not called when cancel is called then a
      callback may still happen. New schedule requests can be made after a
      cancel request has been made.</dd>
  <dt style="font-family: courier;">isScheduled</dt>
    <dd>Is this node in the timerQueue.</dd>
</dl>

<h3 id="Timer1">Timer</h3>

<p>This is the interface for scheduling a timer callback. A timer is created
by calling TimerFactory.create. It has the methods:</p>
<dl>
  <dt style="font-family: courier;">scheduleAfterDelay</dt>
    <dd>A request to schedule a callback after a delay specified in seconds.
      If stop has been called then TimerCallback.timerStopped is called
      immediately.</dd>
  <dt style="font-family: courier;">schedulePeriodic</dt>
    <dd>Schedule a periodic callback. If stop has been called then
      TimerCallback.timerStopped is called immediately.</dd>
  <dt style="font-family: courier;">stop</dt>
    <dd>Stop the timer. The queue is emptied and TimerCallback.timerStopped
      is called for each element of the queue. Further schedule calls result
      in a call to TimerCallback.timerStopped. Once stopped a timer is no
      longer useful. A new timer must be created.</dd>
</dl>

<h3 id="TimerFacto">TimerFactory</h3>

<p>This is the factory that implements the Timer and TimerNode interfaces. It
has the methods:</p>
<dl>
  <dt style="font-family: courier;">create</dt>
    <dd>Create a new Timer.</dd>
  <dt style="font-family: courier;">createNode</dt>
    <dd>Create a TimerNode. A timerNode can be used to schedule any timer but
      a timeNode can only be on a single timer queue and only once on a given
      timer queue.</dd>
</dl>
<hr />

<h2 style="text-align: center;" id="BitSet1">BitSet</h2>
<hr />

<p>This is adapted from the java.util.BitSet. It adds serializable. See
java.util.BitSet for a description. This implementation adds the following
additional methods:</p>
<pre>    public boolean getAndSet(int bitIndex);
    public void set(BitSet src);
    public void or_and(BitSet set1, BitSet set2);</pre>

<p>where</p>
<dl>
  <dt>getAndSet</dt>
    <dd>gets and sets the bit at bitIndex.</dd>
  <dt>set</dt>
    <dd>fast copy operation from src to this bitSet</dd>
  <dt>or_and</dt>
    <dd>The result is the or of the current bitSet with the value of set1.and
      set2. The number of bits is the
    Math.max(set1.bitsInUse,set2.bitsInUse);</dd>
</dl>
<pre>    </pre>
<hr />

<h2 style="text-align: center;" id="Queue">Queue</h2>
<hr />

<p>This provides a queue which has an immutable capacity, which is specified
when the queue is created. When the queue is full the user code is expected
to keep using the current el;ement until a new free element becomes avalable.
This is used by pvData.monitor.</p>
<pre>public class QueueCreate&lt;T&gt; {
    public Queue&lt;T&gt; create(QueueElement&lt;T&gt;[] queueElements) {
        return new QueueImpl&lt;T&gt;(queueElements);
    }

    public QueueElement&lt;T&gt; createQueueElement(T object) {
        return new QueueElementImpl&lt;T&gt;(object);
    }
}

public interface QueueElement&lt;T&gt; {
    public T getObject();
}

public interface Queue&lt;T&gt; {
    void clear();
    int getNumberFree();
    int capacity();
    QueueElement&lt;T&gt; getFree();
    void setUsed(QueueElement&lt;T&gt; queueElement);
    QueueElement&lt;T&gt; getUsed();
    void releaseUsed(QueueElement&lt;T&gt; queueElement);
}</pre>

<p>A queueCreate instance is created via a call like the following:</p>
<pre> QueueCreate&lt;MyObject&gt; queueCreate = new QueueCreate&lt;MyObject&gt;();</pre>

<p>Once a queueCreate is available a queue instance is created via code like
the following:</p>
<pre>Queue&lt;MyObject&gt; queue create(MyObject[] myObjects) {
    QueueElement&lt;MyObject&gt;[] queueElements = new QueueElement[length];
    for(int i=0; i&lt;length; i++) {
        QueueElement&lt;MonitorElement&gt; queueElement =
                 queueCreate.createQueueElement(myObjects[i);
        queueElements[i] = queueElement;
    }
    return queueCreate.create(queueElements);
}</pre>

<p>The queue methods are:</p>
<dl>
  <dt style="font-family: courier;">clear</dt>
    <dd>Make the queue empty.</dd>
  <dt style="font-family: courier;">getNumberFree</dt>
    <dd>Get the number of fee elements in the queue.</dd>
  <dt style="font-family: courier;">capacity</dt>
    <dd>Get the capacity, i.e. the maximun number of elements the queue can
      hold.</dd>
  <dt style="font-family: courier;">getFree</dt>
    <dd>Get the next free element. Null is returned if no free elements are
      available. If a non null value is returned then the element belongs to
      the caller until setUsed is called.</dd>
  <dt style="font-family: courier;">setUsed</dt>
    <dd>Set a queue element used. This <span
      style="font-weight:bold;">must</span> be the element returned by the
      last call to getFree. </dd>
  <dt style="font-family: courier;">getUsed</dt>
    <dd>Get the next used element of null if no more used elements are
      available.</dd>
  <dt style="font-family: courier;">releaseUsed</dt>
    <dd>Set a queue element free. This must be the element returned by the
      last call to getUsed. </dd>
</dl>

<p>A producer calls getFree and setUsed via code like the following:</p>
<pre>   MyObject getFree() {
       QueueElement&lt;MyObject&gt; queueElement = queue.getFree();
       if(queueElement==null) return null;
       return queueElement.getObject();
  }</pre>

<p>A consumer calls getUsed and releaseUsed via code like the following:</p>
<pre>     while(true) {
         QueueElement&lt;MyObject&gt; queueElement = queue.getUsed();
         if(queueElement==null) break;
         MyObject myObject = queueElement.getObject();
         // do something with myObject
         queue.releaseUsed(queueElement);
     }</pre>
<hr />

<h2 style="text-align: center;" id="Destroyabl">Destroyable</h2>
<hr />

<p>This is a base interface used by many other interfaces.</p>
<pre>interface Destroyable  {
    void destroy();
}</pre>

<p>where</p>
<dl>
  <dt style="font-family: courier;">destroy</dt>
    <dd>Destroy the object.</dd>
</dl>
<hr />

<h2 style="text-align: center;" id="Serialize">Serialize</h2>
<hr />

<p>This is a helper class for serialization, which is required for sending
and receiving pvData over the nerwork.</p>
<pre>class SerializeHelper {
    static void writeSize(final int s, ByteBuffer buffer);
    static int readSize(ByteBuffer buffer);
    static void serializeString(final String value, ByteBuffer buffer);
    static void serializeSubstring(final String value,
         int offset, int length, ByteBuffer buffer);
    static String deserializeString(ByteBuffer buffer);
}</pre>

<p>where</p>
<dl>
  <dt style="font-family: courier;">writeSize</dt>
    <dd>Serialize the size.</dd>
  <dt style="font-family: courier;">readSize</dt>
    <dd>Deserialize the size.</dd>
  <dt style="font-family: courier;">serializeString</dt>
    <dd>Serialize a String.</dd>
  <dt style="font-family: courier;">serializeSubstring</dt>
    <dd>Serialize a substring.</dd>
  <dt style="font-family: courier;">deserializeString</dt>
    <dd>Deserialize a string.</dd>
</dl>
</body>
</html>
