<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
      "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="content-type" content="text/html; charset=iso-8859-1" />
  <title>EPICS PVData: misc</title>
</head>

<body>
<h1 style="text-align: center">EPICS PVData : misc<br />
package: org.epics.pvData.misc<br />
2009.04.16</h1>
CONTENTS 

<div class="toc">
<ul>
  <li><a href="#Overview">Overview</a></li>
  <li><a href="#Enumeratio">Enumeration</a></li>
  <li><a href="#Message">Message Support</a> 
    <ul>
      <li><a href="#Definition">Definitions</a></li>
      <li><a href="#MessageQue">MessageQueue</a></li>
    </ul>
  </li>
  <li><a href="#Thread">Thread Support</a> 
    <ul>
      <li><a href="#ThreadPrio">ThreadPriority</a></li>
      <li><a href="#ThreadCrea">ThreadCreate</a></li>
      <li><a href="#Executor">Executor</a></li>
    </ul>
  </li>
  <li><a href="#Time">Time Function Call</a></li>
  <li><a href="#Linked">Linked List</a></li>
</ul>
</div>
<hr />

<h2 style="text-align: center" id="Overview">Overview</h2>
<hr />

<p>This package provides utility code:</p>
<dl>
  <dt>Enumerated Support</dt>
    <dd>Support for an enumerated structure, which is a structure containing
      fields index, choice, and choices.</dd>
  <dt>Message Support</dt>
    <dd>Support for queuing messages to give to requesters.</dd>
  <dt>Thread Support</dt>
    <dd>ThreadCreate and Executor</dd>
  <dt>TimeFunction</dt>
    <dd>Time how long a function call requiresd.</dd>
  <dt>LinkedList</dt>
    <dd>A douuble linked list facility that requires the user to allocate a
      node. It is more efficient that ArrayList and does not require the
      implementation to allocate storage for the nodes.</dd>
</dl>
<hr />

<h2 style="text-align: center;" id="Enumeratio">Enumeration</h2>
<hr />

<p>Enumerated is a convenience interface for a structure that happens to be
an enumerated structure, which is a structure that has fields index, choice,
and choices. Index is an integer, choice is a string, and choices is an array
of strings. Both index and choice select one of the choices.</p>
<pre>    public interface Enumerated {
        PVInt getIndex();
        PVString getChoice();
        PVStringArray getChoices();
        PVStructure getPV();
    }

    public class EnumeratedFactory {
        public static void replacePVField(PVField pvField);
        public static Enumerated getEnumerated(PVField pvField);
    }</pre>

<p>where</p>
<dl>
  <dt>getIndex</dt>
    <dd>Returns the interface for field index.</dd>
  <dt>getChoice</dt>
    <dd>Returns the interface for field choice.</dd>
  <dt>getChoices</dt>
    <dd>Returns the interface for field choices.</dd>
  <dt>getPV</dt>
    <dd>Returns the interface for the PVStructure for the enumerated
      structure.</dd>
  <dt>replacePVField</dt>
    <dd>Replace the PVField implementation. The new implementation implements
      interface Enumerated and also replaces the implementations of fields
      index, choice, and choices. The new implementation updates index when
      choice is changed and choice when index is changed. If choices is
      changed the index is set to 0.</dd>
  <dt>getEnumerated</dt>
    <dd>If the field is an enumerated structure and replacePVField was called
      for the field then interface Enumerated is returned.</dd>
</dl>
<hr />

<h2 style="text-align: center;" id="Message">Message Support</h2>
<hr />

<h3 id="Definition">Definitions</h3>
<pre>    public class MessageNode {
        public String message;
        public MessageType messageType;
    }

    public interface MessageQueue {
        MessageNode get();
        boolean put(String message,MessageType messageType);
        boolean isEmpty();
        boolean isFull();
        void replaceFirst(String message,MessageType messageType);
        void replaceLast(String message,MessageType messageType);
        int getClearOverrun();
    }
    
    public class MessageQueueFactory {
        public static MessageQueue create(int size);
    }</pre>

<h3 id="MessageQue">MessageQueue</h3>

<p>This is for use by code that wants to handle messages without blocking
higher priority threads.</p>

<p>A messageNode is a class with two public data members:</p>
<dl>
  <dt style="font-family: courier;">message</dt>
    <dd>The message.</dd>
  <dt style="font-family: courier;">messageType</dt>
    <dd>The message type.</dd>
</dl>

<p>A messageQueue is an interface with methods:</p>
<dl>
  <dt style="font-family: courier;">put</dt>
    <dd>Put a new message into the queue. False is returned if the queue was
      full and true otherwise.</dd>
  <dt style="font-family: courier;">isEmpty</dt>
    <dd>Is the queue empty?</dd>
  <dt style="font-family: courier;">isFull</dt>
    <dd>Is the queue full?</dd>
  <dt style="font-family: courier;">replaceFirst</dt>
    <dd>Replace the oldest member in the queue.</dd>
  <dt style="font-family: courier;">replaceLast</dt>
    <dd>Replace the newest member in the queue.</dd>
  <dt style="font-family: courier;">getClearOverrun</dt>
    <dd>Get the number of times replaceFirst or replaceLast have been called
      since the last call to getClearOverrun. The internal counter is reset
      to 0.</dd>
</dl>

<p>MessageQueueFactory provides the public method:</p>
<dl>
  <dt style="font-family: courier;">create</dt>
    <dd>Create a MessageQueue and return the interface.</dd>
</dl>

<p>An example is:</p>
<pre>    private ExecutorNode executorNode;
    ...
      executorNode = executor.createNode(this);
    ...

    public void message(final String message, MessageType messageType) {
        boolean execute = false;
        synchronized(messageQueue) {
            if(messageQueue.isEmpty()) execute = true;
            if(messageQueue.isFull()) {
                messageQueue.replaceLast(message, messageType);
            } else {
                messageQueue.put(message, messageType);
            }
        }
        if(syncExec) {
            iocExecutor.execute(executorNode);
        }
    }
    ...
    public run() { // handle messages
        while(true) {
            String message = null;
            int numOverrun = 0;
            synchronized(messageQueue) {
                MessageNode messageNode = messageQueue.get();
                numOverrun = messageQueue.getClearOverrun();
                if(messageNode==null &amp;&amp; numOverrun==0) break;
                message = messageNode.message;
            }
            if(numOverrun&gt;0) {
                System.out.printf(String.format("%n%d missed messages&amp;n", numOverrun));
            }
            if(message!=null) {
               System.out.printf(String.format("%s%n",message));
            }
        }
    }</pre>
<hr />

<h2 style="text-align: center;" id="Thread">Thread Support</h2>
<hr />

<h3 id="ThreadPrio">ThreadPriority</h3>
<pre>    public enum ThreadPriority {
        lowest,
        lower,
        low,
        middle,
        high,
        higher,
        highest;
        
        public static final int[] javaPriority;
        public int getJavaPriority();
        public static int getJavaPriority(ThreadPriority threadPriority);
    }</pre>

<h3 id="ThreadCrea">ThreadCreate</h3>
<pre>    interface ThreadReady {
        void ready();
    }

    interface RunnableReady {
        void run(ThreadReady threadReady);
    }

    interface ThreadCreate {
        Thread create(String name, int priority, RunnableReady runnableReady);
        Thread[] getThreads();
    }
    
    public class ThreadCreateFactory {
        public static ThreadCreate getThreadCreate();
    }</pre>

<p>ThreadCreate provides two features:</p>
<ol>
  <li>Create does not return until ReadyRunnable.run calls
    ThreadReady.ready().</li>
  <li>A list of all active threads is kept. getThreads provides access to the
    list.</li>
</ol>

<h3 id="Executor">Executor</h3>

<p>An Executor is a thread that can execute any object that implements the
Java Runnable interface. The user can request that a single command be
executed. If the command is already in the list of commands to be executed it
is NOT added to the list when add is called.</p>
<pre>    public interface ExecutorNode {}

    public interface Executor {
        ExecutorNode createNode(Runnable command);
        void execute(ExecutorNode executorNode);
        void stop();
    }
    public class ExecutorFactory {
        static public Executor create(String name,ScanPriority priority);
    }</pre>
where 
<dl>
  <dt>createNode</dt>
    <dd>Create a ExecutorNode that can be passed to execute.</dd>
  <dt>execute</dt>
    <dd>Request that command be executed. If it is already on the run list
      nothing is done.</dd>
  <dt>stop</dt>
    <dd>Stop the thread and refuse additional execute requests.</dd>
</dl>
<hr />

<h2 style="text-align: center;" id="Time">Time Function Call</h2>
<hr />

<p>TimeFunction is a facility that measures the average number of seconds a
function call requires. When timeCall is called, it calls function in a loop.
It starts with a loop of one iteration. If the total elapsed time is less
then .1 seconds it increases the number of iterrations by a factor of 10. It
keeps repeating until the elapsed time is greater than .1 seconds. It returns
the average number of seconds per call.</p>
<pre>    public interface TimeFunctionRequester {
        void function();
    }

    public interface TimeFunction {
        double timeCall();
    }

    public class TimeFunctionFactory {
        public static TimeFunction create(TimeFunctionRequester requester);
    }</pre>
<hr />

<h2 style="text-align: center;" id="Linked">Linked List</h2>
<hr />

<p>LinkedList implements a double linked list that requires a user to
allocate the nodes. It is more efficent that ArrayList for implementing
stacks and queues. For lists that are traversed while new elements can be
added or removed, LinkedListArray provides a way to get an array of the
currrent elements without allocating a new array each time the array is
traversed.</p>

<p>LinkedListArray converts a LinkedList to an LinkNode array. The
implementation provided by LinkedListFactory only creates a new LinkNode
array w.en the number of elements in the linkedList passed to setNodes is
greater than the length of the current LinkNode array.</p>
<pre>    public interface LinkedListNode&lt;T&gt; {
        public T getObject();
        boolean isOnList();
    }   
    
    public interface LinkedList {
        void addTail(LinkedListNode&lt;T&gt; listNode);
        void addHead(LinkedListNode&lt;T&gt; listNode);
        void insertAfter(LinkedListNode&lt;T&gt; listNode,LinkedListNode&lt;T&gt; addNode);
        void insertBefore(LinkedListNode&lt;T&gt; listNode,LinkedListNode&lt;T&gt; addNode);
        LinkedListNode&lt;T&gt; removeTail();
        LinkedListNode&lt;T&gt; removeHead();
        void remove(LinkedListNode&lt;T&gt; listNode);
        void remove(T object);
        LinkedListNode&lt;T&gt; getHead();
        LinkedListNode&lt;T&gt; getTail();
        LinkedListNode&lt;T&gt; getNext(LinkedListNode&lt;T&gt; listNode);
        LinkedListNode&lt;T&gt; getPrev(LinkedListNode&lt;T&gt; listNode);
        boolean isEmpty();
        boolean contains(T object);
    }

    public interface LinkedListArray&lt;T&gt; {
        void setNodes(LinkedList&lt;T&gt; linkedList);
        LinkedListNode&lt;T&gt;[] getNodes();
        int getLength();
        void clear();
    }
    
    public class LinkedListCreate&lt;T&gt; {
        public static LinkedList&lt;T&gt; create();
        public static LinkedListNode&lt;T&gt; createNode(Object object);
        public static LinkedListArray&lt;T&gt; createArray();
    }</pre>

<p>LinkedListCreate is created as follows:</p>
<pre>    LinkedListCreate&lt;SomeObject&gt; = new LinkedListCreate&lt;SomeObject&gt;();</pre>

<p>The only way a node can be allocated is by calling
linkedListCreate.createNode(SomeObject object). The object passed to
createNode is what is returned by LinkedList.getObject.</p>

<p>A node can only be on one list at a time but can be put, at different
times, on different lists as long as they all hole the same type of
objects.</p>

<p>The class does not provide a lock but the user can synchronized via calls
like:</p>
<pre>    synchronized(linkedList) {
        linkedList.addTail(listNode);
    }</pre>

<p>The following is an example of how to use LinkedListArray.</p>
<pre>        LinkedListNode&lt;SomeObject&gt;[] nodes = null;
        int length = 0;
        synchronized(linkedList) {
            linkedListArray.setNodes(linkedList);
            nodes = linkedListArray.getNodes();
            length = linkedListArray.getLength();
        }
        for(int i=0; i&lt;length; i++) {
            SomeObject object = nodes[i].getObject();
            // do something with object
        }</pre>
</body>
</html>
