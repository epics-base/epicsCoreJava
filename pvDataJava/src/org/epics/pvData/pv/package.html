<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
      "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="content-type" content="text/html; charset=iso-8859-1" />
  <title>EPICS JavaIOC: pv</title>
</head>

<body>
<h1 style="text-align: center">EPICS PVData: pv<br />
package: org.epics.pvData.pv<br />
2009.08.31</h1>
CONTENTS 

<div class="toc">
<ul>
  <li><a href="#Overview">Overview</a></li>
  <li><a href="#Process">Process Variable Reflection</a> 
    <ul>
      <li><a href="#Type">Type</a></li>
      <li><a href="#Reflection">Reflection</a></li>
    </ul>
  </li>
  <li><a href="#PVField">PVField - Data Interfaces</a> 
    <ul>
      <li><a href="#PVField1">PVField</a></li>
      <li><a href="#Requester">Requester</a></li>
      <li><a href="#PVAuxInfo">PVAuxInfo</a></li>
      <li><a href="#PVListener">PVListener</a></li>
      <li><a href="#PVScalar">PVScalar and extensions</a></li>
      <li><a href="#Primitive">Primitive PVField types</a></li>
      <li><a href="#PVString">PVString</a></li>
      <li><a href="#PVArray">PVArray and Extensions</a> 
        <ul>
          <li><a href="#PVArray1">PVArray</a></li>
          <li><a href="#PVArray2">PVArray Extensions</a></li>
          <li><a href="#Complete">Complete set of PVArray Extensions</a></li>
        </ul>
      </li>
      <li><a href="#PVStructur">PVStructure</a></li>
      <li><a href="#PVRecord">PVRecord</a> 
        <ul>
          <li><a href="#Record">Record Locking</a></li>
        </ul>
      </li>
      <li><a href="#PVDataCrea">PVDataCreate</a></li>
      <li><a href="#PVDatabase">PVDatabase</a></li>
    </ul>
  </li>
  <li><a href="#Convert">Convert</a></li>
  <li><a href="#Examples">Examples</a> 
    <ul>
      <li><a href="#Accessing">Accessing PVData</a></li>
      <li><a href="#Creating">Creating PVData</a></li>
    </ul>
  </li>
</ul>
</div>
<hr />

<h2 style="text-align: center" id="Overview">Overview</h2>
<hr />

<p>This package has the complete set of enum, interface, and class
definitions that describe PVData. The implementation is provided in package
org.epics.pvData.factory.</p>

<p>A PVDatabase consists of a set of PVRecords. Each PVRecord has a unique
record name and is the top level PVStructure, which is a structured set of
PVFields. A PVRecord can be:</p>
<dl>
  <dt>locked</dt>
    <dd>Whenever a record is accessed it can be locked. The JavaIOC requires
      that a record be locked whenever it is accessed.</dd>
  <dt>monitored</dt>
    <dd>Any code can register to be called whenever the data for a field is
      modified. If the code listens for changes to a structure field it is
      notified whenever any scalar or array field in the structure is
      modified. PVField provides a method postPut, which must be called by
      the code that calls the put method of the PVField. Note the caller must
      call postPut because for array fields the array might be written in
      chunks. Only the caller knows when it is done.</dd>
  <dt>a message source</dt>
    <dd>Every PVField has a method message, which can be called by any code
      that has access to the PVField. Code can register to be called whenever
      a message is generated.</dd>
</dl>

<p>As mentioned a PVRecord has a structured set of fields. Each field has
code for accessing the field. The interface for each field is PVField or an
interace that extends PVField. Each field also has an introspection
interface, which is Field or an extension of Field. This package overview
describes the complete set of data and introspection interfaces.</p>

<p>This package also describes an interface Convert, which provides a rich
set of methods for converting and copying data between field.</p>

<p>The interface FieldCreate creates the introspection interfaces. The
interface PVDataCreate creates the PVField interfaces. Between them they
provide the ability to create every type of Field and PVField, i.e. they
provide a complete implemenation of pvData. It is also possible for other
code to provide implementations.</p>

<p>PVDatabase is an interface that provides access to a named set of top
level PVStructures and to a set of PVRecords. The named top level
PVStructures are mostly used to provide an initial set of fields for a
PVStructure field within a PVRecord.</p>

<p>The rest of this package overview describes all the interfaces provided by
this package. Again this package provides no implementations except for
enums. The implementation for all the interfaces is provided by package
org.epics.pvData.factory.</p>
<hr />

<h2 style="text-align: center" id="Process">Process Variable Reflection</h2>
<hr />

<p>Given a pvname, which consists of a record name and field name, it is
possible to introspect the field without requiring access to data. The
reflection and data interfaces are separate because the data may not be
available. For example when a client connects to a PV, the client library can
obtain the reflection information without obtaining any data. Only when a
client issues an I/O request will data be available. This separation is
especially important for arrays and structures so that a client can discover
the type without requiring that a large array or structure be transported
over the network.</p>

<h3 id="Type">Type</h3>

<p>The types are defined by the Java definitions:</p>
<pre>    enum Type {
        scalar,
        scalarArray,
        structure
    }

    enum ScalarType {
        pvBoolean,
        pvByte, pvShort, pvInt, pvLong,
        pvFloat,pvDouble,
        pvString;

        //Convenience methods
        public boolean isInteger();   // pvByte,...,pvLong
        public boolean isNumeric();    // pvByte,...pvDouble
        public boolean isPrimitive();  // pvBoolean,...pvDouble
        public static ScalarType getScalarType(String type);
    }</pre>

<h3 id="Reflection">Reflection</h3>

<p>This section defines the complete set of Java PV reflection interfaces.</p>
<pre>    
    interface Serializable {
        void serialize(ByteBuffer buffer);
        int getSerializationSize();
        void deserialize(ByteBuffer buffer);
    }

    interface Field extends Serializable{
        String getFieldName();
        Type getType();
        String toString();
        String toString(int indentLevel);
    } 

    interface Scalar extends Field {
        ScalarType getScalarType();
    }

    interface Array extends Field{
        ScalarType getElementType();
    }

    interface Structure extends Field{
        String[] getFieldNames();
        Field getField(String fieldName);
        int getFieldIndex(String fieldName);
        Field[] getFields();
    }

    interface FieldCreate {
        Field create(String fieldName,Field field);
        Scalar createScalar(String fieldName,ScalarType scalarType);
        Array createArray(String fieldName,ScalarType elementType);
        Structure createStructure(String fieldName, Field[] field);
    }</pre>

<p>The above definitions support the following:</p>
<dl>
  <dt>Serializable</dt>
    <dd>A Field can be serialized. This is requied for implementing Channel
      Access.</dd>
  <dt>Field</dt>
    <dd>A field: 
      <dl>
        <dt>Has a name.</dt>
        <dt>Has a Type.</dt>
        <dt>Can be converted to a string.</dt>
      </dl>
    </dd>
  <dt>Scalar</dt>
    <dd>A scalar has a scalarType</dd>
  <dt>Array</dt>
    <dd>The element type is a scalarType</dd>
  <dt>Structure</dt>
    <dd>Has fields that can be any of the supported types.</dd>
  <dt>FieldCreate</dt>
    <dd>This is an interface that provides methods to create introspection
      interfaces. A factory is provides to create FieldCreate.</dd>
</dl>
<hr />

<h2 style="text-align: center" id="PVField">PVField - Data Interfaces</h2>
<hr />

<p>This section defines the Java Interfaces for accessing the data within a
PV record.</p>

<h3 id="PVField1">PVField</h3>

<p>PVField is the base interface for accessing data. Every field of every
structure of every record instance has a PVField associated with it. A
structure and a record also has an associated PVField.</p>
<pre>    interface PVField extends Serializable, Requester {
        int getFieldOffset();
        int getNextFieldOffset();
        int getNumberFields();
        PVAuxInfo getPVAuxInfo();
        boolean isImmutable();
        void setImmutable();
        String getFullFieldName();
        String getFullName();
        Field getField();
        PVStructure getParent();
        PVRecord getPVRecord();
        void replacePVField(PVField newPVField);
        void renameField(String newName);
        boolean addListener(PVListener pvListener);
        void removeListener(PVListener pvListener);
        void postPut();
        String toString();
        String toString(int indentLevel);
    }</pre>

<p>where</p>
<dl>
  <dt>Requester</dt>
    <dd>PVField extends Requester which is described in the next
    sub-section.</dd>
  <dt>getFieldOffset</dt>
    <dd>Get offset of the PVField field within top level structure. Every
      field within the PVStructure has a unique offset. The top level
      structure has an offset of 0. The first field within the structure has
      offset equal to 1. The other offsets are determined by recursively
      traversing each structure of the tree. </dd>
  <dt>getNextFieldOffset</dt>
    <dd>Get the next offset. If the field is a scalar or array field then
      this is just offset + 1. If the field is a structure it is the offset
      of the next field after this structure. Thus (nextOffset - offset) is
      always equal to the total number of fields within the field. </dd>
  <dt>getNumberFields</dt>
    <dd>Get the total number of fields in this field. This is nextFieldOffset
      - fieldOffset. </dd>
  <dt>getPVAuxInfo</dt>
    <dd>Get the PVAuxInfo for this field. PVAuxInfo is described below.</dd>
  <dt>isImmutable</dt>
    <dd>Is the field immutable?</dd>
  <dt>setImmutable</dt>
    <dd>Make the field immutable. Once a field is immutable it can never be
      changed since there is no method to again make it mutable. This is an
      important design decision since it allows immutable array fields to
      share the internal primitive data array.</dd>
  <dt>getFullFieldName</dt>
    <dd>Get the full field name. This returns a name in the form "name.name
      ...". </dd>
  <dt>getFullName</dt>
    <dd>Get the full name. This returns a name in the form "recordName.name
      ...".</dd>
  <dt>getField</dt>
    <dd>Get the reflection interface for the data.</dd>
  <dt>getParent</dt>
    <dd>Get the interface for the parent or null if this is the PVRecord
      itself.</dd>
  <dt>getPVRecord</dt>
    <dd>Get the interface for the record that contains this field. This can
      be null.</dd>
  <dt>replacePVField</dt>
    <dd>Replace this PVField. This is called by support code that wants to
      replace the default implementation of a data field with it's own
      implementation.</dd>
  <dt>renameField</dt>
    <dd>Rename the field name.</dd>
  <dt>addListener</dt>
    <dd>Add A PVListener to this field. Whenever this field or any subfield
      if this field is modified the listener will be notified. PVListener is
      described below. Before a listener can call addListener it must first
      call PVRecord.registerListener. </dd>
  <dt>removeListener</dt>
    <dd>Remove a PVListener.</dd>
  <dt>postPut</dt>
    <dd>Post a change to a field. This must be called by any code that
      directly calls the put method of a field. In particular the
      ConvertFactory calls this.</dd>
  <dt>toString</dt>
    <dd>Converts the field data to a string. This is mostly for debugging
      purposes.</dd>
</dl>

<h3 id="Requester">Requester</h3>

<p>A PVField extends Requester. Requester is present so that when database
errors are found there is someplace to send a message. As will be seen below,
PVRecord provides methods to register message requesters. Also a PVDatabase
provides an identical method. Thus when a message is generated for a field it
is propagated up to the record with the full field name attached and then
propagated to the PVDatabase which sends the messages to the registered
requesters.</p>
<pre>    enum MessageType {info,warning,error,fatalError}

    interface Requester {
        String getRequesterName();
        void message(String message, MessageType messageType);
    }</pre>

<p>where</p>
<dl>
  <dt></dt>
  <dt>MessageType</dt>
    <dd>Type of message.</dd>
  <dt>Requester</dt>
    <dd>The default implementation is: 
      <ul>
        <li>getRequesterName<br />
          This is the full field name concatenated to the record name.</li>
        <li>message<br />
          For the default implementation, PVField prepends the full field
          name to the message and calls PVRecord.message. The default
          implementation for PVRecord either displays the message on stdout
          or stderr or gives the message to message requsters.</li>
      </ul>
    </dd>
</dl>

<h3 id="PVAuxInfo">PVAuxInfo</h3>

<p>AuxInfo (Auxillary Information) is information about a field that is
application specific. It will not be available outside the application that
implements the database. In particular it will not be made available to
Channel Access. It is used by the database itself to override the default
implementation of fields. The JavaIOC uses it for attaching support code.
Database Configuration and other tools can use it for configuration
information. Each Field and each PVField can have have an arbitrary number of
auxInfos. An auxInfo is a (key,PVScalar) pair where key is a string.</p>
<pre>    public interface PVAuxInfo {
        PVField getPVField();
        PVScalar createInfo(String key,ScalarType scalarType);
        Map&lt;String,PVScalar&gt; getInfos();
        PVScalar getInfo(String key);
        String toString();
        String toString(int indentLevel);
    }</pre>

<p>where</p>
<dl>
  <dt>getPVField</dt>
    <dd>Get the PVField to which this PVAuxInfo is attached.</dd>
  <dt>createInfo</dt>
    <dd>Create a new PVScalar of type scalarType.</dd>
  <dt>getInfos</dt>
    <dd>Get a map of all the auxInfos.</dd>
  <dt>getInfo</dt>
    <dd>Get the PVScalar with the specified key.</dd>
  <dt>toString</dt>
    <dd>Print all the auxInfos</dd>
</dl>

<h3 id="PVListener">PVListener</h3>

<p>A PVlistener can attach itself to any field or fields of a record. It will
be notified whenever a put is issued to the field, i.e. the field is
modified. If the field is a structure then the PVListener is notified
whenever that field or any subfield is modified.</p>
<pre>    public interface PVListener {
        void dataPut(PVField pvField);
        void dataPut(PVStructure requested,PVField pvField);
        void beginGroupPut(PVRecord pvRecord);
        void endGroupPut(PVRecord pvRecord);
        void unlisten(PVRecord pvRecord);
    }</pre>

<p>where</p>
<dl>
  <dt>dataPut(PVField pvField)</dt>
    <dd>pvField has been modified.</dd>
  <dt>dataPut(PVStructure requested,PVField pvField)</dt>
    <dd>pvField has been modified. Requested is the field to which the
      requester issued a pvField.addListener.</dd>
  <dt>beginGroup</dt>
    <dd>A related set of changes is being started.</dd>
  <dt>endGroup</dt>
    <dd>A related set of changes is done.</dd>
  <dt>unlisten</dt>
    <dd>The PVLister is being removed from the record. This is called when
      the record is being destroyed or when the record structure (not the
      data values) is being changed.</dd>
</dl>

<h3 id="PVScalar">PVScalar and extensions</h3>
<pre>    interface PVScalar extends PVField {
        Scalar getScalar();
    }</pre>

<h3 id="Primitive">Primitive PVField types</h3>

<p>The interfaces for primitive data types are:</p>
<pre>    interface PVBoolean extends PVScalar {
        boolean get();
        void put(boolean value);
    }

    interface PVByte extends PVScalar {
        byte get();
        void put(byte value);
    }

    interface PVShort extends PVScalar {
        short get();
        void put(short value);
    }

    interface PVInt extends PVScalar {
        int get();
        void put(int value);
    }

    interface PVLong extends PVScalar {
        long get();
        void put(long value);
    }

    interface PVFloat extends PVScalar {
        float get();
        void put(float value);
    }

    interface PVDouble extends PVScalar {
        double get();
        void put(double value);
    }</pre>

<h3 id="PVString">PVString</h3>

<p>The interface for string is:</p>
<pre>    interface PVString extends PVScalar {
        String get();
        void put(String value);
    }</pre>

<h3 id="PVArray">PVArray and Extensions</h3>

<h4 id="PVArray1">PVArray</h4>

<p><span style="font-family: courier">PVArray</span> is the base interface
for all the other PV Array interfaces. It extends PVField and provides the
additional methods:</p>
<pre>    interface PVArray extends PVField {
        Array getArray();
        int getLength();
        void setLength(int len);
        int getCapacity();
        void setCapacity(int len);
        boolean isCapacityMutable();
        void setCapacityMutable(boolean isMutable);
    }</pre>
<dl>
  <dt>getArray</dt>
    <dd>Return the Array introspection interface.</dd>
  <dt>getLength</dt>
    <dd>Get the current length. This is less that or equal to the
    capacity.</dd>
  <dt>setLength</dt>
    <dd>Set the length. If the PVField is not mutable then an exception is
      thrown. If this is greater than the capacity setCapacity is called.</dd>
  <dt>getCapacity</dt>
    <dd>Get the capacity, i.e. this is the sized of the underlying data
    array.</dd>
  <dt>setCapacity</dt>
    <dd>Set the capacity. The semantics are implementation dependent but
      typical semantics are as follows: If the capacity is not mutable an
      exception is thrown. A new data array is created and data is copied
      from the old array to the new array. </dd>
  <dt>isCapacityMutable</dt>
    <dd>Is the capacity mutable</dd>
  <dt>setCapacityMutable</dt>
    <dd>Specify if the capacity can be changed.</dd>
</dl>

<h4 id="PVArray2">PVArray Extensions</h4>

<p>The interface for each array type has get and put methods which have the
same arguments except for the data type. For example PVDoubleArray is:</p>
<pre>    public class DoubleArrayData {
        public double[] data;
        public int offset;
    }
    interface PVDoubleArray extends PVArray {
        int get(int offset, int len, DoubleArrayData data);
        int put(int offset, int len, double[]from, int fromOffset);
        void shareData(double[] from);
    }</pre>

<p>Get "exposes" it's internal array by setting data.data and data.offset.
The caller is responsible for copying the array elements. This violates the
principle that objects should not expose their internal data but is done for
efficency. For example it makes it possible to copy between arrays with
identical element types via a call to System.arraycopy without requiring an
intermediate array.</p>

<p>Both get and put return the number of elements actually transfered. The
arguments are:</p>
<dl>
  <dt>offset</dt>
    <dd>The offset in the PV array.</dd>
  <dt>len</dt>
    <dd>The maximum number of elements to transfer. The number actually
      transfered will be less than or equal to this value.</dd>
  <dt>data</dt>
    <dd>Get sets data.data to it's internal array and data.offset to the
      offset into the array. The caller is responsible for the actual data
      transfer.</dd>
  <dt>from</dt>
    <dd>The array from which the data is taken. This array is supplied by the
      caller</dd>
  <dt>fromOffset</dt>
    <dd>The offset in <span style="font-family: courier;">from</span></dd>
</dl>

<p>The caller must be prepared to make multiple calls to retrieve or put an
entire array. A caller should accept or put partial arrays. For example the
following reads an entire array:</p>
<pre>    double[] getArray(PVDoubleArray pv)
    {
        int len = pv.getLength();
        double[] storage = new double[len];
        DoubleArrayData data = new DoubleArrayData();
        int offset = 0;
        while(offset &lt; len) {
            int num = pv.get(offset,(len-offset),data);
            System.arraycopy(data.data,data.offset,storage,offset,num);
            offset += num;
        }
        return storage;
    } </pre>

<p>shareData results in the PVArray using the primitive array that is passed
to this method. This is most useful for immutable arrays. In this case the
caller must set the PVArray to be immutable. In the PVArray is not immutable
then it is the applications responsibility to coordinate accesss to the
array. Again this violates the principle that objects should not expose their
internal data but is imporant for immutable arrays. For example pvData and
the javaIOC define many enumerated structures where an enumerated structure
has three fields: index, choice, and choices. Choices is a PVStringArray that
holds the enumerated choices. Index is a PVInt that is the index of the
currently selected choice and choice is a PVString which is the currectly
selected choice. For many enumerated structures the choices is immutable.
Allowing the choices internal String[] to be shared between all the instances
of an enumerated structure saves on storage. An example is alarmSeverity.
Another reason for allowing shared data is so that an application which
processes an array can be separated into multiple modules that directly
access the internal data array of a PVArray. This can be required for
minimizing CPU overhead. In this case it is the applications responspibility
to coordinate access to the array.</p>

<h4 id="Complete">Complete set of PVArray Extensions</h4>
<pre>    public class BooleanArrayData {
        public boolean[] data;
        public int offset;
    }
    interface PVBooleanArray extends PVArray {
        int get(int offset, int len, BooleanArrayData data);
        int put(int offset, int len, boolean[]from, int fromOffset);
        void shareData(boolean[] from);
    }

    public class ByteArrayData {
        public byte[] data;
        public int offset;
    }
    interface PVByteArray extends PVArray {
        int get(int offset, int len, ByteArrayData data);
        int put(int offset, int len, byte[]from, int fromOffset);
        void shareData(byte[] from);
    }

    public class ShortArrayData {
        public short[] data;
        public int offset;
    }
    interface PVShortArray extends PVArray {
        int get(int offset, int len, ShortArrayData data);
        int put(int offset, int len, short[]from, int fromOffset);
        void shareData(short[] from);
    }

    public class IntArrayData {
        public int[] data;
        public int offset;
    }
    interface PVIntArray extends PVArray {
        int get(int offset, int len, IntArrayData data);
        int put(int offset, int len, int[]from, int fromOffset);
        void shareData(int[] from);
    }

    public class LongArrayData {
        public long[] data;
        public int offset;
    }
    interface PVLongArray extends PVArray {
        int get(int offset, int len, LongArrayData data);
        int put(int offset, int len, long[]from, int fromOffset);
        void shareData(long[] from);
    }

    public class FloatArrayData {
        public float[] data;
        public int offset;
    }
    interface PVFloatArray extends PVArray {
        int get(int offset, int len, FloatArrayData data);
        int put(int offset, int len, float[]from, int fromOffset);
        void shareData(float[] from);
    }

    public class DoubleArrayData {
        public double[] data;
        public int offset;
    }
    interface PVDoubleArray extends PVArray {
        int get(int offset, int len, DoubleArrayData data);
        int put(int offset, int len, double[]from, int fromOffset);
        void shareData(double[] from);
    }

    public class StringArrayData {
        public String[] data;
        public int offset;
    }
    interface PVStringArray extends PVArray {
        int get(int offset, int len, StringArrayData data);
        int put(int offset, int len, String[]from, int fromOffset);
        void shareData(String[] from);
    }</pre>

<h3 id="PVStructur">PVStructure</h3>

<p>The interface for a structure is:</p>
<pre>    interface PVStructure extends PVField {
        Structure getStructure();
        PVField[] getPVFields();
        PVField getSubField(String fieldName);
        PVField getSubField(int fieldOffset);
        void replacePVField(String fieldName,PVField newPVField);
        void appendPVField(PVField pvField);
        void removePVField(String fieldName);
        void postPut(PVField pvSubField);
        // the following are convenience methods
        PVBoolean getBooleanField(String fieldName);
        PVByte getByteField(String fieldName);
        PVShort getShortField(String fieldName);
        PVInt getIntField(String fieldName);
        PVLong getLongField(String fieldName);
        PVFloat getFloatField(String fieldName);
        PVDouble getDoubleField(String fieldName);
        PVString getStringField(String fieldName);
        PVStructure getStructureField(String fieldName,String structureName);
        PVArray getArrayField(String fieldName,Type elementType);
    }</pre>

<p>where</p>
<dl>
  <dt>getStructure</dt>
    <dd>Get the introspection interface for the structure.</dd>
  <dt>getPVFields</dt>
    <dd>Returns the array of subfields. The set of subfields must all have
      different field names.</dd>
  <dt>getSubField(String fieldName)</dt>
    <dd>Get a subField of a field. For a PVStructure a non-null result is
      returned if fieldName is a field of the PVStructure. The fieldName can
      be of the form name.name...</dd>
  <dt>getSubField(int fieldOffset)</dt>
    <dd>Get the field located a fieldOffset, where fieldOffset is relative to
      the top level structure. This returns null if the specified field is
      not located within this PVStructure.</dd>
  <dt>replacePVField</dt>
    <dd>Replace a subfield of a PVStructure.</dd>
  <dt>appendPVField</dt>
    <dd>Append pvField to the end of this PVStructure.</dd>
  <dt>removePVField</dt>
    <dd>Remove the specified field from this structure.</dd>
  <dt>postPut</dt>
    <dd>post a put to a subfield of this structure. It does not have to be a
      direct subfield.</dd>
  <dt>getBooleanField</dt>
    <dd>Look for fieldName. If found and it has the correct type return the
      interface. This and the following methods are convenience methods that
      allow a user to get the interface to a subfield without requiring
      introspection. fieldName can be of the form name.name...</dd>
  <dt>getByteField</dt>
    <dd>Look for fieldName. If found and it has the correct type return the
      interface.</dd>
  <dt>getShortField</dt>
    <dd>Look for fieldName. If found and it has the correct type return the
      interface.</dd>
  <dt>getIntField</dt>
    <dd>Look for fieldName. If found and it has the correct type return the
      interface.</dd>
  <dt>getLongField</dt>
    <dd>Look for fieldName. If found and it has the correct type return the
      interface.</dd>
  <dt>getFloatField</dt>
    <dd>Look for fieldName. If found and it has the correct type return the
      interface.</dd>
  <dt>getDoubleField</dt>
    <dd>Look for fieldName. If found and it has the correct type return the
      interface.</dd>
  <dt>getStringField</dt>
    <dd>Look for fieldName. If found and it has the correct type return the
      interface.</dd>
  <dt>getStructureField</dt>
    <dd>Look for fieldName. If found and it has the correct type return the
      interface.</dd>
  <dt>getArrayField</dt>
    <dd>Look for fieldName. If found and it has the correct type return the
      interface.</dd>
</dl>

<h3 id="PVRecord">PVRecord</h3>

<p>Each PVField is a field within a PVRecord:</p>
<pre>    interface PVRecord extends PVStructure {
        PVStructure getPVStructure();
        String getRecordName();
        void message(String message, MessageType messageType);
        void addRequester(Requester requester);
        void removeRequester(Requester requester);
        void lock();
        void unlock();
        void lockOtherRecord(PVRecord otherRecord);
        void beginGroupPut();
        void endGroupPut();
        void registerListener(PVListener pvListener);
        void unregisterListener(PVListener pvListener);
        boolean isRegisteredListener(PVListener pvListener);
        void removeEveryListener();
    }</pre>

<p>where</p>
<dl>
  <dt>getPVStructure</dt>
    <dd>Get the top level PVStructure for the record.</dd>
  <dt>getRecordName</dt>
    <dd>Returns the record name.</dd>
  <dt>message</dt>
    <dd>This can be called any code that has access to the record
    instance.</dd>
  <dt>addRequester</dt>
    <dd>Add a requester to receive messages.</dd>
  <dt>removeRequester</dt>
    <dd>Remove a message requester</dd>
  <dt>lock</dt>
    <dd>Lock the record. See next sub-section.</dd>
  <dt>unlock</dt>
    <dd>Unlock the record.</dd>
  <dt>lockOtherRecord</dt>
    <dd>While code has a record locked, It can also lock another record. If
      the other record is already locked than this record may be temporily
      unlocked and then relocked. The caller must call the unlock merthod of
      the other record when done with it. The implementation prevents
      deadlocks BUT code must not try to lock more than two records at the
      same time or deadlocks can occur.</dd>
  <dt>beginGroupPut</dt>
    <dd>Begin a group of puts. This results in all registered PVListeners
      being called.</dd>
  <dt>endGroupPut</dt>
    <dd>End a group of puts. This results in all registered PVListeners being
      called.</dd>
  <dt>registerListener</dt>
    <dd>Register a PVListener. This must be called before calling
      pvField.addListener.</dd>
  <dt>unregisterListener</dt>
    <dd>Unregister a listener. The listener will also be removed from all
      fields to which it is attached.</dd>
  <dt>isRegisteredListener</dt>
    <dd>Id the PVListener registered?</dd>
  <dt>removeEveryListener</dt>
    <dd>This must be called by any code that is deleting or changing the
      structure of a record.</dd>
</dl>

<h4 id="Record">Record Locking</h4>

<p>Whever code access a record it must be locked. The code for accessing a
record should use the following pattern:</p>
<pre>    pvRecord.lock();
    try {
       // access the record
    } finally {
        pvRecord.unlock();
    }</pre>

<p>Depending on the application, for example the JavaIOC, it may be required
that the thread does not block between lock and unlock.</p>

<h3 id="PVDataCrea">PVDataCreate</h3>

<p>PVDataCreate is an interface that provides methods that create PVField
interfaces. A factory is provided that creates PVDataCreate.</p>
<pre>interface PVDataCreate {
    PVField createPVField(PVStructure parent, Field field);
    PVField createPVField(PVStructure parent,String fieldName,PVField fieldToClone);
    PVScalar createPVScalar(PVStructure parent,Scalar scalar);
    PVScalar createPVScalar(PVStructure parent,String fieldName,ScalarType fieldType);
    PVScalar createPVScalar(PVStructure parent,String fieldName,PVScalar scalarToClone);
    PVArray createPVArray(PVStructure parent,Array array);
    PVArray createPVArray(PVStructure parent,String fieldName,ScalarType elementType);
    PVArray createPVArray(PVStructure parent,String fieldName,PVArray arrayToClone);
    PVStructure createPVStructure(PVStructure parent,
        Structure structure);
    PVStructure createPVStructure(PVStructure parent,String fieldName,
        Field[] fields);
    PVStructure createPVStructure(PVStructure parent,String fieldName,
        PVStructure structToClone);
    PVStructure createPVStructure(PVStructure parent,String fieldName,
        PVDatabase pvDatabase,String structureName);
    PVRecord createPVRecord(String recordName,
        Field[] fields);
    PVRecord createPVRecord(String recordName,
        PVStructure structToClone);
    PVRecord createPVRecord(String recordName,
        PVDatabase pvDatabase,String structureName);
    PVField[] flattenPVStructure(PVStructure pvStructure);
}</pre>
where 
<dl>
  <dt style="font-family: courier;">createPVField</dt>
    <dd>The PVField is created reusing the Field interface. Two methods are
      provided. Each calls the corresponding createPVScalar, createPVArray,
      or createPVStructure depending in the type os the last argument.</dd>
  <dt style="font-family: courier;">createPVScalar</dt>
    <dd>Creates an instance of a PVScalar. Three versions are supplied. The
      first is passed an introspection interface. The second provides the
      field name and the scalarType. The last provides a field name and a
      PVScalar to clone. The newly created PVScalar will have the same
      auxInfos as the original.</dd>
  <dt style="font-family: courier;">createPVArray</dt>
    <dd>Create an instance of a PVArray. Three versions are supplied. The
      first is passed an introspection interface. The second provides the
      field name and the elementType. The last provides a field name and a
      PVArray to clone. The newly created PVArray will have the same auxInfos
      as the original.</dd>
  <dt style="font-family: courier;">createPVStructure</dt>
    <dd>Create an instance of a PVStructure. Four methods are provided. The
      first method uses a previously created structure introspection
      interface. The second uses a Field array to initialize the sub-fields.
      The third initializes the subfields by cloning the fields contained in
      structToClone. The newly created sub-fields will have the same values
      and auxInfos as the original. If structToClone is null then the new
      structure is initialized to have 0 sub-fields. The last method clones
      the fields from a PVStructure obtained from a PVDatabase. </dd>
  <dt style="font-family: courier;">createPVRecord</dt>
    <dd>Create a record instance. Like createPVStructure, three methods are
      provided with semantics just like createPVStructure.</dd>
  <dt style="font-family: courier;">flattenPVStructure</dt>
    <dd>Create an array of PVFields for the fields in the PVStructure. The
      order is according to fieldOffset.</dd>
</dl>

<h3 id="PVDatabase">PVDatabase</h3>

<p>PVDatabase is an interface for accessing a PVData database. </p>

<p>A PVDatabase contains structures and records. Structures provided an easy
way to create an initial set of subfields of a structure field of record
instances. When a structure field of a record is defined as follows:</p>
<pre>    &lt;record name = ... /&gt;
        &lt;!-- other fields --&gt;
        &lt;structure name = "name" type = "structName" /&gt;
        &lt;!-- ... --&gt;
    &lt;/record&gt;</pre>

<p>Then the fields in the structure are initialized with a copy of the fields
in structure "structName". </p>

<p>The interface is:</p>
<pre>    interface PVDatabase extends Requester{
        PVDatabase getMaster();
        String getName();
        void mergeIntoMaster();
        PVRecord findRecord(String name);
        boolean addRecord(PVRecord pvRecord);
        boolean removeRecord(PVRecord pvRecord);
        PVRecord[] getRecords();
        PVStructure findStructure(String name);
        boolean addStructure(PVStructure pvStructure);
        boolean removeStructure(PVStructure pvStructure);
        PVStructure getStructures();
        void message(String message, MessageType messageType);
        void addRequester(Requester requester);
        void removeRequester(Requester requester);
        String[] recordList(String regularExpression);
        String[] structureList(String regularExpression);
        String recordToString(String regularExpression);
        String structureToString(String regularExpression);
    }</pre>

<p>where</p>
<dl>
  <dt>getMaster</dt>
    <dd>Get the master database. This is just a convenience mthhod.</dd>
  <dt>getName</dt>
    <dd>Get the name of the database.</dd>
  <dt>mergeIntoMaster</dt>
    <dd>Merge this database into the master database.</dd>
  <dt>findRecord</dt>
    <dd>Find a record. Null is returned if the record is not in the
    database.</dd>
  <dt>addRecord</dt>
    <dd>Add a record to the database.</dd>
  <dt>removeRecord</dt>
    <dd>Remove a record from the database.</dd>
  <dt>getRecords</dt>
    <dd>Get a array of all the records.</dd>
  <dt>findStructure</dt>
    <dd>Find a structure. Null is returned if the structure is not in the
      database.</dd>
  <dt>addStructure</dt>
    <dd>Add a structure to the database.</dd>
  <dt>removeStructure</dt>
    <dd>Remove a structure from the database.</dd>
  <dt>getStructures</dt>
    <dd>Get a array of all the structures.</dd>
  <dt>message</dt>
    <dd>Report a message. If no listeners are registered the messages are
      sent to System.out (info) or System.err (all other message types). If
      at least one requester is present then the messages are given to the
      requesters without writing to System.out or System.err. If the database
      is the master, the message is put of a queue that is emptied by another
      thread. This messages sent to the master do not block.</dd>
  <dt>addRequester</dt>
    <dd>Add a requester to receive messages.</dd>
  <dt>removeRequester</dt>
    <dd>Remove a requester.</dd>
  <dt>recordList</dt>
    <dd>Get a list of all records with names that match a regular
    expression.</dd>
  <dt>structureList</dt>
    <dd>Get a list of all structures with names that match a regular
      expression.</dd>
  <dt>recordToString</dt>
    <dd>Get a dump of all records with names that match a regular
    expression.</dd>
  <dt>structureToString</dt>
    <dd>Get a dump of all structures with names that match a regular
      expression.</dd>
</dl>
<hr />

<h2 style="text-align: center" id="Convert">Convert</h2>
<hr />

<p>NOTE about copying immutable array fields. If an entire immutable array
field is copied to another array that has the same elementType, both offsets
are 0, and the length is the length of the source array, then the shareData
method of the target array is called and the target array is set immutable.
Thus the source and target share the same primitive array.</p>

<p>This section describes the supported conversions between data types.</p>
<ul>
  <li>All supported types can be converted to a string. If you ask for a 100
    megabyte array to be converted to a string expect a lot of output.</li>
  <li>Conversion from a string to a scalar type.</li>
  <li>Conversion from an array of strings to an array of scalar types.</li>
  <li>Copy between the following types of scalar PVs 
    <ul>
      <li>Numeric type to another numeric type</li>
      <li>Both have the same type.</li>
      <li>Either is a string</li>
    </ul>
  </li>
  <li>Copy between PVArrays that satisfy one of the following. 
    <ul>
      <li>Numeric to numeric</li>
      <li>Both have the same type.</li>
      <li>Either is a string.</li>
    </ul>
  </li>
  <li>Conversions between numeric scalar types.</li>
  <li>Conversions between arrays of numeric type.</li>
  <li>Conversion between compatible structures.</li>
</ul>
<pre>    interface Convert {
        String getString(PVField pv, int indentLevel);
        String getString(PVField pv);
        void fromString(PVScalar pv,String from);
        void fromString(PVArray pv,String from);
        int fromStringArray(PVField pv,
             int offset, int len, String[]from, int fromOffset);
        int toStringArray(PVArray pv,
             int offset, int len, String[]to, int toOffset);
        boolean isCopyCompatible(Field from, Field to);
        void copy(PVField from,PVField to);
        boolean isCopyScalarCompatible(Field from, Field to);
        void copyScalar(PVField from, PVField to);
        boolean isCopyArrayCompatible(Array from, Array to);
        int copyArray(PVArray from, int offset, int len, PVArray to, int toOffset);
        boolean isCopyStructureCompatible(Structure from, Structure to);
        void copyStructure(PVStructure from, PVStructure to);
        // For the following the pv Type must be PVByte, ...., PVDouble
        byte toByte(PVField pv);
        short toShort(PVField pv);
        int   toInt(PVField pv);
        long  toLong(PVField pv);
        float toFloat(PVField pv);
        double toDouble(PVField pv);
        void fromByte(PVField pv, byte from);
        void  fromShort(PVField pv, short from);
        void  fromInt(PVField pv, int from);
        void  fromLong(PVField pv, long from);
        void  fromFloat(PVField pv, float from);
        void  fromDouble(PVField pv, double from);
// For the following the element type must be pvByte, ...., pvDouble
        int toByteArray(PVArray pv,
            int offset, int len, byte[]to, int toOffset);
        int toShortArray(PVArray pv,
            int offset, int len, short[]to, int toOffset);
        int toIntArray(PVArray pv,
            int offset, int len, int[]to, int toOffset);
        int toLongArray(PVArray pv,
            int offset, int len, long[]to, int toOffset);
        int toFloatArray(PVArray pv,
            int offset, int len, float[]to, int toOffset);
        int toDoubleArray(PVArray pv,
            int offset, int len, double[]to, int toOffset);
        int fromByteArray(PVArray pv,
            int offset, int len, byte[]from, fromOffset);
        int fromShortArray(PVArray pv,
            int offset, int len, short[]from, fromOffset);
        int fromIntArray(PVArray pv,
            int offset, int len, int[]from, fromOffset);
        int fromLongArray(PVArray pv,
            int offset, int len, long[]from, fromOffset);
        int fromFloatArray(PVArray pv,
            int offset, int len, float[]from, fromOffset);
        int fromDoubleArray(PVArray pv,
            int offset, int len, double[]from, fromOffset);
        void newLine(StringBuilder builder, int indentLevel);
    }</pre>

<p>The array methods all return the number of elements copied or converted.
This can be less than <span style="font-family: courier;">len</span> if the
PVField array contains less than len elements.</p>

<p><span style="font-family: courier;">newLine</span> is a convenience method
for code that implements <span style="font-family: courier;">toString</span>
It generates a newline and inserts blanks at the beginning of the newline.</p>
<hr />

<h2 style="text-align: center" id="Examples">Examples</h2>
<hr />

<h3 id="Accessing">Accessing PVData</h3>

<p>Assume that code wants to access two fields from a PVRecord:</p>
<dl>
  <dt>value</dt>
    <dd>Must be a PVDouble.</dd>
  <dt>timeStamp</dt>
    <dd>Just look for field with this name.</dd>
</dl>

<p>The following code uses introspection to get the desired information.</p>
<pre>String getValueAndTimeStamp(String recordName) {
    PVDatabase master = PVDatabaseFactory.getMaster():
    PVRecord pvRecord = master.findRecord(recordName);
    if(pvRecord==null) {
       return "record not found";
   }
   PVStructure pvStructure = pvRecord.getPVStructure();
   PVField valuePV = pvStructure.getSubField("value");
   if(valuePV==null) {
       return "value field not found";
   }
   if(valuePV.getField.getType!=Type.scalar) {
       return "value field is not a scalar";
   }
   Scalar scalar = (Scalar)valuePV.getField();
   if(scalar.getScalarType!=ScalarType.pvDouble) {
       return "value field is not a double";
   }
   PVDouble pvDouble = (PVDouble)valuePV;
   PVField timeStampPV = pvStructure.getSubField("timeStamp");
   if(timeStampPV==null) {
       return "timeStamp field not found";
   }
   double value = valuePV.get();
   return value + " timeStamp " + timeStampPV.toString();
}</pre>

<h3 id="Creating">Creating PVData</h3>

<p>Example of creating a scalar field.</p>
<pre>    PVDataCreate pvDataCreate = PVDataFactory.getPVDataCreate();
    PVDouble pvValue = pvDataCreate.createPVScalar(null,"value",ScalarType.pvDouble);</pre>

<p>Create a structure and put it into the master database.</p>
<pre>    PVDatabase master = PVDatabaseFactory.getMaster():
    FieldCreate fieldCreate = FieldFactory.getFieldCreate();
    PVDataCreate pvDataCreate = PVDataFactory.getPVDataCreate();

    Field[] fields = new Field[2];
    fields[0] = fieldCreate.createScalar("secondsSinceEpoch",ScalarType.pvLong);
    fields[1] = fieldeCreate.createScalar("nanoSeconds",ScalarType.pvInt);
    PVStructure pvStructure = pvDataCreate.createPVStructure(
        null,"timeStamp",fields);
    master.addStructure(pvStructure);</pre>

<p>Create a PVRecord that has a value field and a timeStamp. Use the
structure created in the previous example.</p>
<pre>    Field[] fields = new Field[2];
    fields[0] = fieldCreate.createScalar("value",ScalarType.pvDouble);
    PVStructure pvStructure = master.findStructure("timeStamp");
    fields[1] = fieldCreate.createStructure("timeStamp",pvStructure.getStructure.getFields();
    PVRecord pvRecord = pvDataCreate.createPVRecord("example",fields);</pre>
</body>
</html>
