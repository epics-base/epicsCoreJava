<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
      "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="content-type" content="text/html; charset=iso-8859-1" />
  <title>EPICS pvData: monitor</title>
</head>

<body>
<h1 style="text-align: center">EPICS pvData: monitor<br />
package: org.epics.pvData.monitor<br />
2009.08.26</h1>
CONTENTS 

<div class="toc">
<ul>
  <li><a href="#Overview">Overview</a></li>
  <li><a href="#Implementi">Implementing Monitor Support</a></li>
  <li><a href="#Implementi1">Implementing New Monitor Algorithms</a></li>
  <li><a href="#Monitor">Monitor Interfaces</a> 
    <ul>
      <li><a href="#Monitor1">Monitor</a></li>
      <li><a href="#MonitorEle">MonitorElement</a></li>
      <li><a href="#MonitorCre">MonitorCreator</a></li>
      <li><a href="#MonitorReq">MonitorRequester</a></li>
      <li><a href="#MonitorCre1">MonitorCreate</a></li>
      <li><a href="#MonitorAlg">MonitorAlgorithm</a></li>
      <li><a href="#MonitorQue">MonitorQueue</a></li>
    </ul>
  </li>
  <li><a href="#Monitor2">Monitor Implementation</a> 
    <ul>
      <li><a href="#BaseMonito">BaseMonitor</a></li>
      <li><a href="#Factorys">Factorys</a></li>
    </ul>
  </li>
  <li><a href="#Monitor3">Monitor Queue</a></li>
</ul>
</div>
<hr />

<h2 style="text-align: center" id="Overview">Overview</h2>
<hr />

<p>This package provides the ability to monitor changes to an arbitrary
subset of the fields in a record. It is of interest to developers not to
users.</p>

<p>Monitor developers fall into two types:</p>
<ol>
  <li>Implementing monitor support for systems that do not understand
    pvData.<br />
    This is discussed in the next section. </li>
  <li>Implementing new monitoring algorithms.<br />
    This is discussed in a later section. </li>
</ol>

<p>Developers who need to understand or implement implementations of monitors
will be interested in this package. For example it is used by CAJV4 to
implement server side monitors. The interfaces can be implemented by other
servers, for example the CAJV3 client implements a version of interface
Monitor that links to a version 3 EPICS IOC.</p>

<p>This package implements support for the following monitor algorithms:</p>
<dl>
  <dt>onPut</dt>
    <dd>A monitor is issued whenever an monitored field changes value. The
      only exception is that no monitor is issued if the only field that
      changes is the timeStamp.</dd>
  <dt>onChange</dt>
    <dd>The request structure must defined a field named value. Whenever that
      field changes value a monitor is issued.</dd>
  <dt>onAbsoluteChange</dt>
    <dd>The request structure must define a field named value and that field
      must be a numeric scalar. Whenever the absolute value of the field
      changes by more than a deadband a monitor is issued.</dd>
  <dt>onPercentChange</dt>
    <dd>The request structure must define a field named value and that field
      must be a numeric scalar. Whenever the absolute value of the field
      changes by more than a percentage deadband a monitor is issued.</dd>
</dl>

<p>Code can be written to implement other monitoring algorithms. The code can
extend BaseMonitor or provide a complete implemtation of Monitor.</p>
<hr />

<h2 style="text-align: center" id="Implementi">Implementing Monitor
Support</h2>
<hr />

<p>This section discusses how to implement monitor support for system that do
not understand pvData. An example is the caV3 support that allows a CAJv4
client to communicate with a V3 channel access server. Similar support could
be written for other systems.</p>

<p>The code that implements monitors is normally part of the code that
implements interface Channel, which is defined by CAJv4. See CAJv4 for
details. This package is only concerned with monitors. In order to implement
monitors code must implement Channel.createMonitor. This means that the
MonitorCreate, Monitor, and MonitorElement interfaces defined by this package
must be implemented. The semantics must model the semantics defined in this
package overview. Other than this there is not much to say.</p>
<hr />

<h2 style="text-align: center" id="Implementi1">Implementing New Monitor
Algorithms</h2>
<hr />

<p>This section discusses how to implement new monitor algorithms in addition
to the onPut, onChange, etc, implemented by this package, i. e. how to
implement a monitor algorithm for a CAJv4 server. The simplest way is to
extend BaseMonitor. The following is the code for MonitorOnPutFactory, which
is a simple example.</p>
<pre>public class MonitorOnPutFactory{
    private static final String name = "onPut";
    private static final MonitorOnPut monitorOnPut = new MonitorOnPut();

    public static MonitorCreate getMonitorCreate() {
        return monitorOnPut;
    }
    
    private static class MonitorOnPut implements MonitorCreate {
        /* (non-Javadoc)
         * @see org.epics.ioc.channelAccess.MonitorCreate#create(org.epics.ca.channelAccess.client.Channel, org.epics.ca.channelAccess.client.ChannelMonitorRequester, org.epics.pvData.pv.PVStructure, org.epics.pvData.pvCopy.PVCopy, int, org.epics.pvData.misc.Executor)
         */
        public Monitor create(
                PVRecord pvRecord,
                MonitorCreator monitorCreator,
                MonitorRequester monitorRequester,
                PVStructure pvOption,
                PVCopy pvCopy,
                int queueSize)
        {
            return new Monitor(pvRecord,monitorCreator,monitorRequester,pvCopy,queueSize);
        }
        /* (non-Javadoc)
         * @see org.epics.ioc.channelAccess.MonitorCreate#getName()
         */
        @Override
        public String getName() {
            return name;
        }
    }

    private static class Monitor extends BaseMonitor {
        private Monitor(
                PVRecord pvRecord,
                MonitorCreator monitorCreator,
                MonitorRequester monitorRequester,
                PVCopy pvCopy,
                int queueSize)
        {
            super(pvRecord,monitorCreator,monitorRequester,pvCopy,queueSize);
            PVStructure pvStructure = pvCopy.createPVStructure();
            PVField pvField = pvStructure.getSubField("timeStamp");
            if(pvField!=null) {
                timeStampOffset = pvField.getFieldOffset();
                afterTimeStampOffset = pvField.getNextFieldOffset();
            }
        }
        
        private int timeStampOffset = -1;
        private int afterTimeStampOffset = -1;
        /* (non-Javadoc)
         * @see org.epics.ioc.channelAccess.BaseMonitor#generateMonitor(org.epics.pvData.misc.BitSet)
         */
        @Override
        protected boolean generateMonitor(BitSet bitSet) {
            if(timeStampOffset&lt;0) return true;
            int first = bitSet.nextSetBit(0);
            int next = bitSet.nextSetBit(afterTimeStampOffset);
            if(first&gt;=timeStampOffset &amp;&amp; next==-1) return false;
            return true;
        }

    }
}</pre>

<p>The first part of the code, i.e.:</p>
<pre>private static final String name = "onPut";
    private static final MonitorOnPut monitorOnPut = new MonitorOnPut();

    public static MonitorCreate getMonitorCreate() {
        return monitorOnPut;
    }
    
    private static class MonitorOnPut implements MonitorCreate {
        /* (non-Javadoc)
         * @see org.epics.ioc.channelAccess.MonitorCreate#create(org.epics.ca.channelAccess.client.Channel, org.epics.ca.channelAccess.client.ChannelMonitorRequester, org.epics.pvData.pv.PVStructure, org.epics.pvData.pvCopy.PVCopy, int, org.epics.pvData.misc.Executor)
         */
        public Monitor create(
                PVRecord pvRecord,
                MonitorCreator monitorCreator,
                MonitorRequester monitorRequester,
                PVStructure pvOption,
                PVCopy pvCopy,
                int queueSize)
        {
            return new Monitor(pvRecord,monitorCreator,monitorRequester,pvCopy,queueSize);
        }
        /* (non-Javadoc)
         * @see org.epics.ioc.channelAccess.MonitorCreate#getName()
         */
        @Override
        public String getName() {
            return name;
        }
    }</pre>

<p>Is code that must be implemented in order to be compatible with
org.epics.ca.channelAccess.server.impl.ChannelServerFactory. In addition the
implementation must supply code that calls
ChannelServerFactory.getChannelServer.registerMonitor(MonitorXXXFactory.getMonitorCreate());
For another implementation just replace "onPut" by "onXXX" and "OnPut" by
"OnXXX" where XXX is a meaningfull name.</p>

<p>The implementation is normally only interested in the following arguments
to create:</p>
<dl>
  <dt><span style="font-family: Courier">pvCopy</span></dt>
    <dd>This is described in package org.epics.pvData.pvCopy. It provides
      access to the data being monitored.</dd>
  <dt><span style="font-family: Courier">pvOption</span></dt>
    <dd>This is used to describe monitoring options. It requires some
      standard options that are used by ChannelServer but can also provide
      information for the monitor implementation. Look at
      MonitorOnAbsoluteChange for an example. It requires a deadband. The
      client must provide information required by the implementation</dd>
</dl>

<p>In the implementation of Monitor the code must implement method
generateMonitor. It is called by BaseMonitor when a put is issued to a field
being monitored. The implementation decides if a monitor should be
generated.</p>

<p>If BaseMonitor does not have the correct semantics than the implementation
must completely implement Monitor but must still implement MonitorCreate.</p>
<hr />

<h2 style="text-align: center" id="Monitor">Monitor Interfaces</h2>
<hr />

<h3 id="Monitor1">Monitor</h3>

<p>This is the interface implemented by a factory that implements a
monitoring algorithm</p>
<pre>interface Monitor  {
    void destroy();
    void start();
    void stop();
    MonitorElement poll();
    void release(MonitorElement monitorElement);
}</pre>

<p>where</p>
<dl>
  <dt><span style="font-family: Courier">destroy</span></dt>
    <dd>destroy the monitor, i.e. release whatever resources are used by the
      implementation.</dd>
  <dt><span style="font-family: Courier">start</span></dt>
    <dd>Start monitoring. An initial monitor with all data modified must be
      generated.</dd>
  <dt><span style="font-family: Courier">stop</span></dt>
    <dd>Stop monitoring.</dd>
  <dt><span style="font-family: Courier">poll</span></dt>
    <dd>Called to get modified data. If no data has been modified since the
      last poll null is returned. </dd>
  <dt><span style="font-family: Courier">release</span></dt>
    <dd>release the element returned by the most recent poll request.</dd>
</dl>

<h3 id="MonitorEle">MonitorElement</h3>

<p>This is the interface returned by a call to poll.</p>
<pre>interface MonitorElement  {
    PVStructure getPVStructure();
    BitSet getChangedBitSet();
    BitSet getOverrunBitSet();
}</pre>

<p>where</p>
<dl>
  <dt><span style="font-family: Courier">getPVStructure</span></dt>
    <dd>The data structure.</dd>
  <dt><span style="font-family: Courier">getChangedBitSet</span></dt>
    <dd>The bitSet showing which fields of the PVStructure have changed since
      the previous poll request.</dd>
  <dt><span style="font-family: Courier">getOverrunBitSet</span></dt>
    <dd>the bitSey which shows which fields have been modified more than once
      since the last poll request.</dd>
</dl>

<h3 id="MonitorCre">MonitorCreator</h3>

<p>This is an interface implemented by the code that calls
MonitorCreate.create. </p>
<pre>interface MonitorCreator  {
    void remove(Monitor monitor);
}</pre>

<p>where</p>
<dl>
  <dt><span style="font-family: Courier">remove</span></dt>
    <dd>The monitor has been deleted. The MonitorCreater can clean up any
      resources it allocated for the monitor.</dd>
</dl>

<h3 id="MonitorReq">MonitorRequester</h3>

<p>This is the interface implemented by the code that request a monitor.</p>
<pre>interface MonitorRequester extends Requester {
    void monitorConnect(Monitor monitor, Structure structure);
    void monitorEvent(Monitor monitor);
    void unlisten();
}</pre>

<p>where</p>
<dl>
  <dt><span style="font-family: Courier">monitorConnect</span></dt>
    <dd>The monitor has connected to a PVRecord.</dd>
  <dt><span style="font-family: Courier">monitorEvent</span></dt>
    <dd>A monitor event has occured. Monitor.poll is called to get the
    data.</dd>
  <dt><span style="font-family: Courier">unlisten</span></dt>
    <dd>The server has been told to disconnect from the record. The
      MonitorRequster can no longer issue any requests except destroy until
      monitorConnect is again called.</dd>
</dl>

<h3 id="MonitorCre1">MonitorCreate</h3>

<p>This os a request to create a monitor.</p>
<pre>interface MonitorCreate  {
    String getName();
    Monitor create(
            PVRecord pvRecord,
            MonitorCreator monitorCreator,
            MonitorRequester monitorRequester,
            PVStructure pvOption,
            PVCopy pvCopy,
            int queueSize);
}</pre>

<p>where</p>
<dl>
  <dt><span style="font-family: Courier">getName</span></dt>
    <dd>Get the name of the algorithm implemented by the implementation.</dd>
  <dt><span style="font-family: Courier">create</span></dt>
    <dd>Create a monitor. The arguments are:</dd>
</dl>

<h3 id="MonitorAlg">MonitorAlgorithm</h3>

<p>The base interface implemented by any code that implements a monitor
algorithm.</p>
<pre>interface MonitorAlgorithm  {
    String getAlgorithmName(); 
}</pre>

<p>where</p>
<dl>
  <dt><span style="font-family: Courier">getAlgorithmName</span></dt>
    <dd>return the name of the algorithm.</dd>
</dl>

<h3 id="MonitorQue">MonitorQueue</h3>

<p>This is the interface implemented bt MonitorQueueFactory.</p>
<pre>interface MonitorQueue  {
    void clear();
    int getNumberFree();
    int capacity();
    MonitorElement getFree();
    void setUsed(MonitorElement monitorElement);
    MonitorElement getUsed();
    void releaseUsed(MonitorElement monitorElement);
}</pre>

<p>where</p>
<dl>
  <dt><span style="font-family: Courier">clear</span></dt>
    <dd>Set all elements of the queue free.</dd>
  <dt><span style="font-family: Courier">getNumberFree</span></dt>
    <dd>Get the number of free queue elements.</dd>
  <dt><span style="font-family: Courier">capacity</span></dt>
    <dd>Get the number of queue elements.</dd>
  <dt><span style="font-family: Courier">getFree</span></dt>
    <dd>Get a free queue element. If no free elements null is returned.</dd>
  <dt><span style="font-family: Courier">setUsed</span></dt>
    <dd>Set the latest element returned by getFree to used.</dd>
  <dt><span style="font-family: Courier">getUsed</span></dt>
    <dd>Get the oldest used element. Null is returned when there are no more
      used elements.</dd>
  <dt><span style="font-family: Courier">releaseUsed</span></dt>
    <dd>release the element returned by the latest call to getUsed.</dd>
</dl>
<hr />

<h2 style="text-align: center" id="Monitor2">Monitor Implementation</h2>
<hr />

<h3 id="BaseMonito">BaseMonitor</h3>
<pre>abstract public class BaseMonitor implements Monitor,PVCopyMonitorRequester{
    protected BaseMonitor(
            PVRecord pvRecord,
            MonitorCreator monitorCreator,
            MonitorRequester monitorRequester,
            PVCopy pvCopy,
            int queueSize);
    abstract protected boolean generateMonitor(BitSet changeBitSet);
}</pre>

<h3 id="Factorys">Factorys</h3>

<p>The following factorys are provided:</p>
<dl>
  <dt><span style="font-family: Courier">MonitorOnPutFactory</span></dt>
    <dd>generateMonitor returns true except when the only field that changed
      was timeStamp.</dd>
  <dt><span style="font-family: Courier">MonitorOnChangeFactory</span></dt>
    <dd>The data must have a field named value. generateMonitor only returns
      true if value changed.</dd>
  <dt><span
  style="font-family: Courier">MonitorOnAbsoluteChangeFactory</span></dt>
    <dd>The data must have a numeric scalar field named value and pvRequest
      must have a double scalar field named deadband. Whenever the change in
      absolute value of field value exceeds the deadband generateMonitor
      returns true. </dd>
  <dt><span
  style="font-family: Courier">MonitorOnPercentChangeFactory</span></dt>
    <dd>The data must have a numeric scalar field named value and pvRequest
      must have a double scalar field named deadband. Whenever the percent
      change in field value exceeds the deadband generateMonitor returns
      true. </dd>
</dl>
<hr />

<h2 style="text-align: center" id="Monitor3">Monitor Queue</h2>
<hr />
<pre>public class MonitorQueueFactory {
    public static MonitorQueue create(PVCopy pvCopy, int queueSize);
}</pre>

<p>This provides a complete implementaion of MonitorQueue.</p>
</body>
</html>
