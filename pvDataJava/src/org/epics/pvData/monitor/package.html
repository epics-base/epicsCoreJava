<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
      "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="content-type" content="text/html; charset=iso-8859-1" />
  <title>EPICS pvData: monitor</title>
</head>

<body>
<h1 style="text-align: center">EPICS pvData: monitor<br />
package: org.epics.pvData.monitor<br />
2009.09.04</h1>
CONTENTS 

<div class="toc">
<ul>
  <li><a href="#Overview">Overview</a></li>
  <li><a href="#Implementi">Implementing Monitor Support</a></li>
  <li><a href="#Implementi1">Implementing New Monitor Algorithms</a></li>
  <li><a href="#Monitor">Monitor Interfaces</a> 
    <ul>
      <li><a href="#Monitor1">Monitor</a></li>
      <li><a href="#MonitorEle">MonitorElement</a></li>
      <li><a href="#MonitorCre">MonitorCreator</a></li>
      <li><a href="#MonitorReq">MonitorRequester</a></li>
      <li><a href="#MonitorCre1">MonitorCreate</a></li>
      <li><a href="#MonitorAlg">MonitorAlgorithm</a></li>
      <li><a href="#MonitorQue">MonitorQueue</a></li>
    </ul>
  </li>
  <li><a href="#Monitor2">Monitor Implementation</a> 
    <ul>
      <li><a href="#AbstractMo">AbstractMonitor</a></li>
      <li><a href="#AbstractLo">AbstractLocalMonitor</a></li>
      <li><a href="#Factories">Factories</a></li>
    </ul>
  </li>
  <li><a href="#Monitor3">Monitor Queue</a></li>
</ul>
</div>
<hr />

<h2 style="text-align: center" id="Overview">Overview</h2>
<hr />

<p>MARTY: CHANGE AbstractMonitor:</p>
<ul>
  <li>updateCopySetBitSet to updateSet</li>
  <li>updateCopyFromBitSet to updateFromBitSet</li>
</ul>

<p>This package provides the ability to monitor changes to an arbitrary
subset of the fields in a record. It is of interest to developers not to
users.</p>

<p>The basic interface for monitoring is interface Monitor, which has four
methods: start, stop, poll, and release. Code that implements the client side
for monitors has code like the following:</p>
<pre>    //somewhere the following request is issued
    monitor.start();
    //somewhere the following is done:
    while(true) {
       MonitorElement monitorElement = monitor.poll();
       if(monitorElement==null) {
          // no elements in the queue. Do something.
       } else {
          // got a monitor. Handle the element and then
          monitor.release(monitorElement);
       }
    }</pre>

<p>This package provides the following support for monitors:</p>
<ol>
  <li>Implementing monitor support for systems that do not understand
    pvData.<br />
    This is discussed in the next section. The support is not much, just
    interface definitions.</li>
  <li>AbstractMonitor<br />
    A base class for monitoring pvData. It implements the code for handling
    monitor queues. </li>
  <li>AbstractLocalMonitor<br />
    This implements monitors for a local database, i.e. it directly connects
    to a PVRecord and listens for changes. It implements all abstract methods
    of AbstractMonitor except generateMonitor. It is the class that all the
    algorithms listed below extend. </li>
  <li>Implementing new monitoring algorithms for pvData.<br />
    Many algorithms can be implemented by extending AbstractLocalMonitor.</li>
  <li>Monitor Queues<br />
    This package provides a complete implementation of montor queues for
    pvData. </li>
</ol>

<p>Developers who need to understand or implement implementations of monitors
will be interested in this package. For example it is used by CAJV4 to
implement monitors. The interfaces can be implemented by other servers, for
example the CAJV3 client implements a version of interface Monitor that links
to a version 3 EPICS IOC.</p>

<p>This package implements support for the following monitor algorithms:</p>
<dl>
  <dt>onPut</dt>
    <dd>A monitor is issued whenever an monitored field changes value. The
      only exception is that no monitor is issued if the only field that
      changes is the timeStamp.</dd>
  <dt>onChange</dt>
    <dd>The request structure must defined a field named value. Whenever that
      field changes value a monitor is issued.</dd>
  <dt>onAbsoluteChange</dt>
    <dd>The request structure must define a field named value and that field
      must be a numeric scalar. Whenever the absolute value of the field
      changes by more than a deadband a monitor is issued.</dd>
  <dt>onPercentChange</dt>
    <dd>The request structure must define a field named value and that field
      must be a numeric scalar. Whenever the absolute value of the field
      changes by more than a percentage deadband a monitor is issued.</dd>
</dl>

<p>The monitor queue implementation provided by AbstractMonitor provides
support for the following queue sizes.</p>
<dl>
  <dt>-1</dt>
    <dd>No queue and no data is transfered. The client is just notified
      whenever a monitor occurs.</dd>
  <dt>0</dt>
    <dd>No queue. The entire set of requested data is given to the client
      whenever a monitor occurs.</dd>
  <dt>1</dt>
    <dd>No queue is kept but only modified data is sent to the client. The
      data may often change multiple times between times that the client
      receivers data but for applications like display managers this is what
      is wanted.</dd>
  <dt>&gt;=2</dt>
    <dd>A MonitiorQueue is used. Since a monitor queue has a fixed size over
      runs can still occur but are less likely. </dd>
</dl>
<hr />

<h2 style="text-align: center" id="Implementi">Implementing Monitor
Support</h2>
<hr />

<p>Monitor support for systems that do not understand pvData can be
implemented. The implementation itself must understand pvData. It creates a
set of PVField definitions that model the data representation of the system
it serves. An example is the caV3 support that allows a CAJv4 client to
communicate with a V3 channel access server. Similar support could be written
for other systems. See caV3.BaseV3ChannelMonitor as an example of what to
do.</p>

<p>Code that implements monitors for systems that use pvData is normally part
of the code that implements interface Channel, which is defined by CAJv4. See
CAJv4 for details. This package is only concerned with monitors. In order to
implement monitors code must implement Channel.createMonitor. This means that
the MonitorCreate, Monitor, and MonitorElement interfaces defined by this
package must be implemented. The semantics must model the semantics defined
in this package overview. Other than this there is not much to say.</p>
<hr />

<h2 style="text-align: center" id="Implementi1">Implementing New Monitor
Algorithms</h2>
<hr />

<p>This section discusses how to implement new monitor algorithms in addition
to the onPut, onChange, etc, implemented by this package, i. e. how to
implement a monitor algorithm for a CAJv4 server. The simplest way is to
extend AbstractLocalMonitor. The following is the code for
MonitorOnPutFactory, which is a simple example.</p>
<pre>public class MonitorOnPutFactory{
    private static final String name = "onPut";
    private static final MonitorOnPut monitorOnPut = new MonitorOnPut();

    public static MonitorCreate getMonitorCreate() {
        return monitorOnPut;
    }
    
    private static class MonitorOnPut implements MonitorCreate {
        /* (non-Javadoc)
         * @see org.epics.ioc.channelAccess.MonitorCreate#create(org.epics.ca.channelAccess.client.Channel, org.epics.ca.channelAccess.client.ChannelMonitorRequester, org.epics.pvData.pv.PVStructure, org.epics.pvData.pvCopy.PVCopy, int, org.epics.pvData.misc.Executor)
         */
        public Monitor create(
                PVRecord pvRecord,
                MonitorCreator monitorCreator,
                MonitorRequester monitorRequester,
                PVStructure pvOption,
                PVCopy pvCopy,
                int queueSize)
        {
            return new Monitor(pvRecord,monitorCreator,monitorRequester,pvCopy,queueSize);
        }
        /* (non-Javadoc)
         * @see org.epics.ioc.channelAccess.MonitorCreate#getName()
         */
        public String getName() {
            return name;
        }
    }

    private static class Monitor extends AbstractLocalMonitor {
        private Monitor(
                PVRecord pvRecord,
                MonitorCreator monitorCreator,
                MonitorRequester monitorRequester,
                PVCopy pvCopy,
                int queueSize)
        {
            super(pvRecord,monitorCreator,monitorRequester,pvCopy,queueSize);
            PVStructure pvStructure = pvCopy.createPVStructure();
            PVField pvField = pvStructure.getSubField("timeStamp");
            if(pvField!=null) {
                timeStampOffset = pvField.getFieldOffset();
                afterTimeStampOffset = pvField.getNextFieldOffset();
            }
        }
        
        private int timeStampOffset = -1;
        private int afterTimeStampOffset = -1;
        /* (non-Javadoc)
         * @see org.epics.ioc.channelAccess.AbstractMonitor#generateMonitor(org.epics.pvData.misc.BitSet)
         */
        protected boolean generateMonitor(BitSet bitSet) {
            if(timeStampOffset&lt;0) return true;
            int first = bitSet.nextSetBit(0);
            int next = bitSet.nextSetBit(afterTimeStampOffset);
            if(first&gt;=timeStampOffset &amp;&amp; next==-1) return false;
            return true;
        }

    }
}</pre>

<p>The first part of the code, i.e.:</p>
<pre>private static final String name = "onPut";
    private static final MonitorOnPut monitorOnPut = new MonitorOnPut();

    public static MonitorCreate getMonitorCreate() {
        return monitorOnPut;
    }
    
    private static class MonitorOnPut implements MonitorCreate {
        /* (non-Javadoc)
         * @see org.epics.ioc.channelAccess.MonitorCreate#create(org.epics.ca.channelAccess.client.Channel, org.epics.ca.channelAccess.client.ChannelMonitorRequester, org.epics.pvData.pv.PVStructure, org.epics.pvData.pvCopy.PVCopy, int, org.epics.pvData.misc.Executor)
         */
        public Monitor create(
                PVRecord pvRecord,
                MonitorCreator monitorCreator,
                MonitorRequester monitorRequester,
                PVStructure pvOption,
                PVCopy pvCopy,
                int queueSize)
        {
            return new Monitor(pvRecord,monitorCreator,monitorRequester,pvCopy,queueSize);
        }
        /* (non-Javadoc)
         * @see org.epics.ioc.channelAccess.MonitorCreate#getName()
         */
        public String getName() {
            return name;
        }
    }</pre>

<p>Is code that must be implemented in order to be compatible with
org.epics.ca.channelAccess.server.impl.ChannelServerFactory. In addition the
implementation must supply code that calls
ChannelServerFactory.getChannelServer.registerMonitor(MonitorXXXFactory.getMonitorCreate());
For another implementation just replace "onPut" by "onXXX" and "OnPut" by
"OnXXX" where XXX is a meaningfull name.</p>

<p>The implementation is normally only interested in the following arguments
to create:</p>
<dl>
  <dt><span style="font-family: Courier">pvCopy</span></dt>
    <dd>This is described in package org.epics.pvData.pvCopy. It provides
      access to the data being monitored.</dd>
  <dt><span style="font-family: Courier">pvOption</span></dt>
    <dd>This is used to describe monitoring options. It requires some
      standard options that are used by ChannelServer but can also provide
      information for the monitor implementation. Look at
      MonitorOnAbsoluteChange for an example. It requires a deadband. The
      client must provide information required by the implementation.</dd>
</dl>

<p>In the implementation of Monitor the code must implement method
generateMonitor. It is called by AbstractMonitor when a put is issued to a
field being monitored. The implementation decides if a monitor should be
generated.</p>

<p>If AbstractMonitor does not have the correct semantics than the
implementation must completely implement Monitor by extending AbstractMonitor
but must still implement MonitorCreate.</p>
<hr />

<h2 style="text-align: center" id="Monitor">Monitor Interfaces</h2>
<hr />

<h3 id="Monitor1">Monitor</h3>

<p>This is the interface implemented by a factory that implements a
monitoring algorithm</p>
<pre>interface Monitor extends Destroyable {
    void start();
    void stop();
    MonitorElement poll();
    void release(MonitorElement monitorElement);
}</pre>

<p>where</p>
<dl>
  <dt><span style="font-family: Courier">destroy</span></dt>
    <dd>destroy the monitor, i.e. release whatever resources are used by the
      implementation.</dd>
  <dt><span style="font-family: Courier">start</span></dt>
    <dd>Start monitoring. An initial monitor with all data modified must be
      generated.</dd>
  <dt><span style="font-family: Courier">stop</span></dt>
    <dd>Stop monitoring.</dd>
  <dt><span style="font-family: Courier">poll</span></dt>
    <dd>Called to get modified data. If no data has been modified since the
      last poll null is returned. </dd>
  <dt><span style="font-family: Courier">release</span></dt>
    <dd>release the element returned by the most recent poll request.</dd>
</dl>

<h3 id="MonitorEle">MonitorElement</h3>

<p>This is the interface returned by a call to poll.</p>
<pre>interface MonitorElement  {
    PVStructure getPVStructure();
    BitSet getChangedBitSet();
    BitSet getOverrunBitSet();
}</pre>

<p>where</p>
<dl>
  <dt><span style="font-family: Courier">getPVStructure</span></dt>
    <dd>The data structure.</dd>
  <dt><span style="font-family: Courier">getChangedBitSet</span></dt>
    <dd>The bitSet showing which fields of the PVStructure have changed since
      the previous poll request.</dd>
  <dt><span style="font-family: Courier">getOverrunBitSet</span></dt>
    <dd>the bitSey which shows which fields have been modified more than once
      since the last poll request.</dd>
</dl>

<h3 id="MonitorCre">MonitorCreator</h3>

<p>This is an interface implemented by the code that calls
MonitorCreate.create. </p>
<pre>interface MonitorCreator  {
    void remove(Monitor monitor);
}</pre>

<p>where</p>
<dl>
  <dt><span style="font-family: Courier">remove</span></dt>
    <dd>The monitor has been deleted. The MonitorCreater can clean up any
      resources it allocated for the monitor.</dd>
</dl>

<h3 id="MonitorReq">MonitorRequester</h3>

<p>This is the interface implemented by the code that request a monitor.</p>
<pre>interface MonitorRequester extends Requester {
    void monitorConnect(Monitor monitor, Structure structure);
    void monitorEvent(Monitor monitor);
    void unlisten();
}</pre>

<p>where</p>
<dl>
  <dt><span style="font-family: Courier">monitorConnect</span></dt>
    <dd>The monitor has connected to a PVRecord.</dd>
  <dt><span style="font-family: Courier">monitorEvent</span></dt>
    <dd>A monitor event has occured. Monitor.poll is called to get the
    data.</dd>
  <dt><span style="font-family: Courier">unlisten</span></dt>
    <dd>The server has been told to disconnect from the record. The
      MonitorRequster can no longer issue any requests except destroy until
      monitorConnect is again called.</dd>
</dl>

<h3 id="MonitorCre1">MonitorCreate</h3>

<p>This os a request to create a monitor.</p>
<pre>interface MonitorCreate  {
    String getName();
    Monitor create(
            PVRecord pvRecord,
            MonitorCreator monitorCreator,
            MonitorRequester monitorRequester,
            PVStructure pvOption,
            PVCopy pvCopy,
            int queueSize);
}</pre>

<p>where</p>
<dl>
  <dt><span style="font-family: Courier">getName</span></dt>
    <dd>Get the name of the algorithm implemented by the implementation.</dd>
  <dt><span style="font-family: Courier">create</span></dt>
    <dd>Create a monitor. The arguments are: 
      <dl>
        <dt><span style="font-family: Courier">pvRecord</span></dt>
          <dd>The record being monitored.</dd>
        <dt><span style="font-family: Courier">monitorCreator</span></dt>
          <dd>The code calling create. This may not be the monitor
          requster!!</dd>
        <dt><span style="font-family: Courier">monitorRequester</span></dt>
          <dd>The monitor requester. This is the code to which monitot events
            will be delivered.</dd>
        <dt><span style="font-family: Courier">pvOption</span></dt>
          <dd>The options. See pvData.xml.sxtructures.channelAccess.xml for
            examples. It includes the structures required by the algorithms
            onPut, onChange, etc. An algorithm implementation can defined the
            fields it requires.</dd>
        <dt><span style="font-family: Courier">pvCopy</span></dt>
          <dd>The PVCopy for the set of fields being monitored.</dd>
        <dt><span style="font-family: Courier">queueSize</span></dt>
          <dd>The queueSize. If AbstractMonitor is the base it defines the
            meaning as described previously.</dd>
      </dl>
    </dd>
</dl>

<h3 id="MonitorAlg">MonitorAlgorithm</h3>

<p>The base interface implemented by any code that implements a monitor
algorithm.</p>
<pre>interface MonitorAlgorithm  {
    String getAlgorithmName(); 
}</pre>

<p>where</p>
<dl>
  <dt><span style="font-family: Courier">getAlgorithmName</span></dt>
    <dd>return the name of the algorithm.</dd>
</dl>

<h3 id="MonitorQue">MonitorQueue</h3>

<p>This is the interface implemented bt MonitorQueueFactory.</p>
<pre>interface MonitorQueue  {
    void clear();
    int getNumberFree();
    int capacity();
    MonitorElement getFree();
    void setUsed(MonitorElement monitorElement);
    MonitorElement getUsed();
    void releaseUsed(MonitorElement monitorElement);
}</pre>

<p>where</p>
<dl>
  <dt><span style="font-family: Courier">clear</span></dt>
    <dd>Set all elements of the queue free.</dd>
  <dt><span style="font-family: Courier">getNumberFree</span></dt>
    <dd>Get the number of free queue elements.</dd>
  <dt><span style="font-family: Courier">capacity</span></dt>
    <dd>Get the number of queue elements.</dd>
  <dt><span style="font-family: Courier">getFree</span></dt>
    <dd>Get a free queue element. If no free elements null is returned.</dd>
  <dt><span style="font-family: Courier">setUsed</span></dt>
    <dd>Set the latest element returned by getFree to used.</dd>
  <dt><span style="font-family: Courier">getUsed</span></dt>
    <dd>Get the oldest used element. Null is returned when there are no more
      used elements.</dd>
  <dt><span style="font-family: Courier">releaseUsed</span></dt>
    <dd>release the element returned by the latest call to getUsed.</dd>
</dl>
<hr />

<h2 style="text-align: center" id="Monitor2">Monitor Implementation</h2>
<hr />

<h3 id="AbstractMo">AbstractMonitor</h3>
<pre>abstract public class BaseMonitor implements Monitor
{
    abstract PVStructure createPVStructure();
    abstract void startMonitoring();
    abstract void startMonitoring(BitSet changeBitSet,BitSet overrunBitSet);
    abstract void updateSetBitSet(PVStructure pvStructure,BitSet bitSet);
    abstract void updateFromBitSet(PVStructure pvStructure,BitSet bitSet);
    abstract void switchBitSets(BitSet changedBitSet,BitSet overrunBitSet);
    abstract protected boolean generateMonitor(BitSet changeBitSet);
    protected AbstractMonitor(
            MonitorCreator monitorCreator,
            MonitorRequester monitorRequester,
            int queueSize);
}</pre>

<p>This class implements all the Monitor methods. A derived class must
implement the following methods:</p>
<dl>
  <dt><span style="font-family: Courier">createPVStructure</span></dt>
    <dd>Create a structure to hold data.</dd>
  <dt><span style="font-family: Courier">startMonitoring</span></dt>
    <dd>Start monitoring. The version without arguments means thaty no data
      will be transfered, i.e. the client will only be notified of changes
      but no data will be sent. The other version means that the data will be
      sent. The implementation sets bits in the bitSet arguments to keep
      track of which fields have changes.</dd>
  <dt><span style="font-family: Courier">updateSetBitSet</span></dt>
    <dd>Update the pvStrcture by copying data from the underlying data to all
      fields of pvStructure that are different than the underlying data. Set
      bits in the bitSet for fields which are modified.</dd>
  <dt><span style="font-family: Courier">updateFromBitSet</span></dt>
    <dd>Update the pvStructure by copying data from the underlying data using
      bitSet to determine which fields to modfify.</dd>
  <dt><span style="font-family: Courier">switchBitSets</span></dt>
    <dd>Switch the bitSets for keeping track of changes.</dd>
  <dt><span style="font-family: Courier">generateMonitor</span></dt>
    <dd>Should a monitor be generated?</dd>
</dl>

<h3 id="AbstractLo">AbstractLocalMonitor</h3>
<pre>abstract public class AbstractLocalMonitor
extends AbstractMonitor implements PVCopyMonitorRequester
{
 protected AbstractLocalMonitor(
            PVRecord pvRecord,
            MonitorCreator monitorCreator,
            MonitorRequester monitorRequester,
            PVCopy pvCopy,
            int queueSize);
    protected PVRecord pvRecord;

    protected PVCopy pvCopy;
    protected PVStructure createPVStructure();
    protected void startMonitoring();
    protected void startMonitoring(BitSet changeBitSet,BitSet overrunBitSet);
    protected void updateSetBitSet(PVStructure pvStructure,BitSet bitSet);
    protected void updateFromBitSet(PVStructure pvStructure,BitSet bitSet);
    protected void switchBitSets(BitSet changedBitSet,BitSet overrunBitSet);
}</pre>

<p>Note that this implements all the abstract methods od AbstractMonitor
except generateMonitor. This it is the class extended by all the algorithms
implemented by this package and can be the base for other algorithms.</p>

<h3 id="Factories">Factories</h3>

<p>The following factories are provided:</p>
<dl>
  <dt><span style="font-family: Courier">MonitorOnPutFactory</span></dt>
    <dd>generateMonitor returns true except when the only field that changed
      was timeStamp.</dd>
  <dt><span style="font-family: Courier">MonitorOnChangeFactory</span></dt>
    <dd>The data must have a field named value. generateMonitor only returns
      true if value changed.</dd>
  <dt><span
  style="font-family: Courier">MonitorOnAbsoluteChangeFactory</span></dt>
    <dd>The data must have a numeric scalar field named value and pvRequest
      must have a double scalar field named deadband. Whenever the change in
      absolute value of field value exceeds the deadband generateMonitor
      returns true. </dd>
  <dt><span
  style="font-family: Courier">MonitorOnPercentChangeFactory</span></dt>
    <dd>The data must have a numeric scalar field named value and pvRequest
      must have a double scalar field named deadband. Whenever the percent
      change in field value exceeds the deadband generateMonitor returns
      true. </dd>
</dl>
<hr />

<h2 style="text-align: center" id="Monitor3">Monitor Queue</h2>
<hr />
<pre>public class MonitorQueueFactory {
    public static MonitorQueue create(MonitorElement[] monitorElements);
}</pre>

<p>This provides a complete implementaion of MonitorQueue.</p>
</body>
</html>
