<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
      "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="content-type" content="text/html; charset=iso-8859-1" />
  <title>EPICS PVData: xml</title>
</head>

<body>
<h1 style="text-align: center">EPICS PVData: xml<br />
package: org.epics.pvData.xml<br />
2010.04.15</h1>
CONTENTS 

<div class="toc">
<ul>
  <li><a href="#Overview">Overview</a></li>
  <li><a href="#Database">Database XML Syntax</a>
    <ul>
      <li><a href="#database">database</a></li>
      <li><a href="#auxInfo">auxInfo</a></li>
      <li><a href="#structure">structure and record</a></li>
      <li><a href="#package">package and import</a></li>
      <li><a href="#Field">Field definition</a></li>
      <li><a href="#Scalar">Scalar Types</a></li>
      <li><a href="#Enumerated">Enumerated Structure</a></li>
      <li><a href="#Examples">Examples</a></li>
      <li><a href="#Field1">Field Initialization</a></li>
      <li><a href="#Scalar1">Scalar Types</a></li>
      <li><a href="#string">string</a></li>
      <li><a href="#structure1">structure scalar</a></li>
      <li><a href="#structure2">structure</a></li>
      <li><a href="#array">array</a>
        <ul>
          <li><a href="#structureA">structureArray</a></li>
        </ul>
      </li>
      <li><a href="#Macro">Macro Substitution and Include</a></li>
      <li><a href="#Include">Include</a></li>
      <li><a href="#Macro1">Macro Substitution</a></li>
      <li><a href="#Example">Example Include and Macro Substitution</a></li>
    </ul>
  </li>
  <li><a href="#Database1">Database XML Code</a>
    <ul>
      <li><a href="#Warning">Warning About XML element syntax</a></li>
      <li><a href="#Java">Java Definitions</a></li>
      <li><a href="#PVDatabase">XML To PVDatabase</a>
        <ul>
          <li><a href="#XMLToPVDat">XMLToPVDatabaseFactory</a></li>
          <li><a href="#XMLToPVDat1">XMLToPVDatabaseListener</a></li>
        </ul>
      </li>
      <li><a href="#Include1">Include and Substitution</a></li>
      <li><a href="#IncludeSub">IncludeSubstituteXMLListener</a>
        <ul>
          <li><a
          href="#IncludeSub1">IncludeSubstituteDetailsXMLListener</a></li>
          <li><a href="#IncludeSub2">IncludeSubstituteXMLReader</a></li>
          <li><a
          href="#IncludeSub3">IncludeSubstituteXMLReaderFactory</a></li>
        </ul>
      </li>
    </ul>
  </li>
</ul>
</div>
<hr />

<h2 style="text-align: center" id="Overview">Overview</h2>
<hr />

<p>One way to create structures and records for a PVDatabase is via
XMLToPVDatabaseFactory, which parses structure and record definitions from an
xml file, creates structure and record instances and adds then to a
PVDatabase. This overview first defines the xml syntax and then interfaces
and code for reading the xml files.</p>
<hr />

<h2 style="text-align: center" id="Database">Database XML Syntax</h2>
<hr />

<h3 style="text-align:center;" id="database">database</h3>
A JavaIOC database file is an XML file with the following structure: 
<pre> &lt;?xml version="1.0" ?&gt;
&lt;database
   xmlns="urn:schemas-epics-org:javaioc:1.0"
   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
   xsi:schemaLocation="urn:schemas-epics-org:javaioc:1.0 javaioc.xsd"
   xmlns:model="urn:schemas-cosylab-com:model:1.0"
   name="database"&gt;
   &lt;!--  arbitrary set of structure and record definitions --&gt;
&lt;/database&gt;</pre>

<h3 style="text-align:center;" id="auxInfo">auxInfo</h3>

<p>An auxInfo defines additional information for a record, structure, or
field. It is for use by applications that require additional information for
a field. An arbitrary number of auxInfo can be created for any field. </p>

<p>An auxInfo is defined as follows:</p>
<pre>&lt;auxInfo name = "auxInfoName" scalarType = "scalarType"&gt;
   value
&lt;/auxInfo&gt;</pre>

<p>where:</p>
<dl>
  <dt><span style="font-family: courier">auxInfoName</span></dt>
    <dd>The auxInfo name.</dd>
  <dt><span style="font-family: courier">scalarType</span></dt>
    <dd>The type as described below.</dd>
  <dt><span style="font-family: courier">value</span></dt>
    <dd>The value as described below.</dd>
</dl>

<p>The following auxInfo is supported for every field:</p>
<pre>    &lt;auxInfo name = "pvReplaceFactory" scalarType = "string"&gt;
         value
    &lt;/auxInfobu&gt;</pre>

<p>value must be the name of a structure that provides the name of a factory
that will provide the PVField implementation.</p>

<h3 style="text-align:center;" id="structure">structure and record</h3>

<p>Structure definitions exist so that a structure field of a record can be
initialized with the fields of a previously defined structure definition. A
structure is defined as follows:</p>
<pre>&lt;structure structureName = "structureName" extends = "otherStructureName" &gt;
     &lt;!-- sequence of field --&gt;
&lt;/structure&gt;</pre>

<p>where:</p>
<dl>
  <dt><span style="font-family: courier">structureName</span></dt>
    <dd>The structure name.</dd>
  <dt><span style="font-family: courier">otherStructureName</span></dt>
    <dd>Optional. If given it must be the name of an already defined
      structure definition. The current structure will be initialized to have
      all attributes and fields of the other structure. The current structure
      can changed the attributes and fields and can append additional fields
      to the structure.</dd>
  <dt>field</dt>
    <dd>Zero or more fields can be defined. Each field must have a unique
      name. Order is important.</dd>
</dl>

<p>A record is a structure instance which has a record instance name. A
record is defined as follows:</p>
<pre>&lt;record recordName = "recordName" extends = "structureName" &gt;
     &lt;!-- sequence of field --&gt;
&lt;/structure&gt;</pre>

<p>where:</p>
<dl>
  <dt><span style="font-family: courier">recordName</span></dt>
    <dd>The record name. If the record with this name already exists then
      this definition can modify fields in the existing record but
      structureName must not be defined. recordName which must be
      specified,is a string with a combination of the following characters: 
      <ul>
        <li><span style="font-family: courier">0-9 A-Z a-z _ - : ; [
        ]</span></li>
        <li>Any Unicode/UTF-8 character outside of the Basic Latin set</li>
      </ul>
    </dd>
  <dt><span style="font-family: courier">structureName</span></dt>
    <dd>Optional. If given it must be the name of an already defined
      structure definition. The current record will be initialized to have
      all attributes and fields of the structure. The record can changed the
      attributes and fields and can append additional fields to the
      structure. The name should follow the same convention that Java uses
      for package names. See the next section for details.</dd>
</dl>

<h3 style="text-align:center;" id="package">package and import</h3>

<p>These two elements are both related to structures defined in the previous
section.</p>
<pre>&lt;package name = "packageName" /&gt;
&lt;import name = "packageName" /&gt;</pre>

<p>For both the packageName is of the form:</p>
<pre>     name.name...
     or for import
     name.name...*</pre>

<p>package applys to the structureName in a structure definition: For example
the following:</p>
<pre>&lt;package name = "org.epics.pvData" /&gt;
&lt;structure structureName = "alarm"&gt;
  &lt;!-- field definitions --&gt;
&lt;/structure&gt;</pre>

<p>Is the same as:</p>
<pre>&lt;structure structureName = "org.epics.pvData.alarm"&gt;
   &lt;!-- field definitions --&gt;
&lt;/structure&gt;</pre>

<p>import applys to extends structureNames in structure, record, and field
structure definitions. For example the following:</p>
<pre>&lt;import name = "org.epics.pvData.*" /&gt;
&lt;import name = "org.me.myStuff.*" /&gt;
&lt;record recordName = "xxx" extends = "myStructure"&gt;
    &lt;structure name = "alarm" extends = "alarm"&gt;
&lt;/record&gt;</pre>

<p>Is the same as:</p>
<pre>&lt;record recordName = "xxx" extends = "org.me.myStuff.myStructure"&gt;
    &lt;structure name = "alarm" extends = "org.epics.pvData.alarm"&gt;
&lt;/record&gt;</pre>
<pre></pre>

<h3 style="text-align:center;" id="Field">Field definition</h3>

<p>A field of a record or structure can have one of the following tag names:
scalar, scalarArray, or structure,.</p>

<p>A scalar field is defined as follows:</p>
<pre>  &lt;scalar name = "fieldName" scalarType = "scalarType"&gt;
     value
  &lt;/scalar&gt;</pre>

<p>where:</p>
<dl>
  <dt><span style="font-family: courier">fieldName</span></dt>
    <dd>The name of the field.</dd>
  <dt><span style="font-family: courier">scalarType</span></dt>
    <dd>The scalar type as defined below.</dd>
  <dt><span style="font-family: courier">value</span></dt>
    <dd>The value. The syntax is described below where scalar types are
      defined.</dd>
</dl>

<p>An array field is defined as follows:</p>
<pre>  &lt;array name = "fieldName" scalarType = "scalarType"
   capacity = "capacity" capacityMutable = "true/false" length = "length" offset = "offset"&gt;
     arrayValues
  &lt;/array&gt;</pre>

<p>where:</p>
<dl>
  <dt><span style="font-family: courier">fieldName</span></dt>
    <dd>The name of the field.</dd>
  <dt><span style="font-family: courier">scalarType</span></dt>
    <dd>The element type as defined below.</dd>
  <dt><span
  style="font-family: courier">capacity,capacityMutable,length,offset</span></dt>
    <dd>Each is these is optional.</dd>
  <dt><span style="font-family: courier">arrayValues</span></dt>
</dl>

<p>arrayValues is a comma separated set of values appropriate to the element
type. It can optionally be enclosed in []. Examples: </p>
<pre>     &lt;array name = "field0" scalarType = "double"&gt;
         2.3,5e10,66.0
     &lt;/array&gt;
     &lt;array name = "field1" scalarType = "double"&gt;
         [2.3,5e10,66.0]
     &lt;/array&gt;</pre>

<p>For all array elementTypes except string the convert library will remove
all white space so white space is permitted. If the elementType is string
then white space is not removed. Also each array element is not allowed to
have the character ','. What to do? Should also allow other escape sequences
like \n, etc.</p>

<p>A structure field is defined as follows:</p>
<pre>  &lt;structure name = "fieldName" extends = "structureName"&gt;
     &lt;!-- sequence of field --&gt;
  &lt;/structure&gt;</pre>

<p>where:</p>
<dl>
  <dt><span style="font-family: courier">fieldName</span></dt>
    <dd>The name of the field.</dd>
  <dt><span style="font-family: courier">structureName</span></dt>
    <dd>Optional. If given it must be the name of an already defined
      structure definition. The current record will be initialized to have
      all attributes and fields of the structure. The record can change the
      attributes and field values and append additional fields appended to
      the instance structure.</dd>
</dl>

<h3 style="text-align:center;" id="Scalar">Scalar Types</h3>
The scalar types are: <span style="font-family: courier">boolean</span>,
<span style="font-family: courier">byte</span>, <span
style="font-family: courier">short</span>, <span
style="font-family: courier">int</span>, <span
style="font-family: courier">long</span>, <span
style="font-family: courier">float</span>, <span
style="font-family: courier">double</span>, <span
style="font-family: courier">string</span>,<span
style="font-family: courier">structure</span>. 

<p>Thus all Java primitrive types except char are support and are implemented
via the corresponding Java type. Type string is implemented as a Java String.
</p>

<p>For example </p>
<pre>     
    &lt;scalar name = "value", scalarType = "double" /&gt;
    &lt;scalar name = "rawValue" scalarType = "int" /&gt;
    &lt;scalar name = "description" scalarType = "string" /&gt;</pre>

<p>value for scalar fields must be specified as follows:</p>
<dl>
  <dt><span style="font-family: courier">boolean</span></dt>
    <dd>Must be true or false.</dd>
  <dt><span style="font-family: courier">byte</span></dt>
    <dd>A valid Java long literal value that is cast to a byte</dd>
  <dt><span style="font-family: courier">short</span></dt>
    <dd>A valid Java long literal value that is cast to a short</dd>
  <dt><span style="font-family: courier">int</span></dt>
    <dd>A valid Java long literal value that is cast to a int</dd>
  <dt><span style="font-family: courier">long</span></dt>
    <dd>A valid Java long literal value</dd>
  <dt><span style="font-family: courier">float</span></dt>
    <dd>A valid Java float literal value</dd>
  <dt><span style="font-family: courier">double</span></dt>
    <dd>A valid Java double literal value</dd>
  <dt><span style="font-family: courier">string</span></dt>
    <dd>A valid Java string literal value</dd>
  <dt><span style="font-family: courier">structure</span></dt>
    <dd>If this is the first time the field is being crated than an extends
      must also be specified. The field will hold a PVStructure with a
      structure defined by extends. This value is just definitions for fields
      in the structure.</dd>
</dl>

<p>NOTE about byte, short, int. The syntax allows unsigned instead of signed
values for hex values. For example the following is legal syntax although
Java would complain.</p>
<pre>    &lt;scalar name = "mask" scalarType = "byte"&gt;0xff&lt;/scalar&gt;</pre>

<h3 style="text-align:center;" id="Enumerated">Enumerated Structure</h3>

<p>An enumerated structure is a structure that:</p>
<ol>
  <li>Has exactly two fields.</li>
  <li>The first field is named <span
    style="font-family: courier">index</span> and has scalarType <span
    style="font-family: courier">int</span></li>
  <li>The second field is named <span
    style="font-family: courier">choices</span> and is an array with element
    type <span style="font-family: courier">string</span></li>
</ol>

<p>If the current structure is an enumerated structure then the following
syntax is allowed:</p>
<pre>    &lt;scalar name = "choice"&gt;someChoice&lt;/scalar&gt;</pre>

<p>where <span style="font-family: courier">someChoice</span> must be one of
the elements of <span style="font-family: courier">choices</span>. This
results in the index field being initialized to the correct value. </p>

<h3 style="text-align:center;" id="Examples">Examples</h3>

<p>If <span style="font-family: courier;">fieldName</span> does not exist
then a new field can be created and appended to the end of the current
structure. In this case a new field will be appended to the end of the
structure in which this field appears. </p>

<p>For example:</p>
<pre>&lt;record recordName = "simple" &gt;
  &lt;scalar name = "value" scalarType = "double" /&gt;
&lt;/record&gt;</pre>

<p>Because the record definition does not specify a scalarType =
"structureName", it starts with the generic structure, which has no fields. A
field with name <span style="font-family: courier">value</span> does not
exist so it is created and appended to the structure. i.e. the record will
have a single field of type double and named "value".</p>

<p>The following creates a record which has a structure field that represents
a timeStamp..</p>
<pre>&lt;record recordName = "structureField" &gt;
  &lt;structure name = "timeStamp"&gt;
     &lt;scalar name = "secondsSinceEpoch" scalarType = "long"&gt;
     &lt;scalar name = "nanoSeconds" scalarType = "int"&gt;
  &lt;/structure&gt;
&lt;/record&gt;</pre>

<p>The following creates a record which has a field named output that is an
array of structures:</p>
<pre>&lt;record recordName = "complexExample"&gt;
  &lt;stucture name = "lotsOfStuff" &gt;
     &lt;scalar name = "value" scalarType = "double"&gt;
     &lt;structure name = "output"&gt;
         &lt;structure name = "0"&gt;
            &lt;scalar name = "dest" scalarType = "string"&gt;dest0&lt;/scalar&gt;
            &lt;stucture name = "otherInfo"&gt;
               &lt;!-- other defs --&gt;
            &lt;/structure&gt;
         &lt;/structure&gt;
         &lt;structure name = "1"&gt;
            &lt;scalar name = "dest" scalarType = "string"&gt;dest1&lt;/scalar&gt;
            &lt;stucture name = "otherInfo"&gt;
               &lt;!-- other defs --&gt;
            &lt;/structure&gt;
         &lt;/structure&gt;
      &lt;/structure&gt;
  &lt;/structure&gt;
&lt;/record&gt;</pre>

<h3 style="text-align:center;" id="Field1">Field Initialization</h3>

<p>If multiple field instance definitions appear then the last instance
determines how the field is initialized.</p>

<p>The syntax for the <span style="font-family: courier">initializer</span>
depends on the field type.</p>

<h3 id="Scalar1">Scalar Types</h3>

<p>For scalar types the initializer has the same format as the Java constants
for the type. For example if the type for field value is double:</p>
<pre>    &lt;scalar name = "value"&gt;.98&lt;/scalar&gt;</pre>

<p>Note: For integer data types <span
style="font-family: courier">Long.decode</span> is used to convert a string
to a long, which is then converted to the final integer data type . Thus hex
values are allowed. Java does not allow the sign bit to be set. By converting
first to a long all interger types except long can have the sign bit set. For
example the byte value 0xff is allowed even though Java would raise an
exception if Byte.decode was used. The sign problem does exist for long
values.</p>

<h3 id="string">string</h3>

<p>For string types the initializer is a valid Java string constant, which
can optionally be enclosed in quotes. For example:</p>
<pre>    &lt;scalar = "units"&gt;voltage&lt;/scalar&gt;</pre>

<h3 id="structure1">structure scalar</h3>

<p>A structure scalar field is initialized by giving field definitions for
any fields in the associated structure. For example assume that the following
structure definitions have been given:</p>
<pre>&lt;structure structureName = "test.point"&gt;
  &lt;scalar name = "x" scalarType = "double" /&gt;
  &lt;scalar name = "y" scalarType = "double" /&gt;
&lt;/structure&gt;

&lt;structure structureName = "test.testStructure"&gt;
    &lt;scalar name = "value" scalarType = "double"&gt;10.0&lt;/scalar&gt;
    &lt;structure name = "location" extends = "test.point" /&gt;
&lt;/structure&gt;</pre>

<p>Then the following creates a structure scalar field:</p>
<pre>&lt;record recordName = "structureScalarTest"&gt;
    &lt;structure name = "timeStamp" extends = "timeStamp" /&gt;
    &lt;scalar name = "value" scalarType = "structure" extends = "test.testStructure"&gt;
        &lt;scalar name = "value"&gt;100.0&lt;/scalar&gt;
        &lt;structure name = "location"&gt;
           &lt;scalar name = "x"&gt;1.0&lt;/scalar&gt;
            &lt;scalar name = "y"&gt;2.0&lt;/scalar&gt;&gt;
        &lt;/structure&gt;
    &lt;/scalar&gt;
&lt;/record&gt;</pre>

<h3 id="structure2">structure</h3>

<p>Structure fields are initialized via a recursive definition of field.</p>

<p>Assume the following structure definitions:</p>
<pre>    &lt;structure structureName = "doubleLimit"&gt;
        &lt;scalar name = "low" type ="double"/&gt;
        &lt;scalar name = "high" type ="double"/&gt;
   &lt;/structure&gt;

   &lt;structure structureName = "control"&gt;
     &lt;structure name = "limit" extends = "doubleLimit" /&gt;
     &lt;scalar name = "minStep" scalarType = "double" /&gt;
   &lt;/structure&gt;</pre>

<p>limit is initilized as follows:.</p>
<pre>    &lt;structure name = "control" extends = "control"&gt;
      &lt;structure name = "limit"&gt;
         &lt;scalar name = "low"&gt;0.0&lt;/scalar&gt;
         &lt;scalar name = "high"&gt;10.0&lt;/scalar&gt;
      &lt;/structure&gt;
      &lt;scalar name = "minStep"&gt;.1&lt;/scalar&gt;
   &lt;/structure&gt;</pre>

<p>It is permissible, in a database definition, to define a field to be a
structure without providing a structure name. In this case the default is
"null" which is a structure with no fields.</p>

<p>The default structure and auxInfo can be overridden when a field instance
is defined. The syntax is:</p>
<pre>    &lt;structure name = "fieldName" extends = "structureName"&gt;
       &lt;auxInfo name = "pvReplaceFactory" scalarType = "string"&gt;someFactory&lt;/auxinfo&gt;
    &lt;/structurte&gt;</pre>

<h3 id="array">array</h3>
The syntax for a array initializer is: 
<pre>    &lt;array name = "fieldName" scalarType = "scalarType"
    capacity = "capacity" capacityMutable = "true/false" length = "length" offset = "offset" &gt;
        valueList
    &lt;/array&gt;</pre>

<p>where</p>
<dl>
  <dt style="font-family: courier;">capacity</dt>
    <dd>The amount of storage to allocate for the array. This is optional and
      the capacity will be equal to the number of elements initialized. If
      the capacity is given a value &gt; 0 and capacityMutable is not
      specified then capacityMutable is set to true. </dd>
  <dt style="font-family: courier;">capacityMutable</dt>
    <dd>Can the capacity be changed?</dd>
  <dt style="font-family: courier;">length</dt>
    <dd>The initial length for the array.</dd>
  <dt style="font-family: courier;">offset</dt>
    <dd>The offset of the first element being defined.</dd>
  <dt style="font-family: courier;">valueList</dt>
    <dd>A list of values, which is a comma separated set of values.</dd>
  <dt></dt>
</dl>

<p>The following perform the same initialization:</p>
<pre>    &lt;array name = "intArray" scalarType = "double"&gt;
        0.0,1.0,0.0
    &lt;/array&gt;
    &lt;array name = "intArray" scalarType = "double" length = "3"&gt;
        0.0,1.0
    &lt;/array&gt;</pre>

<p>The following initializes an array of structures</p>
<pre>    &lt;complexArray name = "example"&gt;
      &lt;structure name = "structArray" &gt;
        &lt;structure name = "0" extends = "doubleLimit" &gt;
            &lt;scalar name = "low"&gt;0.0&lt;/scalar&gt;
            &lt;scalar name = "high"&gt;10.0&lt;/scalar&gt;
        &lt;/structure&gt;
        &lt;structure name = "1"  extends = "doubleLimit"&gt;
            &lt;scalar name = "low"&gt;-10.0&lt;/scalarmit&gt;
            &lt;scalar name = "high"&gt;10.0&lt;/scalar&gt;
        &lt;/structure&gt;
      &lt;/structure&gt;
    &lt;/array&gt;</pre>

<h4 id="structureA">structureArray</h4>

<p>The first time a structure array field is created an extends must also be
provided. The extended structure is used to create the array elements. For
example assume that the following structures have been defined:</p>
<pre>&lt;structure structureName = "test.point"&gt;
  &lt;scalar name = "x" scalarType = "double" /&gt;
  &lt;scalar name = "y" scalarType = "double" /&gt;
&lt;/structure&gt;

&lt;structure structureName = "test.testStructure"&gt;
    &lt;scalar name = "value" scalarType = "double"&gt;10.0&lt;/scalar&gt;
    &lt;structure name = "location" extends = "test.point" /&gt;
&lt;/structure&gt;</pre>

<p>Then the following creates a structure array</p>
<pre>&lt;record recordName = "structureArrayTest"&gt;
    &lt;structure name = "timeStamp" extends = "timeStamp" /&gt;
    &lt;array name = "value" scalarType = "structure" extends = "test.testStructure" capacity = "2"&gt;
       &lt;structure&gt;
          &lt;scalar name = "value"&gt;100.0&lt;/scalar&gt;
          &lt;structure name = "location"&gt;
             &lt;scalar name = "x"&gt;0.0&lt;/scalar&gt;
              &lt;scalar name = "y"&gt;0.0&lt;/scalar&gt;&gt;
          &lt;/structure&gt;
       &lt;/structure&gt;
        &lt;structure&gt;
          &lt;scalar name = "value"&gt;200.0&lt;/scalar&gt;
          &lt;structure name = "location"&gt;
             &lt;scalar name = "x"&gt;5.0&lt;/scalar&gt;
              &lt;scalar name = "y"&gt;10.0&lt;/scalar&gt;&gt;
          &lt;/structure&gt;
       &lt;/structure&gt;
       
    &lt;/array&gt;
&lt;/record&gt;</pre>

<h3 style="text-align:center;" id="Macro">Macro Substitution and Include</h3>

<h3 id="Include">Include</h3>
The XML file can include other files also containing Record Instance
Definitions. Included files can also include other files. The syntax is: 
<pre>    
&lt;include addPath = "path" removePath = "path" href = "filename" /&gt;</pre>

<p>Where</p>
<dl>
  <dt style="font-family: courier;">href</dt>
    <dd>The <span style="font-family: courier;">filename</span>, which must
      be a valid XML Record Instance file, is processed. If any addPaths have
      been defined the last one specified is prefixed to the filename.</dd>
  <dt style="font-family: courier;">addPath</dt>
    <dd>Add a path.</dd>
  <dt style="font-family: courier;">removePath</dt>
    <dd>Remove a path.</dd>
</dl>

<h3 id="Macro1">Macro Substitution</h3>

<p>Macro substitution replaces a string of the form "${from}" with some other
text. The syntax is:</p>
<pre>    &lt;substitute from = "fromString" to = "toString" fromTo = "from=to,from=to,..."/&gt;</pre>

<p>Where:</p>
<dl>
  <dt style="font-family: courier;">from</dt>
    <dd><span style="font-family: courier;">fromString</span> is the string
      that appears in ${from}. If <span
      style="font-family: courier;">from</span> is specified then <span
      style="font-family: courier;">to</span> must also be specified.</dd>
  <dt style="font-family: courier;">to</dt>
    <dd><span style="font-family: courier;">toString</span> replaces
    ${from}</dd>
  <dt style="font-family: courier;">toFrom</dt>
    <dd>The attribute value is a series of "from=to" pairs separated by
      commas.</dd>
</dl>

<p>Macro substitution can be performed on the foillowing:</p>
<ol>
  <li>Any attribute value in any element definition.</li>
  <li>The content of any element definition.</li>
</ol>

<p>NOTE: If a substitution is being performed and a substitute is not found
then if the value is found in the system environment table that value is
used.</p>

<h3 id="Example">Example Include and Macro Substitution</h3>

<p>The following is a template file:</p>
<pre>&lt;?xml version="1.0" ?&gt;
&lt;database&gt;
&lt;record recordName = "ai${recordExtension}Record"&gt;
    &lt;scalar name = "value" scalarType = "double"/&gt;
    &lt;structure name = "timeStamp" extends = "timeStamp"&gt;
    &lt;structure name = "alarm" extends = "alarm" /&gt;
    &lt;structure name = "input" extends = "linearConvertInput" &gt;
        &lt;structure name = "input" extends = "inputSupport"&gt;
            &lt;scalar name = "pvname"&gt;${pvname}&lt;/scalar&gt;
            &lt;scalar name = "wait"&gt;true&lt;/scalar&gt;
        &lt;/structure&gt;
        &lt;structure name = "linearConvert"&gt;
            &lt;scalar name = "engUnitsLow"&gt;${engUnitsLow}&lt;/scalar&gt;
            &lt;scalar name = "engUnitsHigh"&gt;${engUnitsHigh}&lt;/scalar&gt;
        &lt;/structure&gt;
    &lt;/structure&gt;
    &lt;structure name = "display" extends = "display" &gt;
        &lt;scalar name = "units"&gt;volts&lt;/scalar&gt;
        &lt;structure name = "limit"&gt;
            &lt;scalar name = "low"&gt;${displayLow}&lt;/scalar&gt;
            &lt;scalar name = "high"&gt;${displayHigh}&lt;/scalar&gt;
        &lt;/structure&gt;
    &lt;/structure&gt;
&lt;/record&gt;
&lt;/database&gt;
se&gt;</pre>

<p>The following creates two instance files from the template:</p>
<pre>&lt;?xml version="1.0" ?&gt;
&lt;database&gt;
&lt;include addPath = "src/org/epics/ioc/dbAccess/example" /&gt;
&lt;substitute from = "recordExtension" to = "01" /&gt;
&lt;substitute from = "pvname" to = "nameFor01" /&gt;
&lt;substitute from = "displayLow" to = "0.0" /&gt;
&lt;substitute from = "displayHigh" to = "10.0" /&gt;
&lt;substitute from = "engUnitsLow" to = "0.0" /&gt;
&lt;substitute from = "engUnitsHigh" to = "9.0" /&gt;
&lt;include href = "protoAiDB.xml" /&gt;
&lt;substitute fromTo = "recordExtension=02,pvname=nameFor02" /&gt;
&lt;include href = "protoAiDB.xml" /&gt;
&lt;/database&gt;</pre>
<hr />

<h2 style="text-align: center" id="Database1">Database XML Code</h2>
<hr />

<p>This section describes the Java support for converting files, which have
XML definitions for PVData structures and records, to PVDatabase PVStructures
and PVRecords.</p>

<p>The support has two components:</p>
<ol>
  <li>Include and Substitute<br />
    Support for macro substitution and include.</li>
  <li>XML to PVDatabase<br />
    Support that parsers the PVData XML statements. It uses the Include and
    Substitute support</li>
</ol>

<p>This section first shows the Java Definitions, then it discusses XML to
PVDatabase parsing, and last Include and Substitute.</p>

<h3 id="Warning">Warning About XML element syntax</h3>

<p>This is a warning for utility code that genetrates xml for PVData. The
problem is the special XML characters:</p>
<ul>
  <li>Less than &lt;</li>
  <li>Greater Than &gt;</li>
  <li>Quote "</li>
  <li>Apostrophe ''</li>
  <li>Ampersand &amp;</li>
</ul>

<p>These symbols are part of the xml syntax. This is a problem when the value
for a string is being defined. For example:</p>
<pre>    &lt;scalar name = "xxx" elementType = "string"&gt;value&lt;/scalar&gt;</pre>

<p>In order to set value = "a&lt;b" Then one of the following must be
entered.</p>
<pre>    &lt;scalar name = "xxx" elementType = "string"&gt;a&amp;lt;b&lt;/scalar&gt;</pre>

<p>or</p>
<pre>    &lt;scalar name = "xxx" elmentType = "string"&gt;&lt;![CDATA[a&lt;b]]&gt;&lt;/scalar&gt;</pre>

<p>I (Marty Kraimer) do not know how to determine, using SAX, what appears in
the original xml source file. What appears to the ContentHandler callback is
just the converted characters. What to do? One suggestion is that any code
that generates PVData xml should look at all string scalar and scalar array
element values. If any of the special XML characters are present then use
the&lt;![CDATA[value]]&gt; method of encoding the value.</p>

<h3 id="Java">Java Definitions</h3>
<pre>    class XMLToPVDatabaseFactory {
        static void convert(PVDatabase pvDatabase, String fileName,Requester requester,
            boolean reportSubstitutionFailure,
            XMLToPVDatabaseListener pvListener,
            IncludeSubstituteXMLListener isListener,
            IncludeSubstituteDetailsXMLListener detailsListener);
        static void convert(PVDatabase pvDatabase, String fileName,Requester requester);
    }

    interface XMLToPVDatabaseListener {
        void startStructure(PVStructure pvStructure);
        void endStructure();
        void startRecord(PVRecord pvRecord);
        void endRecord(); 
        void newStructureField(PVStructure pvStructure);
        void endStructureField();
        void startArray(PVArray pvArray);
        void endArray();
        void startScalar(PVScalar pvScalar);
        void endScalar();
        void startAuxInfo(String name,Map&lt;String,String&gt; attributes);
        void endAuxInfo();
    }

    interface IncludeSubstituteXMLListener {
        void endDocument();
        void startElement(String name, Map&lt;String,String&gt; attributes);
        void element(String content);
        void endElement(String name);
    }

    interface IncludeSubstituteDetailsXMLListener {
        void startElementBeforeSubstitution(String name, Map&lt;String,String&gt; attributes);
        void elementBeforeSubstitution(String content);
        void newSourceFile(String fileName);
        void endSourceFile();
        void addPath(String pathName);
        void removePath(String pathName);
        void substitute(String from,String to);
        void removeSubstitute(String from);
    }
    
    interface IncludeSubstituteXMLReader {
        void parse(String rootElementName,String fileName,Requester requester,
            boolean reportSubstitutionFailure,
            IncludeSubstituteXMLListener listener,
            IncludeSubstituteDetailsXMLListener detailsListener);
        void message(String message,MessageType messageType);
    }

    class IncludeSubstituteXMLReaderFactory {
        static public IncludeSubstituteXMLReader getReader();
    }</pre>

<h3 id="PVDatabase">XML To PVDatabase</h3>

<p>This support processes PVData XML statements. Code that wants to parse
PVData XML statements calls one of the XMLToPVDatabaseFactory.convert
methods. The only difference between the two methods is that the first
provides access to detailed information about parsing while the second only
provides errors..</p>

<h4 id="XMLToPVDat">XMLToPVDatabaseFactory</h4>

<p>This provides two methods both named convert. The first provides detailed
information about parsing. It is intended for use by VDCT. The second reports
all errors including substitution failues but none of the detailed
information. The arguments for the first method are:</p>
<dl>
  <dt><span style="font-family: Courier">pvDatabase</span></dt>
    <dd>The PVDatabase into which structure and record instances are put.</dd>
  <dt><span style="font-family: Courier">fileName</span></dt>
    <dd>The name of the XML file.</dd>
  <dt><span style="font-family: Courier">requester</span></dt>
    <dd>The Requester interface which must be implemented by the caller.</dd>
  <dt><span style="font-family: Courier">reportSubstitutionFailure</span></dt>
    <dd>Should substitution failures be reported?</dd>
  <dt><span style="font-family: Courier">pvListener</span></dt>
    <dd>The XMLToPVDatabaseListener interface, which can be null. If
      implemented the caller is notified when PV XML elements have been
      parsed.</dd>
  <dt><span style="font-family: Courier">isListener</span></dt>
    <dd>The IncludeSubstituteXMLListener interface, which can be null.
      XMLToPVDatabaseFactory implements it's own version but will also call
      this instance if implemented.See the interface description below for
      details.</dd>
  <dt><span style="font-family: Courier">detailsListener</span></dt>
    <dd>The IncludeSubstituteDetailsXMLListener interface, which can be
    null.</dd>
</dl>

<h4 id="XMLToPVDat1">XMLToPVDatabaseListener</h4>

<p>This provides a callback for the beginning and end of the parsing of
PVData XML elements not related to macro substitution and include. It
provides the following methods:</p>
<dl>
  <dt><span style="font-family: Courier">startStructure</span></dt>
    <dd>A new structure instance is being created.</dd>
  <dt><span style="font-family: Courier">endStructure</span></dt>
    <dd>The definition of the new structure is complete.</dd>
  <dt><span style="font-family: Courier">startRecord</span></dt>
    <dd>A new record instance is being created or an existing record is being
      modified.</dd>
  <dt><span style="font-family: Courier">endRecord</span></dt>
    <dd>The definition on the new or existing record is complete.</dd>
  <dt><span style="font-family: Courier">newStructureField</span></dt>
    <dd>A new structure field is being created.</dd>
  <dt><span style="font-family: Courier">endStructureField</span></dt>
    <dd>The definition on the new structure field is complete</dd>
  <dt><span style="font-family: Courier">startArray</span></dt>
    <dd>A new array field is being created.</dd>
  <dt><span style="font-family: Courier">endArray</span></dt>
    <dd>The definition on the new array field is complete</dd>
  <dt><span style="font-family: Courier">startScalar</span></dt>
    <dd>A new scalar field is being created.</dd>
  <dt><span style="font-family: Courier">endScalar</span></dt>
    <dd>The definition on the new scalar field is complete</dd>
  <dt><span style="font-family: Courier">startAuxInfo</span></dt>
    <dd>A new auxInfo is being created.</dd>
  <dt><span style="font-family: Courier">endAuxInfo</span></dt>
    <dd>The definition on the new auxInfo is complete</dd>
</dl>

<h3 id="Include1">Include and Substitution</h3>

<p>This support completely handles all details of Macro Substitution and
Include. The code that calls this support sees only the results of
substitution and include.. This support also implements the SAX2
ContentHandler and EventHandler interfaces. Instead of the SAX2 interfaces,
code that uses this code must implement at least the
IncludeSubstituteXMLListener interface. Support that wants additional
information can also implement the IncludeSubstituteDetailsXMLListener
interface. This code, in addition to macro substitution, provides a
simplified version of what SAX2 provides, which also means that it does not
provide access to all of SAX2. </p>

<p>This code does not understand the complete pvData XML syntax. It only
understands the include, substitute, package, and import elements. Thus it
could be used by code other than XML to PVDatabase but any such code must
realize that it does not provide access to all of SAX2.</p>

<h3 id="IncludeSub">IncludeSubstituteXMLListener</h3>

<p>This interface must be implemented by the caller. It is a simplified
version of the SAX2 ContentHandler. The methods are:</p>
<dl>
  <dt><span style="font-family: Courier">endDocument</span></dt>
    <dd>The end of the xml input file. This is NOT called for included
    files.</dd>
  <dt><span style="font-family: Courier">startElement</span></dt>
    <dd>The opening tag of an xml element is being processed.</dd>
  <dt><span style="font-family: Courier">element</span></dt>
    <dd>The value of an xml element, i.e. what appears between the opening
      and closing tags. Any leading and trailing white space of any element
      fragment is removed.</dd>
  <dt><span style="font-family: Courier">endElement</span></dt>
    <dd>The end tag opf an xml element is being processed.</dd>
</dl>

<h4 id="IncludeSub1">IncludeSubstituteDetailsXMLListener</h4>

<p>This interface can optionally be implemented by the caller. It provides
details about include and substitution details. The methods are:</p>
<dl>
  <dt><span
  style="font-family: Courier">startElementBeforeSubstitution</span></dt>
    <dd>This is the opening tag of an xml element before any
    substitutions.</dd>
  <dt><span style="font-family: Courier">elementBeforeSubstitution</span></dt>
    <dd>This is an xml element value before any substitutions.</dd>
  <dt><span style="font-family: Courier">newSourceFile</span></dt>
    <dd>A new file is being included.</dd>
  <dt><span style="font-family: Courier">endSourceFile</span></dt>
    <dd>End of an included file,</dd>
  <dt><span style="font-family: Courier">addPath</span></dt>
    <dd>A new addPath</dd>
  <dt><span style="font-family: Courier">removePath</span></dt>
    <dd>A addPath is being removed.</dd>
  <dt><span style="font-family: Courier">substitute</span></dt>
    <dd>A new substitute is defined.</dd>
  <dt><span style="font-family: Courier">removeSubstitute</span></dt>
    <dd>A substitute is being removed.</dd>
</dl>

<h4 id="IncludeSub2">IncludeSubstituteXMLReader</h4>

<p>The interface implemented by IncludeSubstituteXMLReaderFactory. It
provides two methods: parse and message. The arguments to parse have already
been describes. The message method adds the location within the input xml
files when this method is called.</p>

<h4 id="IncludeSub3">IncludeSubstituteXMLReaderFactory</h4>

<p>The factory that implements macro substitution and include.</p>
</body>
</html>
