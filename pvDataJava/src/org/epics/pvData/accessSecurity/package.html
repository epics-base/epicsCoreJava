<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
      "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="content-type" content="text/html; charset=iso-8859-1" />
  <title>EPICS JavaIOC: Access Security</title>
</head>

<body>
<h1 style="text-align: center">EPICS PVData: Access Security<br />
package: org.epics.pvData.accessSecurity<br />
2010.02.11</h1>
CONTENTS 
<hr />

<h2 style="text-align: center">Outstanding Issues</h2>
<hr />

<p>This section is temporary. It will be removed after access security is
implemented.</p>

<h3>access security level</h3>

<p>Epics Access Security had the concept of field level with only two levels
allowed. For pvData more than two levels are allowed. In addition names can
be associated with levels via inteface:</p>
<pre>interface AccessSecurityLevel {
    String getName(int level) throws IndexOutOfBoundsException;
    int getLevel(String name) throws NoSuchFieldException;
    String[] getNames();
}
</pre>

<p>A default implementation provides the following definition for names:</p>
<pre>   String[] names = {"internal","configuration","calibration","runtime"};
</pre>

<p>Another implementations can also be provided but any implementation should
define levels starting with 0. Level 0 should be acceptable as the
default.</p>

<p></p>
<hr />

<h2 style="text-align: center">Overview</h2>
<hr />

<p>Access Security limits access to A PVData database. Access Security for a
PVData database is similar to the EPICS V3 access security. The requirements
for access security were generated at ANL/APS in 1992. The requirements
document is: <a
href="http://www.aps.anl.gov/epics/EpicsDocumentation/EpicsGeneral/WorkInProgress/casecsp.html">Channel
Access Security Requirements</a> The V3 implementation is described in the <a
href="http://aps.anl.gov/epics/base/R3-14/11-docs/AppDevGuide.pdf">V3
Application Developer's Guide.</a> In that document read chapter "Access
Security".</p>

<p>This document discusses the following:</p>
<ul>
  <li>Quick start <br />
    A summary of the steps necessary to start access security.</li>
  <li>Features and Limitations</li>
  <li>Access Security Configuration File Syntax<br />
  </li>
  <li>Design Summary <br />
    Functional Requirements and Design Overview.</li>
  <li>Implementation Overview</li>
  <li>Java IOC Support<br />
    A description of support provided by the javaIOC for access security.</li>
  <li>PVAccess Support<br />
    A description of support provided by PVAccess for access security.</li>
  <li>Logging PVAccess Puts<br />
    This allows logging of put and process requests to a PVData database.</li>
</ul>
<hr />

<h2 style="text-align: center">Quick Start</h2>
<hr />

<p>TBD. This section will describe how to start access security for a
javaIOC.</p>
<hr />

<h2 style="text-align: center">Features and Limitations</h2>
<hr />

<h3>Features</h3>

<p>Access security protects IOC databases from unauthorized PVAccess Clients.
Access security is based on the following:</p>
<ul>
  <li>Who<br />
    The PVAccess client. This is implemented via a concept of credentials,
    which supports both who and where.</li>
  <li>Where<br />
    Where the client is located.</li>
  <li>What<br />
    The user is given either no access (none) or some combination of the
    following access rights: read, write, and process Individual fields of
    records are protected. Each record is assigned to an Access Security
    Group. Each field is assigned an access security level.</li>
  <li>When<br />
    Rules may apply only when particular states are active. States are
    defined via enumerated records accessable via PVAccess.</li>
</ul>

<p>Each record is assigned an assess security group or is put by default into
a group named "default".</p>

<p>Each field of each record is assigned an access security level which is an
integer that is greater than or equal to 0. Level 0 is the highest security
level. If a client has access for level n then the client also has access for
all levels greater than n. In addition names can be associated with the
levels, which is implemeted via interface AccessSecurityLevel. A default
implementation is provided which defines the names
"internal","configuration","calibration" and ,"runtime". Other
implementations can also be created but a particular site should define and
use a common implementation.</p>

<p>NOTE: The definion of access security level is an extension to what V3
epics supports. It allows only two levels: 0 and 1 with 1 being the highest
security level.</p>

<h3>Limitations</h3>

<p>PVAccess can be enhanced to implement authentication for udp and tcp
access to a PVData database but this is not the responsibility of access
security. The configuration file, however, provides sytax that allows for
authentication. </p>

<p>A PVData database can be accessed only via PVAccess or via a shell. It is
assumed that access to the shell is protected via physical security and
standard networking and physical security methods. </p>

<p>No attempt has been made to protect against the sophisticated saboteur.
Network security methods must be used to limit access to the subnet on which
the iocs reside. </p>
<hr />

<h2 style="text-align: center">Access Security Configuration File</h2>
<hr />

<p>This section describes the format of a file containing definitions of the
user access groups, host access groups, and access security groups. Lets
first give a simple example and then a complete description of the syntax.
</p>

<h3>Simple Example</h3>
<pre>&lt;accessSecurity&gt;
  &lt;credentials&gt;
    &lt;credential name="user"&gt;[publickey,sharedkey]&lt;/credential&gt;
    &lt;credential name="host"&gt;void&lt;/credential&gt;
    &lt;!-- an arbitrary number of credentials can follow--&gt;
    &lt;plugin name="publickey"&gt;&lt;/plugin&gt;
    &lt;plugin name="sharedkey"&gt;&lt;/plugin&gt;
  &lt;credentials&gt;
  &lt;groups&gt;
      &lt;group name = "users" credential = "user"&gt;[user1,user2]&lt;/group&gt;
      &lt;group name = "hosts" credential = "host"&gt;[host1,host2]&lt;/group&gt;
  &lt;/group&gt;
  &lt;access&gt;
     &lt;group name = "default"&gt;
        &lt;rule&gt;
           &lt;right&gt;[read]&lt;/right&gt;
        &lt;/rule&gt;
        &lt;rule&gt;
           &lt;right&gt;[read,write,process]&lt;/right&gt;
           &lt;group&gt;users.AND.hosts&lt;/group&gt;
        &lt;/rule&gt;
      &lt;/group&gt;
   &lt;/access&gt;
&lt;/accessSecurity&gt;</pre>

<p>These rules provide read access to anyone located anywhere and read,write,
and process access to user1 and user2 if they are located at host1 or
host2.</p>

<h3>Syntax Definition</h3>

<p>An access security configuration file must start and end as follows:</p>
<pre>&lt;?xml version="1.0" ?&gt;
&lt;accesssecurity&gt;
   &lt;!-- credentials, groups, states, access definitions --&gt;
&lt;/accesssecurity&gt;</pre>

<p>??? Should accesssecurity tag define xmlns or xsd ??</p>

<p>Between the accessSecurity tags the following definitions appear:</p>
<pre>  
  &lt;credentials&gt;
     &lt;credential name="name"&gt;[method,....method]&gt;&lt;/credential&gt;
     &lt;!-- will look for plugin that supports method in the order specified,
       first plugin that grants access means access is allowed --&gt;
     &lt;!-- an arbitrary number of credentials can follow--&gt;
     &lt;plugin name="method"&gt;
         &lt;!-- data for plugin. Syntax TBD --&gt;
     &lt;/plugin&gt;
     &lt;!-- an arbitrary number of plugins can follow--&gt;
  &lt;/credentials&gt;
  &lt;groups&gt;
      &lt;group name="name" credential="name"&gt;[name,...,name]&lt;/group&gt;
      &lt;!-- an arbitrary number of groups can be defined --&gt;
  &lt;/groups&gt;
  &lt;states&gt;
      &lt;state name = "name"&gt;
         &lt;provider&gt;name&lt;/provider&gt;
         &lt;!-- The channel provider --&gt;
         &lt;pvname&gt;name&lt;/pvname&gt;
         &lt;!-- name must be a record that has a top level enumerated field named value --&gt;   
      &lt;/state&gt;
      &lt;!-- an arbitrary number of states may appear --&gt;
  &lt;/states&gt;
  &lt;access&gt;
     &lt;group name = "name"&gt;
        &lt;rule accessSecurityLevel = "name" &gt;
            &lt;right&gt;[right,...,right]&lt;/right&gt;
            &lt;state name = "name"&gt;[state,...,state]&lt;/state&gt;
            &lt;group&gt;expression&lt;/group&gt;
            &lt;!-- expression chooses a group from groups above--&gt;
        &lt;/rule&gt;
        &lt;!-- an arbitrary number of rules may appear --&gt;
     &lt;/group&gt;
     &lt;!-- an arbitrary number of groups can be defined --&gt;
  &lt;/access&gt;
  &lt;log&gt;
     &lt;group name = "name"&gt;
        &lt;rule accessSecurityLevel = "name" &gt;
            &lt;right&gt;[right,...,right]&lt;/right&gt;
            &lt;state name = "name"&gt;[state,...,state]&lt;/state&gt;
            &lt;group&gt;expression&lt;/group&gt;
            &lt;!-- expression chooses a group from groups above--&gt;
        &lt;/rule&gt;
        &lt;!-- an arbitrary number of rules may appear --&gt;
     &lt;/group&gt;
     &lt;!-- an arbitrary number of groups can be defined --&gt;
  &lt;/log&gt;</pre>

<h4>credentials</h4>

<p>Credentials allow group names to be verified by PVAccess. All credential
definitions are enclosed in a single credentials xml element. An arbitrary
set of credential and plugin elements can appear within credentials. A
credential has an array of methods. The implementation looks for plugins in
array order and asks the plugin if the client is valid</p>

<p>A credential has a name and holds an array of method names. A method is
used on the server for authentication For example "void" just uses the
response from the client, "sharedkey" does some real work, "client-ip" yields
the client's IP number from PVAccess.</p>

<h4>groups</h4>

<p>groups provide a way to combine a set of names with a single name. For
example all accelerator physicists can be combined into a single group named
acceleratorPhysist. Another example is that all workstations in the control
room can be combined in a group named controlRoom.</p>

<p>A group has a name, selectes a credential, and contains a set of names.</p>

<h4>states</h4>

<p>states alow rules to apply only when something is or is not in a
particular state. A single xml element "states" holds all possible states.</p>

<p>Each state has a name, which is referenced in access rules, and has two
sub-elements: provider and pvname:</p>
<dl>
  <dt>provider</dt>
    <dd>This is the name of the PVAccess provider. At least the following are
      supported: local, PVAccess, and CAV3.</dd>
  <dt>pvname</dt>
    <dd>The name of the channel to which the provider will connect. For local
      and PVAccess this must be a channel that has a top level field named
      "value" and must be an enumerated structure. For CAV3 the VAL field
      must be type DBR_ENUM. In either case if the record is in alarm or the
      channel fails then the result is failure.</dd>
</dl>

<h4>access and access group</h4>

<p>access contains definitions for an arbitrary number of access groups. Each
access group defines an arbitrary number of rules. Each record being
proctected by access security is assigned to an accesss security group. Thus
each record instance belongs to a single access group. The default group has
the name "default", which is the group for all records that do not have the
accessGroup defined. Unlike a V3 access group the access group name will not
be available via the PVRecord interface but will be assigned and kept within
the access security system itself.</p>

<p>Each access group has a name, which selects the set of records to which
the access group applies. The group contains an arbitrary set of rule
definitions.</p>

<p>A rule optionally has an attribute accessSecurityLevel, which chooses an
access security level. If the access security level is not specified then
level 0 is assumed. The value for accessSecurityLevel is the name associated
with the level. Within a rule the following elements can appear:</p>
<dl>
  <dt>right</dt>
    <dd>The access rights which is any combination of read, write, process or
      else just none. If not specified no access is allowed..</dd>
  <dt>state</dt>
    <dd>This refers to a state definition from states. If the current state
      is one of the states in the array then the rule is valid.</dd>
  <dt>group</dt>
    <dd>This selects groups from the groups defined above. An expression that
      can use the following operators: '(', ')', '.OR.', '.AND.', and
      '.NOT.'. Each variable is a name of a group defined in groups. The
      syntax for the expression follows the same precedence rules as Java.
      Note that all arguments are of the form "Is the client part of the
      group defined in groups" The result of every operation is of type
      boolean. The final result is either true or false meaning that the rule
      (does not, does) apply.</dd>
</dl>

<p>The access privilege for a client is determined as follows:</p>
<ol>
  <li>The access group associated with the record is searched.</li>
  <li>Each rule for that access group is checked for the following: 
    <ul>
      <li>The field of the record being accessed must have an access security
        level that is greater than or equal to the access security level
        associated with the rule. If it does not than the rule does not
      apply.</li>
      <li>If state is specified, the state must be one of the choices
        specified. If link to the state record is bad or the alarm severity
        is invalid than the rule will not apply.</li>
      <li>If a group is specified and the expression evaluates to false the
        rule does not apply.</li>
      <li>If the rule does not apply then access is none.</li>
      <li>The client will be allowed to request processing only if the rule
        applies and process is true.</li>
    </ul>
  </li>
  <li>The maximum access right allowed by step 2 is the access right
  chosen.</li>
</ol>

<h4>log and log group</h4>

<p>The definitions are similar to those for access and access group. But
these are differences:</p>
<ul>
  <li>access security level
    <p>The level is now the maximum level to log rather than the minimum.
    Thus if the rule specifies level 0 than only level 0 fields are
    logged.</p>
  </li>
  <li>right 
    <p>none means no logging, read means log reads, etc.</p>
  </li>
  <li>The mimum access from the separate rules is chosen rather that the
    maximum</li>
</ul>
<hr />

<h2 style="text-align: center">Examples</h2>
<hr />

<h3>Credentials</h3>

<p>The following:</p>
<pre>&lt;credentials&gt;
    &lt;credential name="user"&gt;[publickey,sharedkey]&lt;/credential&gt;
    &lt;credential name="host"&gt;void&lt;/credential&gt;
    &lt;credential name="ip"&gt;pva-client-ip&lt;/credential&gt;
    &lt;!-- an arbitrary number of credentials can follow--&gt;
    &lt;plugin name="publickey"&gt;
        &lt;!-- data for plugin. Syntax TBD --&gt;
    &lt;/plugin&gt;
    &lt;plugin name="sharedkey"&gt;
        &lt;!-- data for plugin. Syntax TBD --&gt;
    &lt;/plugin&gt;
    &lt;plugin name="pva-client-ip"&gt;
        &lt;!-- data for plugin. Syntax TBD --&gt;
    &lt;/plugin&gt;
&lt;/credentials&gt; </pre>

<p>The example defines three credentials that may be used in the rules: user,
host, and ip address. The publickey and sharedkey plugins are used (tried in
that order) to authenticate users, the client may just declare its host name
without further checking, and a PVAccess call is used to determine the
numerical IP of the client. </p>

<h3>Groups</h3>
<pre>&lt;groups&gt;
   &lt;group name = "operator" credential = "user"&gt;[op1,op2,superguy]&lt;/group&gt;
   &lt;group name = "supervisor" credential = "user"&gt;[superguy]&lt;/group&gt;
   &lt;group name = "physicist" credential = "user"&gt;[joe,bill,sheng]&lt;/group&gt;
   &lt;group name = "controlRoom" credential = "host"&gt;[crhosr0,crhost1,crhost2]&lt;/group&gt;
   &lt;group name = "ioc" credential = "ip"&gt;[192.168.143.0/24,192.168.144.1,192.168.144.2]&lt;/group&gt;
&lt;/group&gt;</pre>

<h3>States</h3>

<p>The following:</p>
<pre>&lt;states&gt;
    &lt;state name = "ringOpState"&gt;
        &lt;provider&gt;CAV3&lt;/provider&gt;
        &lt;pvname&gt;OpIOC:ringOpState&lt;/pvname&gt;
    &lt;/state&gt;
    &lt;state name = "linacOpState"&gt;
        &lt;provider&gt;CAV3&lt;/provider&gt;
        &lt;pvname&gt;OpIOC:linacOpState&lt;/pvname&gt;
    &lt;/state&gt;
&lt;/states&gt;</pre>

<p>Defines states for a storage ring and for the linac. The choices for each
state are determined by the site. As an example they could be something like:
"offline", "standy", and "operational"</p>

<h3>Access Rules</h3>

<p>The following"</p>
<pre>&lt;access&gt;
   &lt;group name = "default"&gt;
       &lt;rule&gt;
          &lt;right&gt;[read]&lt;/right&gt;
       &lt;/rule accessSecurityLevel = "runtime"&gt;
       &lt;rule&gt;
          &lt;right&gt;[read,write,process]&lt;/right&gt;
          &lt;group&gt;(operator|physicist).AND.controlRoom&lt;/group&gt;
       &lt;/rule&gt;
       &lt;rule&gt;
          &lt;right&gt;[read,write]&lt;/right&gt;
          &lt;state name = "ringOpState"&gt;[offLine]&lt;/state&gt;
          &lt;group&gt;ringDeveloper.AND.controlRoom&lt;/group&gt;
       &lt;/rule&gt;
&lt;/access&gt;</pre>

<p>Allows access to records in the default access security group as
follows:</p>
<ul>
  <li>Any client can read any field of any record.</li>
  <li>Operators and Physicists located in the control room have write and
    read to fields, with accessSecurityLevel runtime, in any record. In
    addition they can request that a record be processed</li>
  <li>Ring developers can read and write any field but only when state is
    offLine.</li>
</ul>

<h3>Logging Rules</h3>

<p>The following:</p>
<pre>&lt;log&gt;
   &lt;group name = "default"&gt;
       &lt;rule&gt;
            &lt;right&gt;[write,process]&lt;/right&gt;
            &lt;group&gt;.NOT.((operators.OR.physicists).AND.controlRoom)&lt;/group&gt;
       &lt;/rule&gt;
       &lt;rule&gt;
            &lt;right&gt;[write,process]&lt;/right&gt;
            &lt;state name = "ringOpState"&gt;[offLine]&lt;/state&gt;
            &lt;group&gt;.NOT.ringDevelopers&lt;/group&gt;
       &lt;/rule&gt;
&lt;/log&gt;</pre>

<p>This will log all write and process requests to all fields of all records
in access group default except:</p>
<ul>
  <li>operators or physicists located in the control room</li>
  <li>ringDevelopers if the ringOpState is offline.</li>
</ul>
<hr />

<h2 style="text-align: center">Linac Example</h2>
<hr />

<p>Lets design a set of rules for a Linac. Assume the following:</p>
<ol>
  <li>Anyone can have read access to all fields at anytime.</li>
  <li>Linac application developers, located in the control room, have read,
    write, and process access to all fields only if the Linac in
  development.</li>
  <li>Operators, located in the control room, can have read, write, and
    process access to fields that have access security level corresponding to
    runtime.</li>
  <li>The operations supervisor, linac supervisor, and the application
    developers can have read,write, and process access to all fields but must
    have some way of not changing something inadvertently.</li>
  <li>Most records use the above rules but a few (high voltage power
    supplies, etc.) are placed under tighter control. These will follow rules
    1 and 4 but not 2 or 3. These records will be in access security group
    "permit".</li>
  <li>IOC PVAccess clients always have read, write, and process access to all
    fields of all records except those in group permit.</li>
</ol>

<p>Most Linac IOC records will not have the ASG field defined and will thus
be placed in group default.</p>

<p>The following records will have an ASG defined:</p>
<ul>
  <li>LI:OPSTATE<br />
    and any other records that need tighter control have asg critical. Two of
    the choices for LI:OPSTATE are "development" and "operational".</li>
  <li>LI:permit is in accessSecurityGroup permit. Thus has choices
    [false,true] In order for the opSup, linacSup, or an appDev to have write
    privilege to everything this record must be set to the value true. Thus
    rule 4) above is satisfied by making the operations supervisor first set
    this record true before other changes are allowed. After changes this
    record should be set back to false.</li>
</ul>

<p>The following access configuration satisfies the above rules.</p>
<pre>&lt;credentials&gt;
    &lt;credential name="user"&gt;[publickey,sharedkey]&lt;/credential&gt;
    &lt;credential name="host"&gt;void&lt;/credential&gt;
    &lt;credential name="ip"&gt;pva-client-ip&lt;/credential&gt;
    &lt;!-- an arbitrary number of credentials can follow--&gt;
    &lt;plugin name="publickey"&gt;
        &lt;!-- data for plugin. Syntax TBD --&gt;
    &lt;/plugin&gt;
    &lt;plugin name="sharedkey"&gt;
        &lt;!-- data for plugin. Syntax TBD --&gt;
    &lt;/plugin&gt;
    &lt;plugin name="pva-client-ip"&gt;
        &lt;!-- data for plugin. Syntax TBD --&gt;
    &lt;/plugin&gt;
&lt;/credentials&gt; 
&lt;groups&gt;
   &lt;group name = "op" credential = "user"&gt;[op1,op2,superguy]&lt;/group&gt;
   &lt;group name = "opSup" credential = "user"&gt;[superguy]&lt;/group&gt;
   &lt;group name = "linac" credential = "user"&gt;[waw,nassiri,grelick,berg,fuja,gsm]&lt;/group&gt;
   &lt;group name = "linacSup" credential = "user"&gt;[gsm]&lt;/group&gt;
   &lt;group name = "appDev" credential = "user"&gt;[nda,kko]&lt;/group&gt;
   &lt;group name = "cr" credential = "host"&gt;[mars,hera,gold]&lt;/group&gt;
   &lt;group name = "ioc" credential = "ip"&gt;
       [192.168.143.0/24,192.168.144.1,192.168.144.2]
   &lt;/group&gt;
&lt;/groups&gt;
&lt;states/&gt;
   &lt;state name = "opstate"&gt;
      &lt;provider&gt;CAV3&lt;/provider&gt;
      &lt;pvname&gt;LI:OPSTATE&lt;/pvname&gt;
   &lt;/state&gt;
   &lt;state name = "permit"&gt;
      &lt;provider&gt;CAV3&lt;/provider&gt;
      &lt;pvname&gt;LI:permit&lt;/pvname&gt;
   &lt;/state&gt;
&lt;/states&gt;
&lt;access&gt;
   &lt;group name = "default"&gt;
      &lt;rule accessSecurityLevel = "runtime"&gt;
         &lt;right&gt;[read,write,process]&lt;/right&gt;
         &lt;state name = "opstate"&gt;[operational]&lt;/state&gt;
         &lt;group&gt;op.AND.cr&lt;/group&gt;
         
      &lt;/rule&gt;
      &lt;rule&gt;
          &lt;right&gt;[read,write,process]&lt;/right&gt;
          &lt;state name = "opstate"&gt;[development]&lt;/state&gt;
          &lt;!-- during development operators do not have access --&gt;
          &lt;group&gt;(opSup.OR.linacSup.OR.appdev).AND.cr&lt;/group&gt;
      &lt;/rule&gt;
      &lt;rule&gt;
          &lt;right&gt;[read,write,process]&lt;/right&gt;
          &lt;state name = "permit"&gt;[true]&lt;/state&gt;
          &lt;group&gt;(opSup.OR.linacSup.OR.appdev).AND.cr&lt;/group&gt;
      &lt;/rule&gt;
      &lt;rule&gt;
          &lt;right&gt;[read]&lt;/right&gt;
      &lt;/rule&gt;
      &lt;rule&gt;
         &lt;right&gt;[read,write,process]&lt;/right&gt;
         &lt;group&gt;ioc&lt;/group&gt;
      &lt;/rule&gt;
   &lt;/group&gt;
   &lt;group name = "critical"&gt;
       &lt;rule&gt;
         &lt;right&gt;[read,write,process]&lt;/right&gt;
         &lt;state name = "permit"&gt;[true]&lt;/state&gt;
         &lt;group&gt;(opSup.OR.linacSup.OR.appDev)&lt;/group&gt;
      &lt;/rule&gt;
      &lt;rule&gt;
         &lt;right&gt;[read]&lt;/right&gt;
      &lt;/rule&gt;
      &lt;rule&gt;
         &lt;right&gt;[read,write,process]&lt;/right&gt;
         &lt;group&gt;ioc&lt;/group&gt;
      &lt;/rule&gt;
   &lt;/group&gt;
   &lt;group name = "permit"&gt;
      &lt;rule&gt;
         &lt;right&gt;[read,write,process]&lt;/right&gt;
         &lt;group&gt;opSup&lt;/group&gt;
      &lt;/rule&gt;
      &lt;rule&gt;
          &lt;right&gt;[read]&lt;/right&gt;
      &lt;/rule&gt;
    &lt;/group&gt;
&lt;/access&gt;</pre>
<hr />

<h2 style="text-align: center">Design Summary</h2>
<hr />

<h3>Summary of Design Requirements</h3>

<p>A brief summary of the Functional Requirements is:</p>
<ol>
  <li>Each field of each record type is assigned an access security
  level.</li>
  <li>Each record instance is assigned to a unique access security group.</li>
  <li>Each user is assigned to one or more user access groups.</li>
  <li>Each host is assigned to a host access group.</li>
  <li>For each access security group a set of access rules can be defined.
    Each rule specifies: 
    <ul>
      <li>access security level.</li>
      <li>read, write, process right.</li>
      <li>An expression selecting the groups allowed.</li>
      <li>Allowed states.</li>
    </ul>
  </li>
</ol>

<h3>Additional Requirements</h3>
<dl>
  <dt>Performance</dt>
    <dd>Although the functional requirements does not mention it, a
      fundamental goal is performance. The design provides almost no overhead
      during normal database access and moderate overhead for the following:
      PVAccess client/server connection, ioc initialization, a change in
      value of a process variable referenced by an access calculation, and
      dynamically changing a records access control group. Dynamically
      changing the user access groups, host access groups, or the rules,
      however, can be a time consuming operation. This is done, however, by a
      low priority thread and thus does not impact normal record processing.
    </dd>
  <dt>Generic Implementation</dt>
    <dd>Access security should be implemented as a stand alone system, i.e.
      it should not be imbedded tightly in database or PVAccess. For example
      it should be usable by a gateway as well as by a javaIOC. </dd>
  <dt>No Access Security within a javaIOC</dt>
    <dd>Within an IOC no access security is invoked. This means that database
      links and local PVAccess clients calls are not subject to access
      control. Also test routines such as dbgf should not be subject to
      access control. </dd>
  <dt>Defaults</dt>
    <dd>It must be possible to easily define default access rules.</dd>
  <dt>Access Security is Optional</dt>
    <dd>When a javaIOC is initialized, access security is optional.</dd>
  <dt>process</dt>
    <dd>Since PVAccess allows the client to request processing ( For V3 this
      was determined by record type database definition), the access rights
      must include process in addition to read and write.</dd>
</dl>
<hr />

<h2 style="text-align: center">Implementation Overview</h2>
<hr />

<p>TBD.</p>
<hr />

<h2 style="text-align: center">Java IOC Support</h2>
<hr />

<p>TBD. The plan is to start/restart access security via record instances
that have support that interfaces to access security</p>
<hr />

<h2 style="text-align: center">PVAccess Support</h2>
<hr />

<p>TBD.</p>
<hr />

<h2 style="text-align: center">Logging PVAccess Puts</h2>
<hr />

<p>TBD.</p>
</body>
</html>
