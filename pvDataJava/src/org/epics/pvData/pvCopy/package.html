<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
      "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="content-type" content="text/html; charset=iso-8859-1" />
  <title>EPICS JavaIOC: pv</title>
</head>

<body>
<h1 style="text-align: center">EPICS PVData: pvCopy<br />
package: org.epics.pvData.pvCopy<br />
2009.08.25</h1>
CONTENTS 

<div class="toc">
<ul>
  <li><a href="#Overview">Overview</a></li>
  <li><a href="#BitSetUtil">BitSetUtil</a></li>
  <li><a href="#PVCopy">PVCopy</a></li>
  <li><a href="#PVCopyMoni">PVCopyMonitor</a></li>
  <li><a href="#PVCopyFact">PVCopyFactory</a> 
    <ul>
      <li><a href="#Java">Java Definition</a></li>
      <li><a href="#PVStructur">PVStructure pvRequest</a></li>
      <li><a href="#Examples">Examples</a></li>
    </ul>
  </li>
  <li><a href="#PVShare">PVShare</a></li>
</ul>
</div>
<hr />

<h2 style="text-align: center" id="Overview">Overview</h2>
<hr />

<p>This package provides support for copying PVData between a client and
server. For example the client can be a channel access client and the server
a channel access server. It allows a client to access an arbitrary set of
fields of a PVRecord that exists on the server. This package does not provide
support for transfering the data between client and server but provides
support for code that does, e. g. it can be used by channel access. In the
examples below the data transfer code is called channel access.</p>

<p>This package uses the field offsets provided by PVField and also requires
that user code creates a java.util.BitSet.</p>

<p>PVField provides support for locating a field within a PVStructure or
PVRecord via a field offset. PVField provides the methods:</p>
<dl>
  <dt>getFieldOffset</dt>
    <dd>Get offset of the PVField field within top level structure. Every
      field within the PVStructure has a unique offset. The top level
      structure has an offset of 0. The first field within the structure has
      offset equal to 1. The other offsets are determined by recursively
      traversing each structure of the tree.</dd>
  <dt>getNextFieldOffset</dt>
    <dd>Get the next offset. If the field is a scalar or array field then
      this is just offset + 1. If the field is a structure it is the offset
      of the next field after this structure. Thus (nextOffset - offset) is
      always equal to the number of fields within the field. </dd>
  <dt>getNumberFields</dt>
    <dd>Get the total number of fields in this field. This is equal to
      nextFieldOffset - fieldOffset. </dd>
</dl>

<p>A BitSet which has a bit for each field of a top level PVStructure can be
created via:</p>
<pre>    BitSet bitSet = new BitSet(pvStructure.getNumberFields());</pre>

<p>The offsets for bitSet match the fieldOffsets. On the client side of
Channel Access only a BitSet created from the PVStructure is required. On the
server side PVCopy provides a way to map between the field in a PVRecord and
the fields in the PVStructure. A copy of the PVStructure resides on both the
Channel Access client and server. The client and server exchange data via
these two PVStructures. PVCopy maps between the PVStructure and the PVRecord
on the server side of Channel Access. </p>

<p>This package provides the following:</p>
<dl>
  <dt>BitSetUtil</dt>
    <dd>An interface that cuurently has only one method compress which
      optimizes the bit settings for a PVStructure.</dd>
  <dt>PVCopy</dt>
    <dd>An interface for mapping between a PVRecord and a PVStructure that
      contains data for a subset of the fields in the PVRecord.</dd>
  <dt>PVCopyMonitor</dt>
    <dd>An interrface for monitoring changes to fields of the PVRecord that
      have a corresponding field in PVStructure.</dd>
  <dt>PVCopyFactory</dt>
    <dd>The factory that implements PVCopy. It accepts a PVStructure that
      describes the set of fields of a PVRecord that should be mapped.</dd>
  <dt>PVShareFactory</dt>
    <dd>A factory that replaces a PVField with an implementation that
      accesses the data from a shared field.</dd>
</dl>
<hr />

<h2 style="text-align: center" id="BitSetUtil">BitSetUtil</h2>
<hr />

<p>This provides functions that operate of a BitSet for a PVStructure. It has
the definitions:</p>
<pre>interface BitSetUtil {
    boolean compress(BitSet bitSet,PVStructure pvStructure);
}

class BitSetUtilFactory {
    public static BitSetUtil getCompressBitSet();
}</pre>

<p>It currently has only one method:</p>
<dl>
  <dt><span style="font-family: Courier">compress</span></dt>
    <dd>Compress the bits in a BitSet related to a structure.<br />
      For each structure: 
      <ol>
        <li>If the bit for the structure is set then the bit for all
          subfields of the structure are cleared. </li>
        <li>If the bit for the structure is not set but all immediate
          subfields have their bit set then the bit for the structure is set
          and the bits for all subfields are cleared. </li>
      </ol>
      Note that this is a recursive algorithm. That is if every immediate
      subfield has it's offset bit set then the bits for ALL fields that
      reside in the structure will be cleared.</dd>
    <dd>Channel Access can call this before sending data. It can then pass
      entire structures if the structure offset bit is set. </dd>
</dl>
<hr />

<h2 style="text-align: center" id="PVCopy">PVCopy</h2>
<hr />

<p>This is the interface for mapping between a PVStructure that contain a
copy of the data for a subset of the fields in a PVRecord. Note that this
interface is NOT for a single PVStructure but for a single PVRecord and a
single Structure introspection interface that describes a subset of the
fields in the PVRecord. For example if a server supports monitor queues then
the server will allocate a PVStructure for each queue element but will create
a single PVCopy.</p>
<pre>    interface PVCopy {
        PVRecord getPVRecord();
        Structure getStructure();
        PVStructure createPVStructure();
        int getCopyOffset(PVField recordPVField);
        int getCopyOffset(PVStructure recordPVStructure,PVField recordPVField);
        PVField getRecordPVField(int structureOffset);
        void initCopy(PVStructure pvCopy, BitSet bitSet,boolean recordLocked);
        void updateCopySetBitSet(PVStructure copyPVStructure,BitSet bitSet,boolean lockRecord);
        void updateCopyFromBitSet(PVStructure copyPVStructure,BitSet bitSet,boolean lockRecord);
        boolean updateRecord(PVStructure pvCopy,BitSet bitSet,boolean lockRecord);
        PVCopyMonitor createPVCopyMonitor(PVCopyMonitorRequester pvCopyMonitorRequester);
    }</pre>

<p>where</p>
<dl>
  <dt><span style="font-family: Courier">getPVRecord</span></dt>
    <dd>Get the PVRecord to which this PVCopy is attached</dd>
  <dt><span style="font-family: Courier">getStructure</span></dt>
    <dd>Get the introspection interface which describes the subset of the
      fields in the PVRecord.</dd>
  <dt><span style="font-family: Courier">createPVStructure</span></dt>
    <dd>Create a PVStructure which can hold a subset of the data from the
      PVRecord. A client may require multiple PVStructures. For example if a
      monitor request supports a queue than a PVStructure is required for
      each queue element. </dd>
  <dt><span style="font-family: Courier">getCopyOffset(PVField
  recordPVField)</span></dt>
    <dd>Given a PVField from the record determine the offset within the
      PVStructure where the copy of the data is located.
      PVStructure.getSubField(offset) can be called to locate the PVField
      within the PVStructure. </dd>
  <dt><span style="font-family: Courier">getCopyOffset(PVStructure
  recordPVStructure,PVField recordPVField)</span></dt>
    <dd>Given a recordPVField within a recordPVStructure determine the offset
      within the PVStructure where the copy of the data is located.
      PVStructure.getSubField(offset) can be called to locate the PVField
      within the PVStructure. </dd>
  <dt><span style="font-family: Courier">getRecordPVField</span></dt>
    <dd>Given an offset within a PVStructure return the corresponding PVField
      in the PVRecord.</dd>
  <dt><span style="font-family: Courier">initCopy</span></dt>
    <dd>Initialize PVStructure with the current data from the PVRecord. The
      bitSet will have offset 0 set to 1 and all other bits set to 0. </dd>
  <dt><span style="font-family: Courier">updateCopySetBitSet</span></dt>
    <dd>Update PVStructure from PVRecord. The BitSet shows which fields in
      PVStructure have changed.</dd>
  <dt><span style="font-family: Courier">updateCopyFromBitSet</span></dt>
    <dd>Update PVStructure from PVRecord. Only fields that have the offset in
      bitSet set to true are modified.</dd>
  <dt><span style="font-family: Courier">updateRecord</span></dt>
    <dd>Update the fields in PVRecord with data from PVStructure. Only fields
      that have the offset in bitSet set to true are modified. </dd>
  <dt><span style="font-family: Courier">createPVCopyMonitor</span></dt>
    <dd>Create a PVCopyMonitor. See next section.</dd>
</dl>
<hr />

<h2 style="text-align: center" id="PVCopyMoni">PVCopyMonitor</h2>
<hr />

<p>PVCopyMonitor is a PVListener for the PVRecord to which PVCopy is
attached. It updates two bitSets when it receives PVListener.dataPut
callbacks. changeBit shows all fields that have changed between calls to
switchBitSets. overrunBitSet shows all fields that have changed value more
than once between calls to switchBitSets. It notifies the
PVCopyMonitorRequester when data has changed. </p>
<pre>interface PVCopyMonitorRequester {
    void dataChanged();
    void unlisten();
}

interface PVCopyMonitor {
    void startMonitoring();
    void startMonitoring(BitSet changeBitSet, BitSet overrunBitSet);
    void stopMonitoring();
    void switchBitSets(BitSet newChangeBitSet,BitSet newOverrunBitSet, boolean lockRecord);
}</pre>

<p>PVCopyMonitorRequester is the interface implemented by the caller that
calls PVCopy.createPVCopyMonitor:</p>
<dl>
  <dt><span style="font-family: Courier">dataChanged</span></dt>
    <dd>Data being monitored has changed.</dd>
  <dt><span style="font-family: Courier">unlisten</span></dt>
    <dd>PVCopyMonitor has been told to unlisten so not more monitors will
      occur. </dd>
</dl>

<p>PVCopyMonitor is the interface returned by a call to
PVCopy.createPVCopyMonitor.</p>
<dl>
  <dt><span style="font-family: Courier">startMonitoring</span></dt>
    <dd>Start monitoring. The version without bitset arguments is for clients
      that just want to be notified of changes.</dd>
  <dt><span style="font-family: Courier">stopMonitoring</span></dt>
    <dd>Stop monitoring.</dd>
  <dt><span style="font-family: Courier">switchBitSets</span></dt>
    <dd>If the pvStructure is not shared all fields that changeBitSet shows
      were changed are copied from the corresponding PVField of the PVRecord
      to the PVField of the PVStructure. Then the bitSets are replaced by the
      new bitSets. Note that a client needs just two instances of the bitSets
      and can just cycle between the two sets. Even if the PVStructure is
      shared this method is important since the caller will not miss data
      changes. It is illegal to call this if startMonitoring was called with
      no arguments.</dd>
</dl>
<hr />

<h2 style="text-align: center" id="PVCopyFact">PVCopyFactory</h2>
<hr />

<h3 id="Java">Java Definition</h3>
<pre>    class PVCopyFactory {
        static PVCopy create(PVRecord pvRecord,PVStructure pvRequest,
               String structureName,boolean shareData);
    }</pre>

<p>where create has the arguments</p>
<dl>
  <dt><span style="font-family: Courier">pvRecord</span></dt>
    <dd>The PVRecord to which the server is attached.</dd>
  <dt><span style="font-family: Courier">pvRequest</span></dt>
    <dd>A PVStructure which describes the fields of PVREcord to which the
      server wants access.</dd>
  <dt><span style="font-family: Courier">structureName</span></dt>
    <dd>The name to give to the structure that describes the subset of the
      fields of PVRecord that are actually mapped.</dd>
  <dt><span style="font-family: Courier">shareData</span></dt>
    <dd>Should the PVStructure created by calling PVCopy.createPVStructure
      share the data from PVRecord of should it keep a separate copy.</dd>
</dl>

<h3 id="PVStructur">PVStructure pvRequest</h3>

<p>This is a PVStructure that describes the fields in PVRecord that are to be
accessed. It looks like the following:</p>
<pre>    &lt;structure&gt;
         &lt;!-- 0 or 1 scalar string definition of the form --&gt;
         &lt;scalar name = "fieldList" scalarType = "string"&gt;
             fullPVRecordFieldName,fullPVRecordFieldName,...
         &lt;/scalar&gt;
         &lt;!-- 0 or more scalar string definitions of the following form --&gt;
         &lt;scalar name = "fieldName" scalarType = "string"&gt;
            fullPVRecordFieldName
         &lt;/scalar&gt;
         &lt;!-- 0 or more structure definitions of the form --&gt;
         &lt;sructure name = "fieldName"&gt;
            &lt;!-- 0 or more scalar string definitions of the following form --&gt;
            &lt;scalar name = "fieldName" scalarType = "string"&gt;
               fullPVRecordFieldName
            &lt;/scalar&gt;
            &lt;!-- 0 or 1 scalar string definition of the form --&gt;
            &lt;scalar name = "fieldList" scalarType = "string"&gt;
                fullPVRecordFieldName,fullPVRecordFieldName,...
            &lt;/scalar&gt;
            &lt;!-- 0 or more structure definitions of the form --&gt;
            &lt;sructure name = "fieldName"&gt;
            &lt;/structure&gt;
        &lt;/structure&gt;
    &lt;/structure&gt;</pre>

<p>where</p>
<dl>
  <dt>fieldList</dt>
    <dd>A comma separated list of fullPVRecordFieldNames. Each will become a
      single field in the structure created by PVCopy with a field name that
      is the same as the field name of the corresponding
      fullPVRecordFieldName. For example if the fullPVFieldName =
      "power.value" then the field name is "value". </dd>
  <dt>fieldName</dt>
    <dd>The name of the field that will appear in the field of the
      introspection Structure that is generated from the pvRequest and the
      fullPVRecordFieldName</dd>
  <dt>fullPVRecordFieldName</dt>
    <dd>The full fieldname in PVRecord to which the field of the
      introspection Structure will map.</dd>
</dl>

<p>Note that the definition is recursive, i.e. an arbitarily complex
structure can be defined.</p>

<h3 id="Examples">Examples</h3>

<p>Assume that the following structures have been put into the master
PVDatabase:</p>
<pre>&lt;structure structureName = "powerFromPowerSupply"&gt;
    &lt;scalar name = "fieldList" scalarType = "string"&gt;
       alarm,timeStamp,power.value
    &lt;/scalar&gt;
&lt;/structure&gt;

&lt;structure structureName = "powerSupplyFromPowerSupply"&gt;
    &lt;scalar name = "alarm" scalarType = "string"&gt;alarm&lt;/scalar&gt;
    &lt;scalar name = "timeStamp" scalarType = "string"&gt;timeStamp&lt;/scalar&gt;
    &lt;structure name = "power"&gt;
        &lt;scalar name = "fieldList" scalarType = "string"&gt;
             power.value,power.alarm
        &lt;/scalar&gt;
    &lt;/structure&gt;
    &lt;structure name = "current"&gt;
        &lt;scalar name = "fieldList" scalarType = "string"&gt;
             current.value,current.alarm
        &lt;/scalar&gt;
    &lt;/structure&gt;
    &lt;structure name = "voltage"&gt;
        &lt;scalar name = "fieldList" scalarType = "string"&gt;
             voltage.value,voltage.alarm
        &lt;/scalar&gt;
    &lt;/structure&gt;
&lt;/structure&gt;</pre>

<p>Then the following shows example code for creating a PVCopy:</p>

<p></p>
<pre>    
    private static PVDatabase master = PVDatabaseFactory.getMaster();
    private static FieldCreate fieldCreate = FieldFactory.getFieldCreate();
    private static PVDataCreate pvDataCreate = PVDataFactory.getPVDataCreate();
    private static BitSetUtil bitSetUtil = BitSetUtilFactory.getCompressBitSet();

        // definitions for request structure to pass to PVCopyFactory
        PVRecord pvRecord = null;
        PVStructure pvRequest = null;
        // definitions for PVCopy
        PVCopy pvCopy = null;
        PVStructure pvCopyStructure = null;
        BitSet bitSet = null;

        //alarm,timeStamp,power.value from powerSupply
        pvRecord = master.findRecord("powerSupply");
        pvRequest = master.findStructure("powerFromPowerSupply");
        pvCopy = PVCopyFactory.create(pvRecord, pvRequest, "",false);
        pvCopyStructure = pvCopy.createPVStructure();
        bitSet = new BitSet(pvCopyStructure.getNumberFields());
        pvCopy.initCopy(pvCopyStructure, bitSet,true);
        System.out.println(pvCopyStructure.toString());

        //power, current, voltage. For each value and alarm
        pvRequest = master.findStructure("powerSupplyFromPowerSupply");
        pvCopy = PVCopyFactory.create(pvRecord, pvRequest, "",false);
        pvCopyStructure = pvCopy.createPVStructure();
        bitSet = new BitSet(pvCopyStructure.getNumberFields());
        pvCopy.initCopy(pvCopyStructure, bitSet,true);
        System.out.println(pvCopyStructure.toString());</pre>

<p>The following shows how the first example could be done by directly
calling pvDataCreate.</p>
<pre>        PVRecord pvRecord = master.findRecord("powerSupply");
        System.out.printf("%nvalue, alarm, timeStamp%n");
        pvRequest = pvDataCreate.createPVStructure(null, "", new Field[0]);
        pvString = (PVString)pvDataCreate.createPVField(pvRequest,"fieldList",ScalarType.pvString);
        pvString.put("alarm,timeStamp,power.value");
        pvRequest.appendPVField(pvString);
        </pre>
<hr />

<h2 style="text-align: center" id="PVShare">PVShare</h2>
<hr />

<p>This is a factory that replaces a scalar or scalarArray field with a
version that shares the data from another field. When a get or put is issued
the get or put method of the shared PVField is called.</p>
<pre>class PVShareFactory {
    public static PVScalar replace(PVScalar pvNow,PVScalar pvShare);
    public static PVArray replace(PVArray pvNow,PVArray pvShare);
}</pre>
</body>
</html>
