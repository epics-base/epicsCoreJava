<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
      "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="content-type" content="text/html; charset=iso-8859-1" />
  <title>EPICS JavaIOC: pv</title>
</head>

<body>
<h1 style="text-align: center">EPICS PVData: pvCopy<br />
package: org.epics.pvData.pvCopy<br />
2010.04.29</h1>
CONTENTS 

<div class="toc">
<ul>
  <li><a href="#Overview">Overview</a></li>
  <li><a href="#Request">Request String</a>
    <ul>
      <li><a href="#Simple">Simple Requests</a></li>
      <li><a href="#Full">Full Request Syntax</a></li>
      <li><a href="#Examples">Examples</a>
        <ul>
          <li><a href="#Simple1">Simple example</a></li>
          <li><a href="#Power">Power Supply Example</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#pvRequest">pvRequest</a>
    <ul>
      <li><a href="#PVStructur">PVStructure pvRequest</a></li>
      <li><a href="#Examples1">Examples</a>
        <ul>
          <li><a href="#Simple2">Simple example</a>
            <ul>
              <li><a href="#quickest">The quickest Way</a></li>
              <li><a href="#Using">Using the field notation</a></li>
            </ul>
          </li>
          <li><a href="#Power1">Power Supply Example</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#BitSetUtil">BitSetUtil</a></li>
  <li><a href="#PVCopy">PVCopy</a></li>
  <li><a href="#PVCopyMoni">PVCopyMonitor</a></li>
  <li><a href="#PVCopyFact">PVCopyFactory</a>
    <ul>
      <li><a href="#Java">Java Definition</a></li>
    </ul>
  </li>
  <li><a href="#PVShare">PVShare</a></li>
</ul>
</div>
<hr />

<h2 style="text-align: center" id="Overview">Overview</h2>
<hr />

<p><span style="font-weight:bold;">NOTE FOR Casual Users</span>: For users
that just want to create pvRequest arguments for pvAccess skip to the next
section.</p>

<p>This package provides support for copying PVData between a client and
server. For example the client can be a pvAccess client and the server a
pvAccess server. It allows a client to access an arbitrary set of fields of a
PVRecord that exists on the server. This package does not provide support for
transfering the data between client and server but provides support for code
that does, e. g. it can be used by channel access. In the examples below the
data transfer code is called channel access.</p>

<p>The Channel interface provided by pvAccess has create calls for each type
of request, e. g. createChannelGet, createChannelPut, etc. Each of these has
an argument "PVStructure pvRequest". The pvRequest describes two things: 1)
The set of fields of the record to which the channel is connected, and 2)
record and field options. This package provides two services: 1) a utility
method that, given a specially encoded string, creates a pvRequest structure
that can be passed to the Channel create methods. and 2) Implements the
mapping between the client request fields and the record.</p>

<p>The next section describes the utility for creating a pvRequest. This is
the only section of interest to users. The remaining sections are of interest
to developers including developers who create new services.</p>

<p>The third section describes the layout of a pvRequest structure. This is
of interest to developers of client applications that use new services.</p>

<p>The remaining sections describe the code implemented by this package.</p>

<p>This package uses the field offsets provided by PVField and also requires
that user code creates a java.util.BitSet.</p>

<p>PVField provides support for locating a field within a PVStructure or
PVRecord via a field offset. PVField provides the methods:</p>
<dl>
  <dt>getFieldOffset</dt>
    <dd>Get offset of the PVField field within top level structure. Every
      field within the PVStructure has a unique offset. The top level
      structure has an offset of 0. The first field within the structure has
      offset equal to 1. The other offsets are determined by recursively
      traversing each structure of the tree.</dd>
  <dt>getNextFieldOffset</dt>
    <dd>Get the next offset. If the field is a scalar or array field then
      this is just offset + 1. If the field is a structure it is the offset
      of the next field after this structure. Thus (nextOffset - offset) is
      always equal to the number of fields within the field. </dd>
  <dt>getNumberFields</dt>
    <dd>Get the total number of fields in this field. This is equal to
      nextFieldOffset - fieldOffset. </dd>
</dl>

<p>A BitSet which has a bit for each field of a top level PVStructure can be
created via:</p>
<pre>    BitSet bitSet = new BitSet(pvStructure.getNumberFields());</pre>

<p>The offsets for bitSet match the fieldOffsets. On the client side of
Channel Access only a BitSet created from the PVStructure is required. On the
server side PVCopy provides a way to map between the field in a PVRecord and
the fields in the PVStructure. A copy of the PVStructure resides on both the
Channel Access client and server. The client and server exchange data via
these two PVStructures. PVCopy maps between the PVStructure and the PVRecord
on the server side of Channel Access. </p>

<p>This package provides the following:</p>
<dl>
  <dt>BitSetUtil</dt>
    <dd>An interface that curently has only one method, compress, which
      optimizes the bit settings for a PVStructure.</dd>
  <dt>PVCopy</dt>
    <dd>An interface for mapping between a PVRecord and a PVStructure that
      contains data for a subset of the fields in the PVRecord.</dd>
  <dt>PVCopyMonitor</dt>
    <dd>An interface for monitoring changes to fields of the PVRecord that
      have a corresponding field in PVStructure.</dd>
  <dt>PVCopyFactory</dt>
    <dd>The factory that implements PVCopy. It accepts a PVStructure that
      describes the set of fields of a PVRecord that should be mapped.</dd>
  <dt>PVShareFactory</dt>
    <dd>A factory that replaces a PVField with an implementation that
      accesses the data from a shared field.</dd>
</dl>
<hr />

<h2 style="text-align: center" id="Request">Request String</h2>
<hr />

<p>Issuing the request:</p>
<pre>    PVStructure pvRequest = PVCopyFactory.createRequest(String request);
</pre>

<p>creates a pvRequest argument for the various create methods provided by
interface Channel.</p>

<h3 id="Simple">Simple Requests</h3>

<p>Before starting lets first give some examples that satisfy clients such as
Synoptic Display, Alarm, and Archive tools. These clients only want access to
some combination of the following fields: value, alarm, timeStamp, display,
and control. If the request is for a record that has these all as top level
fields the request string is just a comma separated list of the field names.
For example:</p>
<pre>    PVStructure pvRequest = PVCopyFactory.createRequest("value,alarm,timeStamp");
</pre>

<p>If the record is does not have the desired field at the top level then the
field can still be accessed with a simple string. For example:</p>
<pre>    pvRequest = PVCopyFactory.createRequest("power.value,alarm,timeStamp,power.display");
</pre>

<p>Will get the top level alarm and timeStamp and the value and alarm from a
structure named power. Thus the above works for a record that is structured
as follows:</p>
<pre>powerSupply
    alarm
    timeStamp
    power
       value
       display
       ...
    ...
</pre>

<p>The only option most clients want is to request that a record be processed
as part of a get or put requests. This is done via requests like the
following:</p>
<pre>    pvRequest = PVCopyFactory.createRequest("record[process=true]field(value,alarm,timeStamp)");
</pre>

<h3 id="Full">Full Request Syntax</h3>

<p>A request is of the form:</p>
<pre>    record[option,...]field(fieldDef,...)putField(fieldDef,...)getField(fieldDef,...)
    OR
    fieldDef,...</pre>

<p>Thus a request consists of record options and sets of field definitions or
just field definitions. A <span style="font-family: Courier">record</span>
option is of the form:</p>
<pre>    record[name=value,...]</pre>

<p>This will generate the equivalent of :</p>
<pre>    &lt;structure name = "record"&gt;
         &lt;scaler name = "name" scalarType = "string"&gt;value&lt;/scalar&gt;
         &lt;!-- other options --&gt;
    &lt;/structure&gt;</pre>

<p>A <span style="font-family: Courier">field,putFeld,getField</span> is a
comma separated set of <span style="font-family: Courier">fieldDefs</span>
which are of the form:</p>
<pre>    fullFieldName[option,...]    // options are optional</pre>
or 
<pre>    fieldName{request}     // recursive definition</pre>

<p>A <span style="font-family: Courier">fullFieldName</span> is the full name
of a field in the PVRecord. The name in a generated data structure will have
just the field name. If <span
style="font-family: Courier">fieldName{request}</span> is given then the
generated data structure will have a structure field with subfields. Note
that <span style="font-family: Courier">request</span> is a recursive
definition.</p>

<p>If request is null or an empty string than the entire PVRecord is
selected.</p>

<h3 id="Examples">Examples</h3>

<p>The following examples are for either a simple record or for a power
supply record. These are records that have one of the following
structures:</p>
<pre>simpleRecord
    value
    alarm
    timeStamp
    display
    .. other fields like input, etc

powerSupply
    alarm
    timeStamp
    power
       value
       alarm
       .. other fields
    voltage
       value
       alarm
       .. other fields
    current
       value
       alarm
       .. other fields
    .. other fields</pre>

<h4 id="Simple1">Simple example</h4>

<p>The following gets the alarm, timeStamp, and power.value.</p>
<pre>    PVStructure pvRequest = PVCopyFactory.createRequest("alarm,timeStamp,power.value");</pre>

<p>The following does the same thing.</p>
<pre>    PVStructure pvRequest = PVCopyFactory.createRequest("field(alarm,timeStamp,power.value)");</pre>
<pre></pre>

<p>In either case the PVStructure holding data for the requester will have
the structure:</p>
<pre> top
     alarm           // from record.alarm
     timeStamp       // from record.timeStamp
     value           // from record.power.value</pre>

<p>Note that if the actual record does not have a requested field than it
will not be present in the structure returned to the client.</p>

<p>The following is the same except that a record option and an option for
the value field will be given.</p>
<pre>     PVStructure pvRequest = PVCopyFactory.createRequest{
        "record[process=true]field(alarm,timeStamp,power.value[shareData=true]);</pre>

<p>The options are to process the record and to share the value data with the
power.value field in the PVRecord.</p>

<h4 id="Power">Power Supply Example</h4>

<p>The following:</p>
<pre>    PVStructure pvRequest = PVCopyFactory.createRequest(
       "field(alarm,timeStamp"
       + ",power{power.value,power.alarm}"
       + ",current{current.value,current.alarm}"
       + ",voltage{voltage.value,voltage.alarm})");</pre>

<p>Defines a client structure as follows:</p>
<pre>top
   alarm          // from record.alarm
   timeStamp      // from record.timeStamp
   power          // appears because of pvRequest
      value       // from record.power.value
      alarm       // from record.power.alarm
   current        // appears because of pvRequest
      value       // from record.current.value
      alarm       // from record.current.alar.
   voltage        // appears because of pvRequest
      value       // from record.voltage.value
      alarm       // from record.voltage.alarm</pre>
<hr />

<h2 style="text-align: center" id="pvRequest">pvRequest</h2>
<hr />

<h3 id="PVStructur">PVStructure pvRequest</h3>

<p>pvRequest is a PVStructure that describes 1) record options and 2) field
requests and options. It has the following structure:</p>
<pre>    &lt;structure&gt;
        &lt;structure name = "record"&gt;
            &lt;!-- 0 or more options with the definition--&gt;
            &lt;scalar name = "optionName" scalarType = "string"&gt;value&lt;/scalar&gt;
        &lt;/structure&gt;
        &lt;structure name = "field"&gt; &lt;!-- or putField and separate definition for getField --&gt;
            &lt;!-- 0 or 1 fieldList definition --&gt;
            &lt;scalar name = "fieldList" scalarType = "string"&gt;
                fullPVRecordFieldName,...,fullPVRecordFieldName
            &lt;/scalar&gt;
            &lt;!-- 0 or more fieldName definitions of the form --&gt;
            &lt;structure name = "fieldName"&gt;
                 &lt;!-- 0 or 1 definition of --&gt;
                 &lt;structure name = "leaf"&gt;
                     &lt;scalar name = "source" scalarType = "string"&gt;
                          fullPVRecordFieldName
                     &lt;/scalar&gt;
                     &lt;!-- 0 or more options for field --&gt;
                 &lt;/structure&gt;
                 &lt;!-- If not a leaf than 1 or more--&gt;
                 &lt;structure name = "fieldName"&gt;
                     &lt;!-- recursive definition of field--&gt;
                 &lt;/structure&gt;
            &lt;/structure
        &lt;/structure
    &lt;/structure&gt;

     OR
    &lt;structure&gt;
        &lt;!-- 0 or 1 fieldList definition --&gt;
        &lt;scalar name = "fieldList" scalarType = "string"&gt;
            fullPVRecordFieldName,...,fullPVRecordFieldName
        &lt;/scalar&gt;
        &lt;!-- 0 or more fieldName definitions of the form --&gt;
        &lt;structure name = "fieldName"&gt;
            &lt;!-- 0 or 1 definition of --&gt;
            &lt;structure name = "leaf"&gt;
                &lt;scalar name = "source" scalarType = "string"&gt;
                    fullPVRecordFieldName
                &lt;/scalar&gt;
                &lt;!-- 0 or more options for field --&gt;
            &lt;/structure&gt;
            &lt;!-- If not a leaf than 1 or more--&gt;
            &lt;structure name = "fieldName"&gt;
                &lt;!-- recursive definition--&gt;
            &lt;/structure&gt;
        &lt;/structure
    &lt;/structure&gt;</pre>

<p>where</p>
<dl>
  <dt><span style="font-family: Courier">record</span></dt>
    <dd>The options that apply to the entire record.</dd>
  <dt><span style="font-family: Courier">option</span></dt>
    <dd>This is of the form 
      <pre>&lt;scalar name = "optionName" scalarType = "string"&gt;value&lt;/scalar&gt;</pre>
    </dd>
  <dt><span style="font-family: Courier">field</span></dt>
    <dd>Definitions that select fields of the PVRecord and options for the
      fields. This definition is recursive.</dd>
  <dt><span style="font-family: Courier">fieldList</span></dt>
    <dd>A comma separated list of fullPVRecordFieldNames. Each will become a
      single field in the structure created by PVCopy with a field name that
      is the same as the field name of the corresponding
      fullPVRecordFieldName. For example if the fullPVFieldName =
      "power.value" then the field name is "value". </dd>
  <dt><span style="font-family: Courier">fieldName</span></dt>
    <dd>The field name that will appear in the PVStructure that is a copy of
      the fields selected from the PVRecord. </dd>
  <dt><span style="font-family: Courier">leaf</span></dt>
    <dd>This definition is a leaf element in the pvRequest structure. The
      field name in the copy structure will be fieldName. The field type will
      be is same as the type of fullPVRecordFieldName. This it could be a
      structure.</dd>
  <dt><span style="font-family: Courier">fullPVRecordFieldName</span></dt>
    <dd>The full fieldname of PVRecord to which the field of copy will
    map.</dd>
</dl>

<p>Note:</p>
<ul>
  <li>The definition is recursive , i.e. an arbitarily complex structure can
    be defined.</li>
  <li>If options are required for a field than fieldList can not be used.</li>
  <li>If a pvRequest with no fields is specified than all fields if the
    target PVRecord will appear in the PVCopy.</li>
</ul>

<p>Two examples of options are process and shareData.</p>

<p>Process is a record option:</p>
<pre>    &lt;structure name = "record"&gt;
         &lt;scalar name = "process" scalarType = "string"&gt;true&lt;/scalar&gt;
    &lt;/structure&gt;</pre>

<p>For example if process is an option to createGet then the record will be
processed before data is fetched. NOTE: scalarType boolean is also
supported.</p>

<p>The following is an example of a field option:</p>
<pre>   &lt;structure name = "field"&gt;
       ...
       &lt;structure name = "value"&gt;
           &lt;structure name = "leaf"&gt;
              &lt;scalar name = "source" scalarType = "string"&gt;value&lt;/scalar&gt;
              &lt;scalar name = "shareData" scalarType = "string"&gt;true&lt;/scalar&gt;
           &lt;/structure&gt;
       &lt;/structure&gt;
       ...
   &lt;/structure&gt;</pre>

<p>This is a request to share the actual data rather than creating a copy.</p>

<p>A pvRequest structure can be created via the PVDataCreate interface
implemented by PVDataCreateFactory or by a call to
PVCopyFactory.createRequest.</p>

<h3 id="Examples1">Examples</h3>

<p>The following examples are for the simple and powerSupply records
described in the previous section.</p>

<h4 id="Simple2">Simple example</h4>

<h5 id="quickest">The quickest Way</h5>

<p>The following structure defines a request for three fields: alarm,
timeStamp, and power.value</p>
<pre>&lt;structure&gt;
    &lt;scalar name = "fieldList" scalarType = "string"&gt;
       alarm,timeStamp,power.value
    &lt;/scalar&gt;
&lt;/structure&gt;</pre>

<p>The following shows how example can be done by directly calling
pvDataCreate.</p>
<pre>    PVStructure pvRequest = pvDataCreate.createPVStructure(null, "", new Field[0]);
    PVArrayString pvString = (PVString)pvDataCreate.createPVScalar(pvRequest,"fieldList",ScalerType.pvString);
    pvString.put("alarm,timeStamp,power.value");
    pvRequest.appendPVField(pvString);
 </pre>

<h5 id="Using">Using the field notation</h5>

<p>The following structure defines a request for three fields: alarm,
timeStamp, and power.value</p>
<pre>&lt;structure&gt;
    &lt;structure name = "field"&gt;
        &lt;scalar name = "fieldList" scalarType = "string"&gt;
           alarm,timeStamp,power.value
        &lt;/scalar&gt;
    &lt;/structure&gt;
&lt;/structure&gt;</pre>

<p>The following shows how the example can be done by directly calling
pvDataCreate.</p>
<pre>    PVStructure pvRequest = pvDataCreate.createPVStructure(null, "", new Field[0]);
    PVStructure pvField = pvDataCreate.createPVStructure(pvRequest,"field", new Field[0]);
    PVArrayString pvString = (PVString)pvDataCreate.createPVScalar(pvField,"fieldList",ScalerType.pvString);
    pvString.put("alarm,timeStamp,power.value");
    pvField.appendPVField(pvString);
    pvRequest.appendPVField(pvField);
 </pre>

<p>In either case (quickest way or using the field notation) the PVStructure
holding data for the requester will have the structure:</p>
<pre> top
     alarm           // from record.alarm
     timeStamp       // from record.timeStamp
     value           // from record.power.value</pre>

<p>Note that if the actual record does not have a requested field than it
will not be present in the structure returned to the client.</p>

<p>The following is the same except that a record option and an option for
the value field will be given.</p>
<pre>&lt;structure&gt;
    &lt;structure name = "record"&gt;
        &lt;scalar name = "process" scalarType = "string"&gt;true&lt;/scalar&gt;
    &lt;/structure&gt;
    &lt;structure name = "field"&gt;
        &lt;scalar name = "fieldList" scalarType = "string"&gt;
           alarm,timeStamp
        &lt;/scalar&gt;
        &lt;structure name = "value"&gt;
            &lt;scalar name = "leaf" scalarType = "string"&gt;power.value&lt;/scalar&gt;
            &lt;scalar name = "shareData" scalarType = "string"&gt;true&lt;/scalar&gt;
        &lt;/structure&gt;
    &lt;/structure&gt;
&lt;/structure&gt;</pre>

<p>The options are to process the record and to share the value data with the
power.value field in the PVRecord.</p>

<h4 id="Power1">Power Supply Example</h4>

<p>The following structure defines a request for alarm, timeStamp, power,
current, and voltage. Power, current, and voltage will each be a structure
with two fields: value and alarm.</p>
<pre>&lt;structure&gt;
    &lt;structure name = "field"&gt;
        &lt;scalar name = "fieldList" scalarType = "string"&gt;alarm,timeStamp&lt;/scalar&gt;
        &lt;structure name = "power"&gt;
            &lt;scalar name = "fieldList" scalarType = "string"&gt;
                power.value,power.alarm
            &lt;/scalar&gt;
        &lt;/structure&gt;
        &lt;structure name = "current"&gt;
            &lt;scalar name = "fieldList" scalarType = "string"&gt;
                current.value,current.alarm
            &lt;/scalar&gt;
        &lt;/structure&gt;
        &lt;structure name = "voltage"&gt;
            &lt;scalar name = "fieldList" scalarType = "string"&gt;
                voltage.value,voltage.alarm
            &lt;/scalar&gt;
        &lt;/structure&gt;
    &lt;/structure&gt;
&lt;/structure&gt;</pre>

<p>The following shows how this can be done by directly calling
pvDataCreate.</p>
<pre>    PVStructure pvRequest = pvDataCreate.createPVStructure(null, "", new Field[0]);
    PVStructure pvField = pvDataCreate.createPVStructure(pvRequest,"field", new Field[0]);
    PVString pvString = (PVString)pvDataCreate.createPVField(pvField,"fieldList",ScalerType.pvString);
    pvString.put("alarm,timeStamp");
    pvField.appendPVField(pvString);
    PVStructure pvStructure = pvDataCreate.createPVStructure(pvField, "power", new Field[0]);
    pvString = (PVString)pvDataCreate.createPVField(pvStructure,"fieldList",ScalerType.pvString);
    pvString.put("power.value,power.alarm");
    pvStructure.appendPVField(pvString)
    pvField.appendPVField(pvStructure);
    pvStructure = pvDataCreate.createPVStructure(pvField, "current", new Field[0]);
    pvString = (PVString)pvDataCreate.createPVField(pvStructure,"fieldList"ScalerType.pvString);
    pvString.put("current.value,current.alarm");
    pvStructure.appendPVField(pvString)
    pvField.appendPVField(pvStructure);
    pvStructure = pvDataCreate.createPVStructure(pvField, "voltage", new Field[0]);
    pvString = (PVString)pvDataCreate.createPVField(pvStructure,"fieldList"ScalerType.pvString);
    pvString.put("voltage.value,voltage.alarm");
    pvStructure.appendPVField(pvString)
    pvField.appendPVField(pvStructure);
    pvRequest.appendField(pvField);</pre>

<p>In either case the resulting structure that appears to the client has the
form:</p>
<pre>pvData
   alarm          // from record.alarm
   timeStamp      // from record.timeStamp
   power          // appears because of pvRequest
      value       // from record.power.value
      alarm       // from record.power.alarm
   current        // appears because of pvRequest
      value       // from record.current.value
      alarm       // from record.current.alar.
   voltage        // appears because of pvRequest
      value       // from record.voltage.value
      alarm       // from record.voltage.alarm</pre>
<hr />

<h2 style="text-align: center" id="BitSetUtil">BitSetUtil</h2>
<hr />

<p>This provides functions that operate of a BitSet for a PVStructure. It has
the definitions:</p>
<pre>interface BitSetUtil {
    boolean compress(BitSet bitSet,PVStructure pvStructure);
}

class BitSetUtilFactory {
    public static BitSetUtil getCompressBitSet();
}</pre>

<p>It currently has only one method:</p>
<dl>
  <dt><span style="font-family: Courier">compress</span></dt>
    <dd>Compress the bits in a BitSet related to a structure.<br />
      For each structure: 
      <ol>
        <li>If the bit for the structure is set then the bit for all
          subfields of the structure are cleared. </li>
        <li>If the bit for the structure is not set but all immediate
          subfields have their bit set then the bit for the structure is set
          and the bits for all subfields are cleared. </li>
      </ol>
      Note that this is a recursive algorithm. That is if every immediate
      subfield has it's offset bit set then the bits for ALL fields that
      reside in the structure will be cleared.</dd>
    <dd>Channel Access can call this before sending data. It can then pass
      entire structures if the structure offset bit is set. </dd>
</dl>
<hr />

<h2 style="text-align: center" id="PVCopy">PVCopy</h2>
<hr />

<p>This is the interface for mapping between a PVStructure that contain a
copy of the data for a subset of the fields in a PVRecord. Note that this
interface is NOT for a single PVStructure but for a single PVRecord and a
single Structure introspection interface that describes a subset of the
fields in the PVRecord. For example if a server supports monitor queues then
the server will allocate a PVStructure for each queue element but will create
a single PVCopy.</p>
<pre>    interface PVCopy {
        PVRecord getPVRecord();
        Structure getStructure();
        PVStructure createPVStructure();
        int getCopyOffset(PVField recordPVField);
        int getCopyOffset(PVStructure recordPVStructure,PVField recordPVField);
        PVField getRecordPVField(int structureOffset);
        void initCopy(PVStructure pvCopy, BitSet bitSet,boolean recordLocked);
        void updateCopySetBitSet(PVStructure copyPVStructure,BitSet bitSet,boolean lockRecord);
        void updateCopyFromBitSet(PVStructure copyPVStructure,BitSet bitSet,boolean lockRecord);
        boolean updateRecord(PVStructure pvCopy,BitSet bitSet,boolean lockRecord);
        PVCopyMonitor createPVCopyMonitor(PVCopyMonitorRequester pvCopyMonitorRequester);
    }</pre>

<p>where</p>
<dl>
  <dt><span style="font-family: Courier">getPVRecord</span></dt>
    <dd>Get the PVRecord to which this PVCopy is attached</dd>
  <dt><span style="font-family: Courier">getStructure</span></dt>
    <dd>Get the introspection interface which describes the subset of the
      fields in the PVRecord.</dd>
  <dt><span style="font-family: Courier">createPVStructure</span></dt>
    <dd>Create a PVStructure which can hold a subset of the data from the
      PVRecord. A client may require multiple PVStructures. For example if a
      monitor request supports a queue than a PVStructure is required for
      each queue element. </dd>
  <dt><span style="font-family: Courier">getCopyOffset(PVField
  recordPVField)</span></dt>
    <dd>Given a PVField from the record determine the offset within the
      PVStructure where the copy of the data is located.
      PVStructure.getSubField(offset) can be called to locate the PVField
      within the PVStructure. </dd>
  <dt><span style="font-family: Courier">getCopyOffset(PVStructure
  recordPVStructure,PVField recordPVField)</span></dt>
    <dd>Given a recordPVField within a recordPVStructure determine the offset
      within the PVStructure where the copy of the data is located.
      PVStructure.getSubField(offset) can be called to locate the PVField
      within the PVStructure. </dd>
  <dt><span style="font-family: Courier">getRecordPVField</span></dt>
    <dd>Given an offset within a PVStructure return the corresponding PVField
      in the PVRecord.</dd>
  <dt><span style="font-family: Courier">initCopy</span></dt>
    <dd>Initialize PVStructure with the current data from the PVRecord. The
      bitSet will have offset 0 set to 1 and all other bits set to 0. </dd>
  <dt><span style="font-family: Courier">updateCopySetBitSet</span></dt>
    <dd>Update PVStructure from PVRecord. The BitSet shows which fields in
      PVStructure have changed.</dd>
  <dt><span style="font-family: Courier">updateCopyFromBitSet</span></dt>
    <dd>Update PVStructure from PVRecord. Only fields that have the offset in
      bitSet set to true are modified.</dd>
  <dt><span style="font-family: Courier">updateRecord</span></dt>
    <dd>Update the fields in PVRecord with data from PVStructure. Only fields
      that have the offset in bitSet set to true are modified. </dd>
  <dt><span style="font-family: Courier">createPVCopyMonitor</span></dt>
    <dd>Create a PVCopyMonitor. See next section.</dd>
</dl>
<hr />

<h2 style="text-align: center" id="PVCopyMoni">PVCopyMonitor</h2>
<hr />

<p>PVCopyMonitor is a PVListener for the PVRecord to which PVCopy is
attached. It updates two bitSets when it receives PVListener.dataPut
callbacks. changeBit shows all fields that have changed between calls to
switchBitSets. overrunBitSet shows all fields that have changed value more
than once between calls to switchBitSets. It notifies the
PVCopyMonitorRequester when data has changed. </p>
<pre>interface PVCopyMonitorRequester {
    void dataChanged();
    void unlisten();
}

interface PVCopyMonitor {
    void startMonitoring(BitSet changeBitSet, BitSet overrunBitSet);
    void stopMonitoring();
    void switchBitSets(BitSet newChangeBitSet,BitSet newOverrunBitSet, boolean lockRecord);
}</pre>

<p>PVCopyMonitorRequester is the interface implemented by the caller that
calls PVCopy.createPVCopyMonitor:</p>
<dl>
  <dt><span style="font-family: Courier">dataChanged</span></dt>
    <dd>Data being monitored has changed.</dd>
  <dt><span style="font-family: Courier">unlisten</span></dt>
    <dd>PVCopyMonitor has been told to unlisten so not more monitors will
      occur. </dd>
</dl>

<p>PVCopyMonitor is the interface returned by a call to
PVCopy.createPVCopyMonitor.</p>
<dl>
  <dt><span style="font-family: Courier">startMonitoring</span></dt>
    <dd>Start monitoring.</dd>
  <dt><span style="font-family: Courier">stopMonitoring</span></dt>
    <dd>Stop monitoring.</dd>
  <dt><span style="font-family: Courier">switchBitSets</span></dt>
    <dd>If the pvStructure is not shared all fields that changeBitSet shows
      were changed are copied from the corresponding PVField of the PVRecord
      to the PVField of the PVStructure. Then the bitSets are replaced by the
      new bitSets. Note that a client needs just two instances of the bitSets
      and can just cycle between the two sets. Even if the PVStructure is
      shared this method is important since the caller will not miss data
      changes. It is illegal to call this if startMonitoring was called with
      no arguments.</dd>
</dl>
<hr />

<h2 style="text-align: center" id="PVCopyFact">PVCopyFactory</h2>
<hr />

<h3 id="Java">Java Definition</h3>
<pre>    class PVCopyFactory {
        static PVCopy create(PVRecord pvRecord,PVStructure pvRequest,String structureName);
        static PVStructure createRequest(String request);
    }</pre>

<p><span style="font-family: Courier">create</span> has the arguments</p>
<dl>
  <dt><span style="font-family: Courier">pvRecord</span></dt>
    <dd>The PVRecord to which the server is attached.</dd>
  <dt><span style="font-family: Courier">pvRequest</span></dt>
    <dd>A PVStructure which describes the fields of PVRecord to which the
      server wants access. It is described below.</dd>
  <dt><span style="font-family: Courier">structureName</span></dt>
    <dd>This must be one of: "field", "putField", or "getField"</dd>
</dl>

<p><span style="font-family: Courier">createRequest</span> is an easy way to
create a pvRequest structure to pass to <span
style="font-family: Courier">create</span>. It is described below.</p>
<hr />

<h2 style="text-align: center" id="PVShare">PVShare</h2>
<hr />

<p>This is a factory that replaces a scalar or scalarArray field with a
version that shares the data from another field. When a get or put is issued
the get or put method of the shared PVField is called.</p>
<pre>class PVShareFactory {
    public static PVScalar replace(PVScalar pvNow,PVScalar pvShare);
    public static PVArray replace(PVArray pvNow,PVArray pvShare);
}</pre>
</body>
</html>
