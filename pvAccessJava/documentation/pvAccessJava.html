<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
      "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="content-type" content="text/html; charset=iso-8859-1" />
  <title>EPICS pvAccessJava</title>
  <link rel="stylesheet" type="text/css"
  href="http://epics-pvdata.sourceforge.net/base.css" />
  <link rel="stylesheet" type="text/css"
  href="http://epics-pvdata.sourceforge.net/epicsv4.css" />
  <style type="text/css">
  /*<![CDATA[*/
     .about { margin-left: 3em; margin-right: 3em; font-size: .83em}
     table { margin-left: auto; margin-right: auto }
     .diagram { text-align: center; margin: 2.5em 0 }
     span.opt { color: grey }
     span.nterm { font-style:italic }
     span.term { font-family:courier }
     span.user { font-family:courier }
     span.user:before { content:"<" }
     span.user:after { content:">" }
     .nonnorm { font-style:italic }
     p.ed { color: #AA0000 }
     span.ed { color: #AA0000 }
     p.ed.priv { display: inline; }
     span.ed.priv { display: inline; }
  /*]]>*/</style>
  <!-- Script that generates the Table of Contents -->
  <script type="text/javascript"
  src="http://epics-pvdata.sourceforge.net/script/tocgen.js">
 </script>
</head>

<body>

<div class="head">
<h1>EPICS pvAccessJava</h1>
<!-- Maturity: Working Draft or Request for Comments, or Recommendation, and date. -->

<h2 class="nocount">EPICS v4 Working Group, Working Draft, 05-Sep-2012</h2>
<dl>
  <dt>This version:</dt>
    <dd><a
      href="http://epics-pvdata.sourceforge.net/pvAccessJava_20111220.html">pvAccessJava_20120905.html</a></dd>
  <dt>Latest version:</dt>
    <dd><a
      href="http://epics-pvdata.sourceforge.net/pvAccessJava_20111220.html">pvAccessJava_20120905.html</a></dd>
  <dt>Editors:</dt>
    <dd>Marty Kraimer, BNL<br />
      Matej Sekoranja, CosyLab</dd>
</dl>
</div>

<h2 class="nocount">Abstract</h2>

<p>pvAccessJava is the Java implementation of pvAccess, which is one of a
related set of products:</p>
<dl>
  <dt>pvData</dt>
    <dd>pvData (Process Variable Data) defines and implements an efficent way
      to store, access, and transmit memory resident structured data</dd>
  <dt>pvAccess</dt>
    <dd>pvAccess is network support for transmitting pvData.</dd>
  <dt>pvIOC</dt>
    <dd>A pvIOC is a network accessable smart real time database. The database
      consists of memory resident records. Each record has a name that is
      unique within the local area network and contains a top level pvData
      structure. Each field of a record can optionally have support code
      attached to it. The support is called when a request is made to process
      the record. The support code is what makes the record "smart". A pvAccess
      server is provided so that the records can be accesed via the network.
    </dd>
  <dt>pvService</dt>
    <dd>A middle layer for implementing services.</dd>
</dl>

<p>Each of the products has a Java and a C++ implementation.</p>

<p>The products are all part of the <a
href="http://epics-pvdata.sourceforge.net/">V4</a> implementation of <a
href="http://www.aps.anl.gov/epics/">Experimental Physics and Industrial
Control System.</a></p>

<h2 class="nocount">Status of this Document</h2>

<p>This is the 05-Sep-2012 version of the Java implementation of pvAccess. It
is a complete implementation of pvAccess as currently defined. </p>

<h2 class="nocount">TODO</h2>

<p>The following is a list of unresolved issues for pvAccessJava:</p>
<dl>
  <dt>(none)</dt>
    <dd>(none)</dd>
</dl>

<div id="toc">
<h2 class="nocount" style="page-break-before: always">Table of Contents</h2>
</div>

<div id="contents" class="contents">
<h2>Introduction</h2>

<p>This product is available via an <a
href="http://epics-pvdata.sourceforge.net/LICENSE.html">open source
license</a></p>

<p>This document is the project and package overviews for pvAccessJava. The
javaDOC is available at <a href="./html/index.html">JavaDoc</a></p>

<p>The javaDOC package overview documents for this project are not complete but
the packages of interest to people writing client code or connecting an
application that wants to start a pvAccess server is complete. What remains is
to fully document the implementation. This project overview gives a brief
description of the packages provided by this project.</p>

<p>This project implements pvAccess, which is an implementation of Channel
Access that fully supports pvData. Package <b>org.epics.pvaccess.client</b> is
of interest to anyone who wants to write client code for pvAccess and is also
of interest to anyone who wants to write a server that interfaces to other
system. The other packages are mainly of interest to those who want to
understand the internals of the implementation.</p>

<p>If your interest is only to write client code go directly to
<b>org.epics.pvaccess.client</b></p>

<p>This project provides the client and server networking spport for the
interfaces defined in <b>org.epics.pvaccess.client</b>. The pvIOCJava provides
a local implementation of pvAccess API, which registers itself with the server
support provided by this project. Other implementations can also be
provided.</p>

<p>This package also allows the following:</p>
<ol>
  <li>An application can be created that provide a pvAccess server that
    provides full support for pvData.This is done by starting a local
    PVDatabase, calling org.epics.pvaccess.LocalFactory.start(), and calling
    org.epics.pvaccess.ServerFactory.start().</li>
  <li>An extensible set of monitoring algorithms is supported. Monitoring is
    defined by project pvData. pvAccess provides access to this facility. A
    default set of monitoring algorithms is provided by pvData but other
    algorithms can be implemented. The code that implements an algorithm must
    extend org.epics.pvdata.monitor.AbstractMonitor and register with
    org.epics.pvaccess.server.ChannelServer.</li>
  <li>A gateway between pvAccess and other systems can be implemented. For
    example projects pvAccessJava and pvIOCJava provide gateway code between
    caV3 and pvAccess. pvAccessJava (see package <b>org.epics.caV3</b>) allows
    pvAccess client to talk to a caV3 server, pvIOCJava (see package
    <b>org.epics.pvioc.caV3</b>) allows caV3 client to talk to a pvAccess
    server.</li>
</ol>

<h2>User Interface Packages</h2>

<p>This section briefly describes the interfaces used by a pvAccess client and
by an application that supports a pvAccess server. It only describes how things
are connected, i.e. it does not describe pvAccess API or any of its related
interfaces because they are described in the package overview for
org.epics.pvaccess.client.</p>

<h3>org.epics.pvaccess</h3>

<p>This package provides the factories that start the various components of
pvAccess:</p>
<dl>
  <dt>ClientFactory</dt>
    <dd>This starts the client side of the network support for pvAccess. This
      is the only support that needs to be started by a stand-alone client. The
      example shown in the previous section calls this.</dd>
  <dt>ServerFactory</dt>
    <dd>This must be started in order to allow pvAccess clients to access the
      local pvAccess data source. For example the pvIOCJava (PVDatabase) can
      start this.</dd>
</dl>

<h3>org.epics.pvaccess.client</h3>

<p>This package provides everything required for a pvAccess client. See the
package overview for details. This section only describes how to connect to a
channel and how to register monitor algoritms and channel providers.</p>

<p>To connect to a channel a client does the following:</p>
<pre>    // define the following
    private static final ChannelAccess channelAccess
         = ChannelAccessFactory.getChannelAccess();

    // get wanted channel provider 
    ChannelProvider channelProvider = channelAccess.getProvider("pvAccess");

    // connect to a channel with given name
    Channel channel = channelProvider.createChannel(
                                         "someChannel",
                                         channelRequester,
                                         ChannelProvider.PRIORITY_DEFAULT);</pre>

<p>This package defines the interfaces a client uses to comnmunicate with a
pvAccess server. This project fully implements all the interfaces. If a server
is implemented for other systems, it is OK to implement a subset of the
interfaces. For example the caV3 server implemented by the pvIOCJava does not
support ChannelPutGet because an EPICS V3 IOC does not provide an equivalent
facility.</p>

<p>Except for ChannelAccessFactory and CreateRequestFactory, this package
contains only Java interface and enum definition. ChannelAccessFactory provides
a complete implementation of interface ChannelAccess and three static public
members:</p>
<pre>public class ChannelAccessFactory {
    public static ChannelAccess getChannelAccess();
    public static void registerChannelProvider(ChannelProvider channelProvider);
    public static void unregisterChannelProvider(ChannelProvider channelProvider);
}</pre>

<p>where</p>
<dl>
  <dt>getChannelAccess</dt>
    <dd>This gets the single instance of ChannelAccess</dd>
  <dt>registerChannelProvider</dt>
    <dd>This registers a ChannelProvider. Usually user code does not call this,
      e.g. it is called via the factories in <b>org.epics.pvaccess</b></dd>
  <dt>unregisterChannelProvider</dt>
    <dd>This unregisters a ChannelProvider. Usually user code does not call
      this, e.g. it is called via the factories in
    <b>org.epics.pvaccess</b></dd>
</dl>

<p>ChannelAccess is defined as:</p>
<pre>interface ChannelAccess {
    ChannelProvider getProvider(String providerName);
    String[] getProviderNames();
}</pre>

<p>where</p>
<dl>
  <dt>getProvider</dt>
    <dd>Get the channel provider.</dd>
  <dt>getProviderNames</dt>
    <dd>Get the names of all regsitered providers.</dd>
</dl>

<p>ChannelProvider has a method (among others):</p>
<pre>Channel createChannel(String channelName, ChannelRequester channelRequester, short priority); 
 ...</pre>

<p>This is the method a client calls to connect to a Channel. See the package
overview for details.</p>

<h2>Problems and Future Plans</h2>

<h3>Access Security</h3>

<p>Something like how csV3 implements access security is required. A
complication is that for caV3 a client attaches to a single scalar or array
field. For pvAccess a client attaches to an arbirary set of fields in a record.
Takes some thought to decide what to do.</p>

<h3>User Controlled Send Queues</h3>

<p>Currently a user can only ask to send a message immediately, i. e. a client
has no control over when a message is sent. This can result in many short
network packets. Perhaps the following should be provided: Allow a client, for
each send request, to specify the following options:</p>
<dl>
  <dt>immediate</dt>
    <dd>Immediately queue a request to the send thread.</dd>
  <dt>periodically</dt>
    <dd>Put requests on a periodic send queue. At some periodic rate the queue
      is transfered to the send thread.</dd>
  <dt>user queue</dt>
    <dd>Client keeps a private queue for requests. The client decides when the
      queue should be transfered to the send thread.</dd>
</dl>

<h2>Helper Packages</h2>

<p>This is set of packages that are used by other parts of this project</p>

<h3>org.epics.pvaccess</h3>

<p>This has the following:</p>
<dl>
  <dt>ClientFactory</dt>
    <dd>Starts the client side of remote pvAccess.</dd>
  <dt>ServerFactory</dt>
    <dd>Starts the server side of remote pvAccess.</dd>
  <dt>CAConstants</dt>
    <dd>A set of constants for pvAccess</dd>
  <dt>CAException</dt>
    <dd>An extension to Exception for pvAccess</dd>
  <dt>Version</dt>
    <dd>Defines the version.</dd>
  <dt>PVFactory</dt>
    <dd>Factory proxy for all the standard pvData factories used by
    pvAccess.</dd>
</dl>

<h3>org.epics.pvaccess.util.logging</h3>

<p>A logging facility based on java.util.logging. This has the following:</p>
<dl>
  <dt>LoggerProvider</dt>
    <dd>Defines an interface that provides a logger.</dd>
  <dt>ConsoleLogFormatter</dt>
    <dd>Java API formatter that produces single line log reports meant to go to
      the console.</dd>
  <dt>ConsoleLogHandler</dt>
    <dd>Java API log handler output logs to the System.out. By default it uses
      ConsoleLogFormatter.</dd>
</dl>

<p>To setup a simple logging in you console application, use the following
code:</p>
<pre>        ConsoleLogHandler.defaultConsoleLogging(Level.INFO);
        Logger logger = Logger.getLogger(MyApplicationClass.class.getName());

        ...
        logger.info("Hello world.");</pre>

<h2>Implementation Packages</h2>

<p>These packages provide implementation classes and interfaces shared by both
the client and server code for pvAccess</p>

<h3>org.epics.pvaccess.util</h3>

<p>This has the following:</p>
<dl>
  <dt>CircularBuffer</dt>
    <dd>A fixed size circular buffer. If full a new element replaces the
    oldest.</dd>
  <dt>GrowingCircularBuffer</dt>
    <dd>A circular buffer that holds an unlimited number of elements.</dd>
  <dt>HexDump</dt>
    <dd>Converts a byte array to hex and writes to System.out.println.</dd>
  <dt>InetAddressUtil</dt>
    <dd>Convience methods for INET address conversion.</dd>
  <dt>IntHashMap</dt>
    <dd>An integer hash map. This is used instead of java.util.HashMap so that
      Integer objects do not have to be allocated.</dd>
  <dt>Mailbox</dt>
    <dd>Optimized usage of concurrent linked list queue.</dd>
  <dt>ShortHashMap</dt>
    <dd>A short hash map. This is used instead of java.util.HashMap so that
      Short objects do not have to be allocated.</dd>
</dl>

<h3>org.epics.pvaccess.util.sync</h3>

<h3>org.epics.pvaccess.util.configuration</h3>

<h3>org.epics.pvaccess.util.configuration.impl</h3>

<h3>org.epics.pvaccess.impl.remote</h3>

<p>This package contains enums, interface, and abstract class definitions
common to both the client and server implementation. </p>

<h3>org.epics.pvaccess.impl.remote.codec</h3>

<h3>org.epics.pvaccess.impl.remote.codec.impl</h3>

<h3>org.epics.pvaccess.impl.remote.io</h3>

<h3>org.epics.pvaccess.impl.remote.io.impl</h3>

<h3>org.epics.pvaccess.impl.remote.request</h3>

<h3>org.epics.pvaccess.impl.remote.tcp</h3>

<p>This contains the code that sends and receives tcp messages. It creates a
send and a receive thread for each tcp connectrion.</p>

<h3>org.epics.pvaccess.impl.remote.udp</h3>

<p>This contains the code that sends and receives udp messages. It creates a
send and a receive thread for each udp connectrion.</p>

<h3>org.epics.pvaccess.impl.remote.utils</h3>

<p>Some network utility support.</p>

<h2>Client Implementation Packages</h2>

<p>These packages provide the implementation classes and interfaces for the
client code for pvAccess.</p>

<h3>org.epics.pvaccess.client.impl.remote</h3>

<p>This implements the client side of passing the various ChannelXXX requests
over the network, where XXX is Get, Put, PutGet, etc. This code uses the code
in the following two packages to send requests and receive responses.</p>

<h3>org.epics.pvaccess.client.impl.remote.handlers</h3>

<p>This implements handlers for receiving responses from network requests.</p>

<h3>org.epics.pvaccess.client.impl.remote.requests</h3>

<p>This implements code that sends a network request.</p>

<h3>org.epics.pvaccess.client.impl.remote.search</h3>

<h3>org.epics.pvaccess.client.impl.remote.tcp</h3>

<p>This interfaces the client code to package
org.epics.pvaccess.impl.remote.tcp.</p>

<h2>Server Implementation Packages</h2>

<p>These packages provide the implementation classes and interfaces for the
server code for pvAccess.</p>

<h3>org.epics.pvaccess.server.impl.remote</h3>

<p>This implements the server side of passing the various ChannelXXX requests
over the network, where XXX is Get, Put, PutGet, etc. This code uses the code
in the following two packages to send requests and receive responses. It also
has the code which issues beacons.</p>

<h3>org.epics.pvaccess.server.impl.remote.handlers</h3>

<p>This implements handlers for receiving requests from the client.</p>

<h3>org.epics.pvaccess.server.impl.remote.plugins</h3>

<p>Currently has just code related to beacons.</p>

<h3>org.epics.pvaccess.server.impl.remote.tcp</h3>

<p>This interfaces the server code to package
org.epics.pvaccess.impl.remote.tcp.</p>

<h3>org.epics.pvaccess.server.impl.rpc</h3>

<h3>org.epics.pvaccess.server.impl.rpc.impl</h3>

<h2>Package org.epics.pvaccess</h2>

<h3>Overview</h3>

<p>This package provides:</p>
<dl>
  <dt>Factories</dt>
    <dd>Factories are available to start pvAccess channel access. This includes
      local channel access and the client and server for remote pvAccess.</dd>
  <dt>CAConstants</dt>
    <dd>A set of constants used by the pvAccess implementation.</dd>
  <dt>CAException</dt>
    <dd>A extension of Exception for pvAccess.</dd>
  <dt>Version</dt>
    <dd>Administrative class to keep track of the version number.</dd>
</dl>

<h3>Factories</h3>

<p>Each factory has a single public method:</p>
<pre>    public static synchronized void start();</pre>

<p>For example the pvAccess client can be started by calling:</p>
<pre>    org.epics.pvaccess.ClientFactory.start();</pre>

<p>The following factories are available:</p>
<dl>
  <dt>ClientFactory</dt>
    <dd>This starts the client side of the network support for pvAccess. This
      is the only support that needs to be started by a stand-alone client.</dd>
  <dt>LocalFactory</dt>
    <dd>This is called for accessing a local PVDatabase. It is also required by
      the ServerFactory and must be started before the server factory. An
      application that wants to use channel access to access the local database
      must start this. For example the JavaIOC starts this.</dd>
  <dt>ServerFactory</dt>
    <dd>This must be started in order to allow pvAccess clients to access the
      local PVDatabase. For example the javaIOC can start this.</dd>
</dl>

<h3>CAConstants</h3>

<p>This defines a number of constants used by the implementation. It is not of
interest to users. Look at the source for details.</p>

<h3>CAException</h3>

<p>This is a simple extension of the Java Exception class. It is defined so
that channel access specific exceptions can be thrown.</p>

<h3>Version</h3>

<p>This is an administrative class to keep track of the version number. See the
code for details.</p>

<h2>Package org.epics.pvaccess.client</h2>

<h3>Overview</h3>

<p>This package defines the client interfaces for pvAccess, which is a version
of channel access that fully supports structured data as defined by PVData. It
is assumed that the reader understands PVData, which is implemented by the
eclipse project "org.epics.pvdata". </p>

<p>A Channel provides a communication path beween a client and a PVRecord. A
channel access server, which must reside in the same process as the PVRecord,
provides access to the record. The client and server can be part of the same
process or can be in different processes on the same network node or on
different network nodes. Channel Access provides the connection between the
client and server.</p>

<p>A client creates a channel via a call to ChannelProvider.createChannel. A
ChannelProvider is located via a call to ChannelAccess.getProvider.
ChannelAccess is located via ChannelAccessFactory.</p>

<p>This overview discusses:</p>
<ul>
  <li>An example client.</li>
  <li>How to connect to a channel provider.</li>
  <li>An overview of all the client interfaces..</li>
</ul>

<p>Many of the methods described below return or have a argument Status. This
is defined in project pvData as follows:</p>
<pre>interface Status extends Serializable {
    public enum StatusType {OK,WARNING,ERROR,FATAL}
    StatusType getType();
    String getMessage();
    String getStackDump();
    boolean isOK();
    boolean isSuccess();
}</pre>

<p>Unless isSuccess is true the client must realize that the request failed.
When a failure occurs, other arguments may be null.</p>

<h3>Example</h3>

<h4>What the example does</h4>

<p>This section shows an example of issuing a channel get request. the example
is a java main program that can be executed as follows:</p>
<pre>java org.epics.pvaccess.client.example.ExampleChannelGet &lt;channelName&gt; &lt;request&gt;</pre>

<p>For example if the arguments are:</p>
<pre>    counter field(value)</pre>

<p>The output is:</p>
<pre>structure example
{
    value = 8
}</pre>

<p>If the arguments are: </p>
<pre>    counter field(value,alarm,timeStamp)</pre>

<p>The output is (TODO now actually isn't):</p>
<pre>structure example
{
    value = 5
    alarm = structure
    {
        severity = structure
        {
            index = 0
            choices = [none,minor,major,invalid]
        }
        message = null
        ackTransient = false
        ackSeverity = structure
        {
            index = 0
            choices = [none,minor,major,invalid]
        }
    }
    timeStamp = structure
    {
        secondsPastEpoch = 1253549456
        nanoSeconds = 478000000
    }
}</pre>

<p>If the request is not given then the entire record is shown.</p>

<h4>Example Source</h4>

<h5>main</h5>
<pre>public class ExampleChannelGet {
    public static void main(String[] args) throws CAException {
        org.epics.pvaccess.ClientFactory.start();
        int len = args.length;
        if(len&lt;1 || len&gt;2 || (len==1 &amp;&amp; args[0].equals("?"))) {
            System.out.println("Usage: channelName request");
            return;
        }
        String channelName = args[0];
        String request = null;
        if(len==2) {
            request = args[1];
        }
       
        Client client = new Client(channelName,request);
        for(int i=0; i&lt;10; i++) {
            if(client.isDone()) break;
            try {
                System.out.println("waiting");
                Thread.sleep(1000);
            } catch (Throwable th) {
                th.printStackTrace();
            }
        }
    }

    private static final String providerName = "pvAccess";
    private static final ChannelAccess channelAccess = ChannelAccessFactory.getChannelAccess();
    private static final PVDataCreate pvDataCreate = PVDataFactory.getPVDataCreate();</pre>

<p>The main routine first checks for valid arguments, creates an instance of
Client, which is shown below, and then waits for up to ten seconds until Client
has obtained data.</p>

<h5>Implementation of channel get client</h5>
<pre>    private static class Client implements ChannelRequester, ChannelGetRequester {

        Client(String channelName,String request) {
            if(request==null) {
                pvRequest = pvDataCreate.createPVStructure(null, "example", new Field[0]);
            } else {
                pvRequest = CreateRequestFactory.createRequest(request);
            }
            channelProvider = channelAccess.getProvider(providerName);
            channelProvider.createChannel(channelName, this, ChannelProvider.PRIORITY_DEFAULT);
        }

        private ChannelProvider channelProvider = null;
        private Channel channel = null;
        private ChannelGet channelGet = null;
        private PVStructure pvStructure = null;
        private BitSet bitSet = null;
        private PVStructure pvRequest = null;
        private boolean done = false;

        boolean isDone() {return done;}</pre>

<p>The above is the constructor and private data. The constructor creates a
channel. This will result in a call to channelCreated and, if succesful, a call
to channelStateChange.</p>

<h5>ChannelRequester methods.</h5>
<pre>        public void channelCreated(Status status, Channel channel) {
            if(!status.isSuccess()) {
                message("channelCreated " + status.getMessage(),MessageType.error);
                done = true;
                return;
            }
            this.channel = channel;
        }

        public void channelStateChange(Channel c,ConnectionState connectionState) {
            if(connectionState==ConnectionState.CONNECTED) {
                this.channel = c;
                channelGet = channel.createChannelGet(this, pvRequest);
            } else {
                message(connectionState.name(),MessageType.error);
                done = true;
            }
        }</pre>

<p>channelCreated just checks status and saves the reference to the channel.
<b>channelStateChange</b> calls <b>createChannelGet</b> when the channel
connects. This will result in a call to <b>channelGetConnect</b>. </p>

<h5>ChannelGetRequester methods:</h5>
<pre>        public void channelGetConnect(Status status, ChannelGet channelGet,PVStructure pvStructure, BitSet bitSet) {
            if(!status.isSuccess()) {
                message("channelGetConnect " + status.getMessage(),MessageType.error);
                done = true;
                return;
            }
            synchronized(this) {
                this.channelGet = channelGet;
                this.pvStructure = pvStructure;
                this.bitSet = bitSet;
            }
            channelGet.get(true);
        }

        public void getDone(Status status) {
            if(!status.isSuccess()) {
                message("getDone " + status.getMessage(),MessageType.error);
                done = true;
                return;
            }
            message(pvStructure.toString(),MessageType.info);
            done = true;
        }</pre>

<p>channelGetConnect issues a get request, specifying that it is the last
request. A client can issue multiple get requests for each ChannelGet but for a
particular channelGet a new get request must not be issued until<b>getDone</b>
is called. <b>getDone</b> is called as a result of a get request.</p>

<h5>Requester methods:</h5>
<pre>        public String getRequesterName() {
            return "example";
        }

        public void message(String message, MessageType messageType) {
            if(messageType!=MessageType.info) {
                System.err.println(messageType.toString() + " " + message);
            } else {
                System.out.println(message);
            }
        }

    }
}</pre>

<p>These two methods are defined by project pvData.</p>

<h3>Starting Channel Access</h3>

<p>Before using channel access, the appropriate support must be started. Each
support is started by calling the start method of a factory that starts the
support. For example the client side of network based channel access is started
by calling:</p>
<pre>    org.epics.pvaccess.ClientFactory.start();</pre>

<p>Package org.epics.pvaccess provides the following factories:</p>
<dl>
  <dt>ClientFactory</dt>
    <dd>This starts the client side of the network support for pvAccess. This
      is the only support that needs to be started by a stand-alone client. The
      example shown in the previous section calls this.</dd>
  <dt>LocalFactory</dt>
    <dd>This is called for accessing a local PVDatabase. It is also required by
      the ServerFactory and must be started before the server factory. An
      application that wants to use channel access to access the local database
      must start this. For example the JavaIOC starts this.</dd>
  <dt>ServerFactory</dt>
    <dd>This must be started in order to allow pvAccess clients to access the
      local PVDatabase. For example the javaIOC can start this.</dd>
</dl>

<p>The javaIOC provides factories for starting the gateway code between caV3
and pvAccess. The factories are located in package org.epics.ioc.caV3 and are
named:</p>
<dl>
  <dt>ClientFactory</dt>
    <dd>The code that allows a pvAccess client to commuinicate with an epiocs
      V3 IOC.</dd>
  <dt>ServerFactory</dt>
    <dd>The code that allows an epics V3 channel access client to access the
      local PVDatabase.</dd>
</dl>

<h3>ChannelAccess, and ChannelProvider</h3>

<p>In order to connect to a channel a client must:</p>
<ol>
  <li>Call ChannelAccessFactory to get the ChannelAccess interface.</li>
  <li>Call ChannelAccess to get a ChannelProvider.</li>
  <li>Call channelProvider to create a Channel.</li>
</ol>

<p>A client must know the channel name and the name of the channel provider.
For PVData the channel name is just a record name. This project (CAJv4)
implements the following channel providers: local and pvAccess. The javaIOC
eclipse project provides support for version 3 channel access. See it for
details. </p>

<h4>ChannelAccessFactory</h4>

<p>Class org.epics.pvaccess.client.ChannelAccessFactory has the following
public methods:</p>
<pre>public class ChannelAccessFactory {
    public static ChannelAccess getChannelAccess();
    public static void registerChannelProvider(ChannelProvider channelProvider);
}</pre>

<p>where</p>
<dl>
  <dt>getChannelAccess</dt>
    <dd>Gets the ChannelAccess interface described next.</dd>
  <dt>registerChannelProvider</dt>
    <dd>Registers a channel provider. Typical providers are local, pvAccess and
      caV3. This is called by channel providers not by user code.</dd>
</dl>

<h4>ChannelAccess</h4>
<pre>interface ChannelAccess {
    ChannelProvider getProvider(String providerName);
    String[] getProviderNames();
}</pre>

<p>where</p>
<dl>
  <dt>getProvider</dt>
    <dd>Get the provider with the specified name. A null is returned if no
      provider with that name has been registered.</dd>
  <dt>getProviderNames</dt>
    <dd>Get the names of all the registered providers.</dd>
</dl>

<h4>ChannelProvider</h4>
<pre>interface ChannelProvider {
    static final public short PRIORITY_MIN = 0;
    static final public short PRIORITY_MAX = 99;
    static final public short PRIORITY_LINKS_DB = PRIORITY_MAX;
    static final public short PRIORITY_ARCHIVE = (PRIORITY_MAX + PRIORITY_MIN) / 2;
    static final public short PRIORITY_OPI = PRIORITY_MIN;

    void destroy();
    String getProviderName();
    ChannelFind channelFind(String channelName,ChannelFindRequester channelFindRequester);
    void createChannel(String channelName, channelRequester,short priority);
}</pre>

<p>where</p>
<dl>
  <dt>destroy</dt>
    <dd>The channel provider will shutdown and remove all resources it is
    using.</dd>
  <dt>getProviderName</dt>
    <dd>Get the name of the provider.</dd>
  <dt>channelFind</dt>
    <dd>Find a channel. The details are described in this section.</dd>
  <dt>createChannel</dt>
    <dd>Create a channel. A Channel is described in the next section.</dd>
</dl>

<h4>ChannelFind</h4>

<p>A client can determine if a channel exists without creating a channel. The
client must implement a requester interface and the implentation provides an
interface that the client can use to cancel the request. The interfaces are:</p>
<pre>interface ChannelFindRequester {
    void channelFindResult(Status status,ChannelFind channelFind,boolean wasFound);
}

interface ChannelFind {
     ChannelProvider getChannelProvider();
     void cancelChannelFind();
} </pre>

<p>where</p>
<dl>
  <dt>channelFindResult</dt>
    <dd>This is called by the implementation. It may or may not get called. For
      a remote call it is normally called only if the channel is found. A local
      provider will usually call it immediately and report if it has the
      requested channel. Thus this can be called before the channelFind method
      returns.</dd>
  <dt>getChannelProvider</dt>
    <dd>Get the channel provider.</dd>
  <dt>cancelChannelFind</dt>
    <dd>Cancel the find request.</dd>
</dl>

<h3>Channel</h3>

<p>The Channel interface provides access to the services a channel access
provider implements for a channel. The principal services are: process, get,
put, putGet,array, and monitor. Each of these and some other services are
described in later sections of this package overview.</p>

<p>As described in the previous section a Channel is created via a call to the
method:</p>
<pre>    ChannelProvider.createChannel(String channelName,ChannelRequester channelRequester)</pre>

<p>The caller must implement the interface:</p>
<pre>interface ChannelRequester extends Requester {
    void channelCreated(Status status,Channel channel);
    void channelStateChange(Channel c,ConnectionState connectionState);
    void destroy(Channel c);
}</pre>

<p>where</p>
<dl>
  <dt>Requester</dt>
    <dd>This is defined in package org.epics.pvdata.pv. It has two methods:
      getRequesterName and message.</dd>
  <dt>channelCreated</dt>
    <dd>This is called when a channel has been created. The argument provides
      the channel unless status was not success.</dd>
  <dt>channelStateChange</dt>
    <dd>A channel connection state change has occured. This called the first
      time when a channel has been created and connected to a server.</dd>
  <dt>destroy</dt>
    <dd>This is called if the channel is being terminated for some reason. The
      requester will no longer be able to make requests of the channel.</dd>
</dl>

<p>The Channel interface is:</p>
<pre>interface Channel extends Requester{
    public enum ConnectionState {
         NEVER_CONNECTED, CONNECTED, DISCONNECTED, DESTROYED
    };

    ChannelProvider getProvider();
    String getRemoteAddress();
    ConnectionState getConnectionState();
    void destroy();
    String getChannelName();
    ChannelRequester getChannelRequester();
    boolean isConnected();
    AccessRights getAccessRights(PVField pvField);
    void getField(GetFieldRequester requester,String subField);
    ChannelProcess createChannelProcess(
        ChannelProcessRequester channelProcessRequester,
        PVStructure pvOption);
    ChannelGet createChannelGet(
        ChannelGetRequester channelGetRequester,
        PVStructure pvRequest);
    ChannelPut createChannelPut(
        ChannelPutRequester channelPutRequester,
        PVStructure pvRequest);
    ChannelPutGet createChannelPutGet(
        ChannelPutGetRequester channelPutGetRequester,
        PVStructure pvRequest);
    ChannelRPC createChannelRPC(
        ChannelRPCRequester channelRPCRequester,
        PVStructure pvRequest);
    ChannelArray createChannelArray(
        ChannelArrayRequester channelArrayRequester,
        PVStructure pvRequest);
    Monitor createMonitor(
        MonitorRequester MonitorRequester,
        PVStructure pvRequest);
}</pre>

<p>where</p>
<dl>
  <dt>getProvider</dt>
    <dd>Get the provider.</dd>
  <dt>getRemoteAddress</dt>
    <dd>Get the network address of the server.</dd>
  <dt>destroy</dt>
    <dd>Destroy the channel and all resources used by the channel.</dd>
  <dt>getChannelName</dt>
    <dd>The name of the channel. For cav4 this is the name if the PVRecord.</dd>
  <dt>getChannelRequester</dt>
    <dd>Get the channel requester. This is normally called by the
      implementation rather than the client.</dd>
  <dt>isConnected</dt>
    <dd>Is the channel connected?</dd>
  <dt>getAccessRights</dt>
    <dd>Get the access rights for the channel.</dd>
</dl>

<p>The remaining methods are described in later sections of this package
overview.</p>

<h3>AccessRights</h3>

<p>Access Rights are not currently implemented.</p>
<pre>enum AccessRights {
    none,
    read,
    readWrite
}</pre>

<h3>GetField</h3>

<p>MATEJ There is no way to cancel the request.</p>

<p>The method:</p>
<pre>    Channel.getField(GetFieldRequester requester,String subField);</pre>

<p>Gets the introspection interface for the specified sub field of the record
it which the channel is connected. The subField can be null, which means get
the introspection interface for the entire record, or is of the form
"name.name..." . Thus it can be a request for any field within a record. The
requester must implement the interface:</p>
<pre>interface GetFieldRequester extends Requester {
    void getDone(Status status,Field field);
}</pre>

<p>where</p>
<dl>
  <dt>getDone</dt>
    <dd>A getField request has finished. A null is returned if the request
      fails. If the request succeeds Field is the introspection interface. </dd>
</dl>

<h3>ChannelRequest</h3>

<p>Many of the interfaces described in later sections extend the following
interface.</p>
<pre>interface ChannelRequest extends Destroyable {}</pre>

<p>where Destroyable has the single method:</p>
<dl>
  <dt>destroy</dt>
    <dd>Destroy whatever the extended interface implements. It will free all
      resources it uses.</dd>
</dl>

<p>Many of the interface described in the later sections are created via a
create call that has as one of it's arguments:</p>
<pre>       PVStructure pvRequest</pre>

<p>A request structure is defined in package org.epics.ioc.pvCopy but, for
convenience part is repeated here.</p>

<h4>PVStructure pvRequest</h4>

<p>This is a PVStructure that describes the fields and options in PVRecord that
are to be accessed. The format is defined by org.epics.pvdata.pvCopy. See the
package overview for details.</p>

<h4>CreateRequestFactory.createRequest</h4>

<p>This package provides the following factory:</p>
<pre>class CreateRequestFactory {
    public static PVStructure createRequest(String request,Requester requester);
}</pre>

<p>This creates a request structure. See the package documentation for
org.epics.iov.pvCopy/package.html for a detailed description.A few examples are
repeaed here. </p>

<h4>Examples</h4>

<p>The following examples are for either a simple record or for a power supply
record. These are records that have one of the following structures:</p>
<pre>simpleRecord
    value
    alarm
    timeStamp
    display
    .. other fields like input, etc

powerSupply
    alarm
    timeStamp
    power
       value
       alarm
       .. other fields
    voltage
       value
       alarm
       .. other fields
    current
       value
       alarm
       .. other fields
    .. other fields</pre>

<h5>Simple example</h5>

<p>The following creates a request for three fields: alarm, timeStamp, and
power.value</p>
<pre>    PVStructure pvRequest = CreateRequestFactory.createRequest("alarm,timeStamp,power.value");</pre>

<p>The PVStructure holding data for the requester will have the structure:</p>
<pre> pvData
     alarm           // from record.alarm
     timeStamp       // from record.timeStamp
     value           // from record.value</pre>

<p>Note that if the actual record does not have a requested field than that
field will not be present in the structure returned to the client.</p>

<h5>Power Supply Example</h5>

<p>The following creates a request for alarm, timeStamp, power, current, and
voltage. Power, current, and voltage will each be a structure with two fields:
value and alarm.</p>
<pre>    PVStructure pvRequest = CreateRequestFactory.createRequest(
       "alarm,timeStamp"
       + ",power{power.value,power.alarm}"
       + ",current{current.value,current.alarm}"
       + ",voltage{voltage.value,voltage.alarm}");</pre>

<p>The resulting structure that appears to the client has the form:</p>
<pre>pvData
   alarm          // from record.alarm
   timeStamp      // from record.timeStamp
   power          // appears because of pvRequest
      value       // from record.power.value
      alarm       // from record.power.alarm
   current        // appears because of pvRequest
      value       // from record.current.value
      alarm       // from record.current.alar.
   voltage        // appears because of pvRequest
      value       // from record.voltage.value
      alarm       // from record.voltage.alarm</pre>

<h3>ChannelProcess</h3>

<p>A ChannelProcess is created via a call to:</p>
<pre>interface Channel extends Requester{
   ChannelProcess createChannelProcess(
       ChannelProcessRequester channelProcessRequester);
}</pre>

<p>The requester must implement the interface:</p>
<pre>interface ChannelProcessRequester extends Requester {
    void channelProcessConnect(Status status,ChannelProcess channelProcess);
    void processDone(Status status);
}</pre>

<p>where</p>
<dl>
  <dt>channelProcessConnect</dt>
    <dd>This returns the interface for requesting that a record be processed.
      Status is the result for the create request. channelProcess is null if
      status is not success.</dd>
  <dt>processDone</dt>
    <dd>This is called when a process request is done. Status is the result for
      the process request. </dd>
</dl>

<p>The following is the interface for requesting that a record be processed.</p>
<pre>interface ChannelProcess extends ChannelRequest {
    void process(boolean lastRequest);
}</pre>

<p>where</p>
<dl>
  <dt>process</dt>
    <dd>Process the record. If lastRequest is true than it is a one time
      request, i.e. it is the same as calling destroy after the process is
      complete. Another process request must not be issued until processDone is
      called.</dd>
</dl>

<h3>ChannelGet</h3>

<p>A ChannelGet is created via a call to:</p>
<pre>interface Channel extends Requester{
    ChannelGet createChannelGet(ChannelGetRequester channelGetRequester,PVStructure pvRequest);
}</pre>

<p>where</p>
<dl>
  <dt>channelGetRequester</dt>
    <dd>Described next.</dd>
  <dt>pvRequest</dt>
    <dd>This was described in a previous section. BUT for channelGet the
      request string for CreateRequestFactory.createRequest has the form:
      "record[options]field(fieldOptions)". An example of a record options is
      "process=true". The fieldOptions are as defined by pvCopy.</dd>
</dl>

<p>The requester must implement the interface.</p>
<pre>interface ChannelGetRequester extends Requester {
    void channelGetConnect(Status status,ChannelGet channelGet,PVStructure pvStructure,BitSet bitSet);
    void getDone(Status status);
}</pre>

<p>where</p>
<dl>
  <dt>channelGetConnect</dt>
    <dd>This is called if the createProcess fails or when the client request is
      connected to the server. Status provides the result of the createChannel
      request. If status is not success than the other arguments are null.
      channelGet is the interface for requesting gets. All data will be
      returned in pvStructure. bitSet shows which fields have new data. If a
      bit of bitSet is set for a structure field that means that all fields of
      the structure have new values. For example of bit 0 of bitSet is set then
      all fields of pvStructure have new data. Note that each PVField
      implements a method getFieldOffset(). this can be used with bitSet to
      determine which fields have new data values. See BitSet and PVField in
      org.epics.pvdata for details.</dd>
  <dt>getDone</dt>
    <dd>The get request is done. status provides the result of the get request.
      If successful the pvStructure and bitSet returned by the call to
      channelGetConnect contain the data.</dd>
</dl>

<p>The following is the interface for requesting data from a record.</p>
<pre>interface ChannelGet extends ChannelRequest {
    void get(boolean lastRequest);
}</pre>

<p>where</p>
<dl>
  <dt>get</dt>
    <dd>Get data. If lastRequest is true than it is a one time request, i.e. it
      is the same as calling destroy after the get is complete. Another get
      request must not be issued until getDone is called.</dd>
</dl>

<h3>ChannelPut</h3>

<p>A ChannelPut is created via a call to:</p>
<pre>interface Channel extends Requester{
    ChannelPut createChannelPut(ChannelPutRequester channelPutRequester,PVStructure pvRequest);
}</pre>

<p>where</p>
<dl>
  <dt>channelPutRequester</dt>
    <dd>Described next.</dd>
  <dt>pvRequest</dt>
    <dd>This was described in a previous section. BUT for channelPut the
      request string for CreateRequestFactory.createRequest has the form:
      "record[options]field(fieldOptions)". An example of a record options is
      "process=true". The fieldOptions are as defined by pvCopy.</dd>
</dl>

<p>The requester must implement the interface.</p>
<pre>interface ChannelPutRequester extends Requester {
    void channelPutConnect(Status status,ChannelPut channelPut,PVStructure pvStructure,BitSet bitSet);
    void putDone(Status status);
    void getDone(Status status);
}</pre>

<p>where</p>
<dl>
  <dt>channelPutConnect</dt>
    <dd>This is called if the createChannelPut fails or when the client request
      is connected to the server. Status provides the result of the
      createChannelPut request. If status is not success than the other
      arguments are null. channelPut is the interface for requesting puts and
      gets. The caller puts data into pvStructure pvStructure and sets bits in
      bitSet to shows which fields have new data before making a put request.
      If a bit of bitSet is set for a structure field that means that all
      fields of the structure have new values. For example of bit 0 of bitSet
      is set then all fields of pvStructure have new data. Note that each
      PVField implements a method getFieldOffset(). this can be used with
      bitSet to determine which fields have new data values. See BitSet and
      PVField in org.epics.pvdata for details.</dd>
  <dt>putDone</dt>
    <dd>The put request is done. status provides the result of the put request.
    </dd>
  <dt>getDone</dt>
    <dd>The get request is done. status provides the result of the put request.
    </dd>
</dl>

<p>The following is the interface for requesting data from a record.</p>
<pre>interface ChannelPut extends ChannelRequest {
    void put(boolean lastRequest);
    void get();
}</pre>

<p>where</p>
<dl>
  <dt>put</dt>
    <dd>Put data. If lastRequest is true than it is a one time request, i.e. it
      is the same as calling destroy after the put is complete.</dd>
  <dt>get</dt>
    <dd>Get the current data from the record. The record is never processed.
      The request just gets the current values which is put into the
      pvStructure returned in the call to channelPutConnect.</dd>
  <dt>NOTE: Only one of put and get can be outstanding at the same time.
  Another get or put must not be issued until getDone or putDone is called.</dt>
</dl>

<h3>ChannelPutGet</h3>

<p>A channelPutGet request puts data into a record, optionally processes the
record, and gets data from the record.</p>

<p>A channel putGet is created via a call to:</p>
<pre>ChannelPutGet createChannelPutGet(ChannelPutGetRequester channelPutGetRequester,PVStructure pvRequest);
}</pre>

<p>where</p>
<dl>
  <dt>channelPutGetRequester</dt>
    <dd>Described next.</dd>
  <dt>pvPutRequest</dt>
    <dd>This was described in a previous section. BUT for channelPutGet the
      request string for CreateRequestFactory.createRequest has the form:
      "record[process=true]putField(fieldOptions)getField(fieldOptions)". An
      example of a record options is "process=true". The fieldOptions are as
      defined by pvCopy.</dd>
</dl>

<p>The requester must implement the interface.</p>
<pre>interface ChannelPutGetRequester extends Requester {
    void channelPutGetConnect(Status status,ChannelPutGet channelPutGet,
            PVStructure pvPutStructure,PVStructure pvGetStructure);
    void putGetDone(Status status);
    void getPutDone(Status status);
    void getGetDone(Status status);
}</pre>

<p>where</p>
<dl>
  <dt>channelPutGetConnect</dt>
    <dd>This is called if the createChannelPutGet fails or when the client
      request is connected to the server. Status provides the result of the
      createChannelPutGet request. If status is not success than the other
      arguments are null. channelPutGet is the interface for requesting putGet,
      getPut and getGet. pvPutStructure holds the put data and pvGetStructure
      holds the get data. </dd>
  <dt>putGetDone</dt>
    <dd>The putGet request is done.</dd>
  <dt>getPutDone</dt>
    <dd>The getPut request is done.</dd>
  <dt>getGetDone</dt>
    <dd>The getGet request is done.</dd>
</dl>

<p>The following is the interface for requesting data from a record.</p>
<pre>interface ChannelPutGet extends ChannelRequest {
    void putGet(boolean lastRequest);
    void getPut();
    void getGet();
}</pre>

<p>where</p>
<dl>
  <dt>putGet</dt>
    <dd>First put the pvPutStructure data into the record. Then if process is
      true process the record. Finally get data from the record and put it into
      pvGetStructure. If lastRequest is true than it is a one time request,
      i.e. it is the same as calling destroy after the putGet is complete.</dd>
  <dt>getPut</dt>
    <dd>Get current data from the record and put it into pvPutStructure. The
      record is never processed. The request just gets the current values which
      is put into the pvPutStructure returned in the call to
      channelPutGetConnect.</dd>
  <dt>getGet</dt>
    <dd>Get current data from the record and put it into pvGetStructure. The
      record is never processed. The request just gets the current values which
      is put into the pvGetStructure returned in the call to
      channelPutGetConnect.</dd>
</dl>

<p>NOTE: Only one of putGet, getPut, or getGet can be outstanding at the same
time. Another request must not be issued until the appropriate xxxDone is
called.</p>

<h3>ChannelRPC</h3>

<p>A ChannelRPC is like a putProcessGet except that a completly different
PVStructure can be returned for each request. It is created via a call to:</p>
<pre>interface Channel extends Requester{
    ChannelRPC createChannelRPC(ChannelRPCRequester channelRPCRequester,PVStructure pvRequest);
}</pre>

<p>where</p>
<dl>
  <dt>channelRPCRequester</dt>
    <dd>Described next.</dd>
  <dt>pvRequest</dt>
    <dd>This was described in a previous section. BUT for channelRPC the
      request string for CreateRequest.createRequest has the form:
      "record[options]field(fieldOptions)". Normally no record options are
      entered. The fieldOptions are as defined by pvCopy.</dd>
</dl>

<p>The requester must implement the interface.</p>
<pre>interface ChannelRPCRequester extends Requester {
    void channelRPCConnect(Status status,ChannelRPC channelRPC);
    void requestDone(Status status,PVStructure pvResponse);
}</pre>

<p>where</p>
<dl>
  <dt>channelRPCConnect</dt>
    <dd>Status provides the result of the createChannelRPC request. If status
      is not success than the other argument is null.</dd>
  <dt>requestDone</dt>
    <dd>The request is done. status provides the result of the request. If
      successful a pvResponse is returned. </dd>
</dl>

<p>The following is the interface for requesting data from a record.</p>
<pre>interface ChannelRPC extends ChannelRequest {
    void request(PVStructure pvArgument,boolean lastRequest);
}</pre>

<p>where</p>
<dl>
  <dt>request</dt>
    <dd>pvArgument is the structure that is sent to the server. If lastRequest
      is true than it is a one time request, i.e. Send it is the same as
      calling destroy after the request is complete.</dd>
</dl>

<p>Only one request at a time can outstanding.</p>

<h3>ChannelArray</h3>

<p>ChannelArray provides the ability to read or write a sub-array of an array
field in a record. Note that all the other transfer methods can also read or
write arrays but always transfer entire arrays. ChannelArray provides the
ability to transfer a subarray. A ChannelArray is created via a call to:</p>
<pre>interface Channel extends Requester{
    ChannelArray createChannelArray(
        ChannelArrayRequester channelArrayRequester,
        PVStructure pvRequest);
}</pre>

<p>where</p>
<dl>
  <dt>channelArrayRequester</dt>
    <dd>Described next.</dd>
  <dt>pvRequest</dt>
    <dd>This must be a PVStructure created as follows: 
      <pre>PVStructure pvRequest = pvDataCreate.createPVStructure(null, "", new Field[0]);
PVString pvFieldName = (PVString)pvDataCreate.createPVScalar(pvRequest, "field", ScalarType.pvString);
pvFieldName.put(subField);
pvRequest.appendPVField(pvFieldName);</pre>
    </dd>
</dl>

<p>The requester must implement the interface.</p>
<pre>interface ChannelArrayRequester extends Requester {
    void channelArrayConnect(Status status,ChannelArray channelArray,PVArray pvArray);
    void putArrayDone(Status status);
    void getArrayDone(Status status);
}</pre>

<p>where</p>
<dl>
  <dt>channelArrayConnect</dt>
    <dd>This is called if the createChannelArray fails or when the client
      request is connected to the server. Status provides the result of the
      createChannelArray request. If status is not success than the other
      arguments are null. channelArray is the interface for requesting puts and
      gets. pvArray holds the data to put or get.</dd>
  <dt>putArrayDone</dt>
    <dd>The put request is done.</dd>
  <dt>getArrayDone</dt>
    <dd>The get request is done.</dd>
</dl>

<p>The following is the interface for getting or putting array data from a
record.</p>
<pre>interface ChannelArray extends ChannelRequest{
    void putArray(boolean lastRequest, int offset, int count);
    void getArray(boolean lastRequest, int offset, int count);
}</pre>

<p>where</p>
<dl>
  <dt>putArray</dt>
    <dd>Put array data. The offset is the offset in the server and the count is
      the total number of elements to write. If lastRequest is true than it is
      a one time request, i.e. it is the same as calling destroy after the put
      is complete.</dd>
  <dt>getArray</dt>
    <dd>Get array data. The offset is the offset in the server and the count is
      the total number of elements to read. If lastRequest is true than it is a
      one time request, i.e. it is the same as calling destroy after the get is
      complete.</dd>
</dl>

<h3>Monitor</h3>

<p>Monitor provides the abiliy to set monitors on data in a PVRecord. What
triggers a monitor depends on the monitor support in the server. The standard
server provides support for the following: onPut, onChange, onAbsoluteChange,
and onPercentChange.</p>

<p>A Monitor is created via a call to:</p>
<pre>    void createMonitor(
        MonitorRequester monitorRequester,
        PVStructure pvRequest);
}</pre>

<p>where</p>
<dl>
  <dt>monitorRequester</dt>
    <dd>Described next.</dd>
  <dt>pvRequest</dt>
    <dd>This is defined by pvCopy and pvMonitor. See their package overviews
      for details (org.epics.pvdata.pvCopy and org.epics.pvdata.pvMonitor). The
      format of the request for CreateRequest.createRequest has the form
      "record[options]field(fieldOptions)". Note that you can specify monitor
      options for individual fields. See the package overview for pvMonitor for
      details.</dd>
</dl>

<p>The requester must implement the interface.</p>
<pre>interface MonitorRequester extends Requester{
    void monitorConnect(Monitor monitor);
    void monitorEvent((Monitor monitor);
    void unlisten();
}</pre>

<p>where</p>
<dl>
  <dt>monitorConnect</dt>
    <dd>This is called if the createMonitor fails or when the client request is
      connected to the server. Status provides the result of the createMonitor
      request. If status is not success than the other arguments are null.
      monitor is the interface for the Monitor</dd>
  <dt>monitorEvent</dt>
    <dd>monitorEvent is called when a monitor occurs. The client must call
      monitor.poll to get data for the monitor. See below. </dd>
  <dt>unlisten</dt>
    <dd>The server has issued an unlisten request.</dd>
</dl>

<p>The following is the Monitor interface which is defined in project pvData</p>
<pre>interface Monitor extends Destroyable {
    void start();
    void stop();
    MonitorElement poll();
    void release(MonitorElement monitorElement);
}</pre>

<p>where</p>
<dl>
  <dt>start</dt>
    <dd>Start monitoring</dd>
  <dt>stop</dt>
    <dd>Stop monitoring</dd>
  <dt>poll</dt>
    <dd>Poll for monitor event. Null is returned when no more events are
      available. The client must call this method in order to get monitor
    data.</dd>
  <dt>release</dt>
    <dd>When the client has processed the monitor event returned by poll the
      client must call release before again calling poll.</dd>
</dl>

<p>A monitorElement is defined as:</p>
<pre>interface MonitorElement {
    PVStructure getPVStructure();
    BitSet getChangedBitSet();
    BitSet getOverrunBitSet();
}</pre>

<p>where</p>
<dl>
  <dt>getPVStructure</dt>
    <dd>The data structure.</dd>
  <dt>getChangedBitSet</dt>
    <dd>A bitset which has a bit set for each field of the data structure which
      has changed since the last monitor.</dd>
  <dt>getOverrunBitSet</dt>
    <dd>A bitset which has a bit set for each field of the data structure which
      has changed more than once since the last monitor.</dd>
</dl>

<h2>Package org.epics.pvaccess.server</h2>

<h3>Overview</h3>

<p>This package defines the server interfaces for pvAccess, which is the
version of channel access that fully supports structured data as defined by
PVData. This package describes: </p>
<dl>
  <dt>Channel Processor</dt>
    <dd>An application that uses the pvAccess server to make a local PVDatabase
      available to the network can implement support for processing records,
      i.e. implement support for the process option of the various
      Channel.createChannelXXX methods. For example the javaIOC imnplements
      this by interfacing pvAccess to the RecordProcess facility implemented by
      the javaIOC.</dd>
  <dt>Channel Server</dt>
    <dd>The ChannelServer interface is described.</dd>
  <dt>Server Context</dt>
    <dd>The ServerContext implemented by pvAccess is described.</dd>
</dl>

<h3>Channel Processor</h3>

<p>Three interfaces are involved with support for a client asking that a record
be processed. ChannelProcessor and ChannelProcessorProvider are implemented by
the application, e. g. the javaIOC. ChannelProcessorRequester is implemented bu
pvAccess.</p>

<p>ChannelProcessor, which is attached to a specific PVRecord, is defined
as:</p>
<pre>interface ChannelProcessor {
    void detach();
    void requestProcess();
    void process(boolean leaveActive,TimeStamp timeStamp);
    void setInactive();
}</pre>

<p>where</p>
<dl>
  <dt>detach</dt>
    <dd>End of being a channel processor.</dd>
  <dt>requestProcess</dt>
    <dd>Request to process. ChannelProcessorRequester.becomeProcessor is called
      when the requester can call setActive and/or process.</dd>
  <dt>setActive</dt>
    <dd>Set the record active. This is called if the requester wants to put to
      the record before the record starts processing. If this is successful
      than the requester must call process after the put is complete.</dd>
  <dt>process</dt>
    <dd><p>Process the record. A value of false means that the request failed.
      If leaveActive is true the record is left active after process is
      complete. This allows the caller to read data from the record before the
      record is released.The caller must call setInactive after the caller is
      done reading data.</p>
    </dd>
  <dt>setInactive</dt>
    <dd>Called if leaveActive was true.</dd>
</dl>

<p>ChannelProcessorPrivider is defined as:</p>
<pre>interface ChannelProcessorProvider {
    ChannelProcessor requestChannelProcessor(PVRecord pvRecord,
         ChannelProcessorRequester channelProcessorRequester);
}</pre>

<p>where</p>
<dl>
  <dt>requestChannelProcessor</dt>
    <dd>Request to become record processor. A null is returned if the caller
      could not become the record processor.</dd>
</dl>

<p>ChannelProcessorRequester is defined as:</p>
<pre>interface ChannelProcessorRequester extends Requester{
    void becomeProcessor();
    void canNotProcess(String reason);
    void recordProcessResult(Status status);
    void recordProcessComplete();
    void lostRightToProcess();
}</pre>

<p>where</p>
<dl>
  <dt>becomeProcessor</dt>
    <dd>Called as a result of a call to requestProcess.</dd>
  <dt>canNotProcess</dt>
    <dd>A request was made to become processor but record can not be
    processed.</dd>
  <dt>recordProcessResult</dt>
    <dd>Called to report result of record processing. This is called before the
      record is unlocked.</dd>
  <dt>recordProcessComplete</dt>
    <dd>Called when all processing is complete and record is unlocked.</dd>
  <dt>lostRightToProcess</dt>
    <dd>The process requester has lost the right to request processing.</dd>
</dl>

<h3>Channel Server</h3>

<p>This is an interface implemented by local server:</p>
<pre>interface ChannelServer extends ChannelProvider{
    void registerMonitor(MonitorCreate monitorCreate);
    boolean registerChannelProcessProvider(
        ChannelProcessorProvider channelProcessProvider);
}</pre>

<p>where</p>
<dl>
  <dt>registerMonitor</dt>
    <dd>register a monitor algorithm.</dd>
  <dt>registerChannelProcessProvider </dt>
    <dd>Register the ChannelProcessProvider.</dd>
</dl>

<h3>Server Context</h3>

<p>This is an interface implemented by pvAccess server:</p>
<pre>interface ServerContext {
    Version getVersion();
    void initialize(ChannelAccess channelAccess) throws CAException, IllegalStateException;
    void run(int seconds) throws CAException, IllegalStateException;
    void shutdown() throws CAException, IllegalStateException;
    void destroy() throws CAException, IllegalStateException;
    void printInfo();
    void printInfo(PrintStream out);
    void dispose();
    void setBeaconServerStatusProvider(BeaconServerStatusProvider beaconServerStatusProvider);
}</pre>

<p>where</p>
<dl>
  <dt>getVersion</dt>
    <dd>x</dd>
  <dt>initialize</dt>
    <dd>x</dd>
  <dt>run</dt>
    <dd>x</dd>
  <dt>shutdown</dt>
    <dd>x</dd>
  <dt>destroy</dt>
    <dd>x</dd>
  <dt>printInfo</dt>
    <dd>x</dd>
  <dt>dispose</dt>
    <dd>x</dd>
  <dt>setBeaconServerStatusProvider</dt>
    <dd>x</dd>
</dl>
</div>
</body>
</html>
