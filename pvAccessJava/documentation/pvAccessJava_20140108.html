<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
      "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="content-type" content="text/html; charset=iso-8859-1" />
  <title>EPICS pvAccessJava</title>
  <link rel="stylesheet" type="text/css"
  href="http://epics-pvdata.sourceforge.net/base.css" />
  <link rel="stylesheet" type="text/css"
  href="http://epics-pvdata.sourceforge.net/epicsv4.css" />
  <style type="text/css">
  /*<![CDATA[*/
     .about { margin-left: 3em; margin-right: 3em; font-size: .83em}
     table { margin-left: auto; margin-right: auto }
     .diagram { text-align: center; margin: 2.5em 0 }
     span.opt { color: grey }
     span.nterm { font-style:italic }
     span.term { font-family:courier }
     span.user { font-family:courier }
     span.user:before { content:"<" }
     span.user:after { content:">" }
     .nonnorm { font-style:italic }
     p.ed { color: #AA0000 }
     span.ed { color: #AA0000 }
     p.ed.priv { display: inline; }
     span.ed.priv { display: inline; }
  /*]]>*/</style>
  <!-- Script that generates the Table of Contents -->
  <script type="text/javascript"
  src="http://epics-pvdata.sourceforge.net/script/tocgen.js">
 </script>
</head>

<body>

<div class="head">
<h1>EPICS pvAccessJava</h1>
<!-- Maturity: Working Draft or Request for Comments, or Recommendation, and date. -->

<h2 class="nocount">EPICS v4 Working Group, Working Draft, 08-Jan-2014</h2>
<dl>
  <dt>This version:</dt>
    <dd><a
      href="pvAccessJava.html">pvAccessJava.html</a></dd>
  <dt>Latest version:</dt>
    <dd><a
      href="pvAccessJava_20140108.html">pvAccessJava_20140108.html
      </a></dd>
  <dt>Previous version:</dt>
    <dd><a
      href="pvAccessJava_20120905.html">pvAccessJava_20120905.html
      </a></dd>
  <dt>Editors:</dt>
    <dd>Marty Kraimer, BNL<br />
      Matej Sekoranja, CosyLab</dd>
</dl>
</div>

<h2 class="nocount">Abstract</h2>

<p>pvAccessJava is the Java implementation of pvAccess, which is one of a
related set of products:<br />
<a href="http://epics-pvdata.sourceforge.net/relatedDocumentsV4.html">relatedDocumentsV4.html</a>
</p>


<h2 class="nocount">Status of this Document</h2>

<p>This is the 08-Jan-2014 version of the Java implementation of pvAccess. It
is a complete implementation of pvAccess as currently defined. </p>

  <dt>Editors:</dt>
    <dd>Marty Kraimer, BNL<br />
      Matej Sekoranja, CosyLab</dd>
</dl>
</div>

<h2 class="nocount">Abstract</h2>

<p>pvAccessJava is the Java implementation of pvAccess, which is one of a
related set of products:<br />
<a href="http://epics-pvdata.sourceforge.net/relatedDocumentsV4.html">relatedDocumentsV4.html</a>
</p>


<h2 class="nocount">Status of this Document</h2>

<p>This is the 08-Jan-2014 version of the Java implementation of pvAccess. It
is a complete implementation of pvAccess as currently defined. </p>

<h2 class="nocount">TODO</h2>

<p>The following is a list of unresolved issues for pvAccessJava:</p>
<dl>
  <dt>(none)</dt>
    <dd>(none)</dd>
</dl>

<div id="toc">
<h2 class="nocount" style="page-break-before: always">Table of Contents</h2>
</div>

<div id="contents" class="contents">
<h2>Introduction</h2>

<p>This product is available via an <a
href="http://epics-pvdata.sourceforge.net/LICENSE.html">open source
license</a></p>

<p>This document is the project and package overviews for pvAccessJava. The
javaDOC is available at <a href="./html/index.html">JavaDoc</a></p>

<p>The javaDOC package overview documents for this project are not complete but
the packages of interest to people writing client code or connecting an
application that wants to start a pvAccess server is complete. What remains is
to fully document the implementation. This project overview gives a brief
description of the packages provided by this project.</p>

<p>This project implements pvAccess, which is an implementation of Channel
Access that fully supports pvData. Package <b>org.epics.pvaccess.client</b> is
of interest to anyone who wants to write client code for pvAccess and is also
of interest to anyone who wants to write a server that interfaces to other
system. The other packages are mainly of interest to those who want to
understand the internals of the implementation.</p>

<p>If your interest is only to write client code go directly to
<b>org.epics.pvaccess.client</b></p>

<p>This project provides the client and server networking spport for the
interfaces defined in <b>org.epics.pvaccess.client</b>. The pvIOCJava provides
a local implementation of pvAccess API, which registers itself with the server
support provided by this project. Other implementations can also be
provided.</p>

<p>This package also allows the following:</p>
<ol>
  <li>An application can be created that provide a pvAccess server that
    provides full support for pvData.This is done by starting a local
    PVDatabase, calling org.epics.pvaccess.LocalFactory.start(), and calling
    org.epics.pvaccess.ServerFactory.start().</li>
  <li>An extensible set of monitoring algorithms is supported. Monitoring is
    defined by project pvData. pvAccess provides access to this facility. A
    default set of monitoring algorithms is provided by pvData but other
    algorithms can be implemented. The code that implements an algorithm must
    extend org.epics.pvdata.monitor.AbstractMonitor and register with
    org.epics.pvaccess.server.ChannelServer.</li>
  <li>A gateway between pvAccess and other systems can be implemented. For
    example projects pvAccessJava and pvIOCJava provide gateway code between
    caV3 and pvAccess. pvAccessJava (see package <b>org.epics.caV3</b>) allows
    pvAccess client to talk to a caV3 server, pvIOCJava (see package
    <b>org.epics.pvioc.caV3</b>) allows caV3 client to talk to a pvAccess
    server.</li>
</ol>

<h2>User Interface Packages</h2>

<p>This section briefly describes the interfaces used by a pvAccess client and
by an application that supports a pvAccess server. It only describes how things
are connected, i.e. it does not describe pvAccess API or any of its related
interfaces because they are described in the package overview for
org.epics.pvaccess.client.</p>

<h3>org.epics.pvaccess</h3>

<p>This package provides the factories that start the various components of
pvAccess:</p>
<dl>
  <dt>ClientFactory</dt>
    <dd>This starts the client side of the network support for pvAccess. This
      is the only support that needs to be started by a stand-alone client. The
      example shown in the previous section calls this.</dd>
  <dt>ServerFactory</dt>
    <dd>This must be started in order to allow pvAccess clients to access the
      local pvAccess data source. For example the pvIOCJava (PVDatabase) can
      start this.</dd>
</dl>

<h3>org.epics.pvaccess.client</h3>

<p>This package provides everything required for a pvAccess client. See the
package overview for details. This section only describes how to connect to a
channel and how to register monitor algoritms and channel providers.</p>

<p>To connect to a channel a client does the following:</p>
<pre>    // define the following
    private static final ChannelAccess channelAccess
         = ChannelAccessFactory.getChannelAccess();

    // get wanted channel provider
    ChannelProvider channelProvider = channelAccess.getProvider("pva");

    // connect to a channel with given name
    Channel channel = channelProvider.createChannel(
                                         "someChannel",
                                         channelRequester,
                                         ChannelProvider.PRIORITY_DEFAULT);</pre>

<p>This package defines the interfaces a client uses to comnmunicate with a
pvAccess server. This project fully implements all the interfaces. If a server
is implemented for other systems, it is OK to implement a subset of the
interfaces. For example the caV3 server implemented by the pvIOCJava does not
support ChannelPutGet because an EPICS V3 IOC does not provide an equivalent
facility.</p>

<p>Except for ChannelAccessFactory and CreateRequest, this package
contains only Java interface and enum definition.
See ChannelRequest below for more detail about CreateRequest.
</p>
<p>ChannelAccessFactory provides
a complete implementation of interface ChannelAccess and three static public
members:</p>
<pre>public class ChannelAccessFactory {
    public static ChannelAccess getChannelAccess();
    public static void registerChannelProvider(ChannelProvider channelProvider);
    public static void unregisterChannelProvider(ChannelProvider channelProvider);
}</pre>

<p>where</p>
<dl>
  <dt>getChannelAccess</dt>
    <dd>This gets the single instance of ChannelAccess</dd>
  <dt>registerChannelProvider</dt>
    <dd>This registers a ChannelProvider. Usually user code does not call this,
      e.g. it is called via the factories in <b>org.epics.pvaccess</b></dd>
  <dt>unregisterChannelProvider</dt>
    <dd>This unregisters a ChannelProvider. Usually user code does not call
      this, e.g. it is called via the factories in
    <b>org.epics.pvaccess</b></dd>
</dl>

<p>ChannelAccess is defined as:</p>
<pre>interface ChannelAccess {
    ChannelProvider getProvider(String providerName);
    String[] getProviderNames();
}</pre>

<p>where</p>
<dl>
  <dt>getProvider</dt>
    <dd>Get the channel provider.</dd>
  <dt>getProviderNames</dt>
    <dd>Get the names of all regsitered providers.</dd>
</dl>

<p>ChannelProvider has a method (among others):</p>
<pre>Channel createChannel(String channelName, ChannelRequester channelRequester, short priority);
 ...</pre>

<p>This is the method a client calls to connect to a Channel. See the package
overview for details.</p>

<h2>Problems and Future Plans</h2>

<h3>Access Security</h3>

<p>Something like how csV3 implements access security is required. A
complication is that for caV3 a client attaches to a single scalar or array
field. For pvAccess a client attaches to an arbirary set of fields in a record.
Takes some thought to decide what to do.</p>

<h3>User Controlled Send Queues</h3>

<p>Currently a user can only ask to send a message immediately, i. e. a client
has no control over when a message is sent. This can result in many short
network packets. Perhaps the following should be provided: Allow a client, for
each send request, to specify the following options:</p>
<dl>
  <dt>immediate</dt>
    <dd>Immediately queue a request to the send thread.</dd>
  <dt>periodically</dt>
    <dd>Put requests on a periodic send queue. At some periodic rate the queue
      is transfered to the send thread.</dd>
  <dt>user queue</dt>
    <dd>Client keeps a private queue for requests. The client decides when the
      queue should be transfered to the send thread.</dd>
</dl>

<h2>Helper Packages</h2>

<p>This is set of packages that are used by other parts of this project</p>

<h3>org.epics.pvaccess</h3>

<p>This has the following:</p>
<dl>
  <dt>ClientFactory</dt>
    <dd>Starts the client side of remote pvAccess.</dd>
  <dt>ServerFactory</dt>
    <dd>Starts the server side of remote pvAccess.</dd>
  <dt>CAConstants</dt>
    <dd>A set of constants for pvAccess</dd>
  <dt>CAException</dt>
    <dd>An extension to Exception for pvAccess</dd>
  <dt>Version</dt>
    <dd>Defines the version.</dd>
  <dt>PVFactory</dt>
    <dd>Factory proxy for all the standard pvData factories used by
    pvAccess.</dd>
</dl>

<h3>org.epics.pvaccess.util.logging</h3>

<p>A logging facility based on java.util.logging. This has the following:</p>
<dl>
  <dt>LoggerProvider</dt>
    <dd>Defines an interface that provides a logger.</dd>
  <dt>LoggingUtils</dt>
    <dd>Contains various logging helper methods, e.g. mapping from pvData
      MessageType to Java Logging API Level.</dd>
  <dt>ConsoleLogFormatter</dt>
    <dd>Java API formatter that produces single line log reports meant to go to
      the console.</dd>
  <dt>ConsoleLogHandler</dt>
    <dd>Java API log handler output logs to the System.out. By default it uses
      ConsoleLogFormatter.</dd>
</dl>

<p>To setup a simple logging in you console application, use the following
code:</p>
<pre>        ConsoleLogHandler.defaultConsoleLogging(Level.INFO);
        Logger logger = Logger.getLogger(MyApplicationClass.class.getName());

        ...
        logger.info("Hello world.");</pre>

<h2>Implementation Packages</h2>

<p>These packages provide implementation classes and interfaces shared by both
the client and server code for pvAccess</p>

<h3>org.epics.pvaccess.util</h3>

<p>This has the following:</p>
<dl>
  <dt>CircularBuffer</dt>
    <dd>A fixed size circular buffer. If full a new element replaces the
    oldest.</dd>
  <dt>GrowingCircularBuffer</dt>
    <dd>A circular buffer that holds an unlimited number of elements.</dd>
  <dt>HexDump</dt>
    <dd>Converts a byte array to hex and writes to System.out.println.</dd>
  <dt>InetAddressUtil</dt>
    <dd>Convience methods for INET address conversion.</dd>
  <dt>IntHashMap</dt>
    <dd>An integer hash map. This is used instead of java.util.HashMap so that
      Integer objects do not have to be allocated.</dd>
  <dt>Mailbox</dt>
    <dd>Optimized usage of concurrent linked list queue.</dd>
  <dt>ShortHashMap</dt>
    <dd>A short hash map. This is used instead of java.util.HashMap so that
      Short objects do not have to be allocated.</dd>
</dl>

<h3>org.epics.pvaccess.util.sync</h3>

<p>This package contains thread synchronization utility classes, e.g. named
lock pattern implementation (lock guarding a named instance).</p>

<h3>org.epics.pvaccess.util.configuration</h3>

<p>This package defines interfaces for configuration framework used by
pvAccess.</p>

<h3>org.epics.pvaccess.util.configuration.impl</h3>

<p>This package implements default configuration method for pvAccess.</p>

<h3>org.epics.pvaccess.impl.remote</h3>

<p>This package contains enums, interface, and abstract class definitions
common to both the client and server implementation. </p>

<h3>org.epics.pvaccess.impl.remote.codec</h3>

<p>This package implement pvAccess protocol (codec) in a way that can be
plugged into the blocking or non-blocking IO system.</p>

<h3>org.epics.pvaccess.impl.remote.codec.impl</h3>

<p>This package partly implements codec to be used by blocking or non-blocking
IO system.</p>

<h3>org.epics.pvaccess.impl.remote.io</h3>

<p>This package currently provides interfaces of a non-blocking IO system.</p>

<h3>org.epics.pvaccess.impl.remote.io.impl</h3>

<p>This package contains an implementation of non-blocking IO system using
Selector.</p>

<h3>org.epics.pvaccess.impl.remote.request</h3>

<p>This pakcage contains interfaces pvAccess uses to handle requests.</p>

<h3>org.epics.pvaccess.impl.remote.tcp</h3>

<p>This package contains the code that implements pvAccess codec over TCP
transport.</p>

<h3>org.epics.pvaccess.impl.remote.udp</h3>

<p>his package contains the code that implements pvAccess codec over UDP
transport.</p>

<h3>org.epics.pvaccess.impl.remote.utils</h3>

<p>Some network utility support.</p>

<h2>Client Implementation Packages</h2>

<p>These packages provide the implementation classes and interfaces for the
client code for pvAccess.</p>

<h3>org.epics.pvaccess.client.impl.remote</h3>

<p>This implements the client side pvAccess API of passing the various
ChannelXXX requests over the network, where XXX is Get, Put, PutGet, etc. This
code uses the code in the following two packages to send requests and receive
responses.</p>

<h3>org.epics.pvaccess.client.impl.remote.handlers</h3>

<p>This implements handlers for receiving responses from network requests.</p>

<h3>org.epics.pvaccess.client.impl.remote.requests</h3>

<p>This implements code that sends a network request.</p>

<h3>org.epics.pvaccess.client.impl.remote.search</h3>

<p>This implement pvAccess discovery mechanism over UDP.</p>

<h3>org.epics.pvaccess.client.impl.remote.tcp</h3>

<p>This interfaces the client code to package
org.epics.pvaccess.impl.remote.tcp.</p>

<h2>Server Implementation Packages</h2>

<p>These packages provide the implementation classes and interfaces for the
server code for pvAccess.</p>

<h3>org.epics.pvaccess.server.impl.remote</h3>

<p>This implements the server side pvAccess API of passing the various
ChannelXXX requests over the network, where XXX is Get, Put, PutGet, etc. This
code uses the code in the following two packages to send requests and receive
responses. It also has the code which issues beacons.</p>

<h3>org.epics.pvaccess.server.impl.remote.handlers</h3>

<p>This implements handlers for receiving requests from the client.</p>

<h3>org.epics.pvaccess.server.impl.remote.plugins</h3>

<p>Currently has just code related to beacons. User can attach its own data to
the beacon messages (e.g. to report IOC status).</p>

<h3>org.epics.pvaccess.server.impl.remote.tcp</h3>

<p>This interfaces the server code to package
org.epics.pvaccess.impl.remote.tcp.</p>

<h3>org.epics.pvaccess.server.impl.rpc</h3>

<p>This package contains interfaces to implement a service based on pvAccess
RPC mechanism.</p>

<h3>org.epics.pvaccess.server.impl.rpc.impl</h3>

<p>This package is the implementation of the org.epics.pvaccess.server.impl.rpc
package.</p>

<h2>Package org.epics.pvaccess</h2>

<h3>Overview</h3>

<p>This package provides:</p>
<dl>
  <dt>Factories</dt>
    <dd>Factories are available to start pvAccess channel access. This includes
      local channel access and the client and server for remote pvAccess.</dd>
  <dt>CAConstants</dt>
    <dd>A set of constants used by the pvAccess implementation.</dd>
  <dt>CAException</dt>
    <dd>A extension of Exception for pvAccess.</dd>
  <dt>Version</dt>
    <dd>Administrative class to keep track of the version number.</dd>
</dl>

<h3>Factories</h3>

<p>Each factory has a single public method:</p>
<pre>    public static synchronized void start();</pre>

<p>For example the pvAccess client can be started by calling:</p>
<pre>    org.epics.pvaccess.ClientFactory.start();</pre>

<p>The following factories are available:</p>
<dl>
  <dt>ClientFactory</dt>
    <dd>This starts the client side pvAccess API of the network support for
      pvAccess. This is the only support that needs to be started by a
      stand-alone client.</dd>
  <dt>ServerFactory</dt>
    <dd>This starts the server side pvAccess API of the network support for
      pvAccess. For example the pvIOCJava can start this.</dd>
</dl>

<h3>CAConstants</h3>

<p>This defines a number of constants used by the implementation. It is not of
interest to users. Look at the source for details.</p>

<h3>CAException</h3>

<p>This is a simple extension of the Java Exception class. It is defined so
that channel access specific exceptions can be thrown.</p>

<h3>Version</h3>

<p>This is an administrative class to keep track of the version number. See the
code for details.</p>

<h2>Package org.epics.pvaccess.client</h2>

<h3>Overview</h3>

<p>This package defines the client interfaces for pvAccess, which is a version
of channel access that fully supports structured data as defined by PVData. It
is assumed that the reader understands PVData, which is implemented by the
eclipse project "org.epics.pvdata". </p>

<p>A Channel provides a communication path beween a client and a PVRecord. A
channel access server, which must reside in the same process as the PVRecord,
provides access to the record. The client and server can be part of the same
process or can be in different processes on the same network node or on
different network nodes. Channel Access provides the connection between the
client and server.</p>

<p>A client creates a channel via a call to ChannelProvider.createChannel. A
ChannelProvider is located via a call to ChannelAccess.getProvider.
ChannelAccess is located via ChannelAccessFactory.</p>

<p>This overview discusses:</p>
<ul>
  <li>An example client.</li>
  <li>How to connect to a channel provider.</li>
  <li>An overview of all the client interfaces.</li>
</ul>

<p>Many of the methods described below return or have a argument Status. This
is defined in project pvData as follows:</p>
<pre>interface Status extends Serializable {
    public enum StatusType {OK,WARNING,ERROR,FATAL}
    StatusType getType();
    String getMessage();
    String getStackDump();
    boolean isOK();
    boolean isSuccess();
}</pre>

<p>Unless isSuccess is true the client must realize that the request failed.
When a failure occurs, other arguments may be null.</p>

<h3>Example</h3>

<h4>What the example does</h4>

<p>This section shows an example of issuing a channel get request. the example
is a java main program that can be executed as follows:</p>
<pre>java org.epics.pvaccess.client.example.ExampleChannelGet &lt;channelName&gt; &lt;request&gt;</pre>

<p>For example if the arguments are:</p>
<pre>    counter field(value)</pre>

<p>The output is:</p>
<pre>2012-09-11T12:48:44.831 Channel 'counter' created with status: StatusImpl [type=OK].
2012-09-11T12:48:45.631 Channel 'counter' CONNECTED.
2012-09-11T12:48:45.708 ChannelGet for 'counter' connected with status: StatusImpl [type=OK].
2012-09-11T12:48:45.710 getDone for 'counter' called with status: StatusImpl [type=OK].
structure
    int value 1
2012-09-11T12:48:45.735 Channel 'counter' DISCONNECTED.
2012-09-11T12:48:45.736 Channel 'counter' DESTROYED. </pre>

<p>If the arguments are: </p>
<pre>    counter field(value,timeStamp,alarm)</pre>

<p>The output is:</p>
<pre>2012-09-11T12:51:12.113 Channel 'counter' created with status: StatusImpl [type=OK].
2012-09-11T12:51:12.156 Channel 'counter' CONNECTED.
2012-09-11T12:51:12.163 ChannelGet for 'counter' connected with status: StatusImpl [type=OK].
2012-09-11T12:51:12.164 getDone for 'counter' called with status: StatusImpl [type=OK].
structure
    int value 4
    timeStamp_t timeStamp
        long secondsPastEpoch 1347360671
        int nanoSeconds 660000000
        int userTag 0
    alarm_t alarm
        int severity 0
        int status 0
        string message
2012-09-11T12:51:12.167 Channel 'counter' DISCONNECTED.
2012-09-11T12:51:12.168 Channel 'counter' DESTROYED.</pre>

<p>If the request is not given then the entire record is shown.</p>

<h4>Example Source</h4>

<h5>main:</h5>
<pre>public class ExampleChannelGet {

    public static void main(String[] args) throws Throwable {

    int len = args.length;
        if (len == 0 || len &gt; 2)
        {
            System.out.println("Usage: &lt;channelName&gt; &lt;pvRequest&gt;");
            return;
        }

        final String channelName = args[0];
        final String pvRequestString = args[1];

        // initialize console logging
        ConsoleLogHandler.defaultConsoleLogging(Level.INFO);
        Logger logger = Logger.getLogger(ExampleChannelGet.class.getName());
        logger.setLevel(Level.ALL);

        // setup pvAccess client
        org.epics.pvaccess.ClientFactory.start();

        // get pvAccess client provider
        ChannelProvider channelProvider = ChannelAccessFactory.getChannelAccess().getProvider(org.epics.pvaccess.ClientFactory.PROVIDER_NAME);

        //
        // create channel and channelGet
        //
        CountDownLatch doneSignal = new CountDownLatch(1);

        ChannelRequesterImpl channelRequester = new ChannelRequesterImpl(logger);
        Channel channel = channelProvider.createChannel(channelName, channelRequester, ChannelProvider.PRIORITY_DEFAULT);

        ChannelGetRequester channelGetRequester = new ChannelGetRequesterImpl(logger, channel, doneSignal);
        CreateRequest createRequest = CreateRequest.create();
        PVStructure pvRequest = createRequest.createRequest(pvRequestString);
        if(pvRequest==null) {
                String message = "createRequest failed " + createRequest.getMessage();
                logger.info(message);
        } else {
                channel.createChannelGet(channelGetRequester,pvRequest);

                // wait up-to 3 seconds for completion
                if (!doneSignal.await(3, TimeUnit.SECONDS))
                        logger.info("Failed to get value (timeout condition).");
        }
        // stop pvAccess client
        org.epics.pvaccess.ClientFactory.stop();
    }</pre>

<p>The main routine first checks for valid arguments, initializes console
logging, creates a channel and channel get and then waits for up to 3 seconds
for response. </p>

<h5>Implementation of ChannelRequester:</h5>
<pre>    static class ChannelRequesterImpl implements ChannelRequester
    {
        private final Logger logger;
        public ChannelRequesterImpl(Logger logger)
        {
            this.logger = logger;
        }

        @Override
        public String getRequesterName() {
            return getClass().getName();
        }

        @Override
        public void message(String message, MessageType messageType) {
            logger.log(LoggingUtils.toLevel(messageType), message);
        }

        @Override
        public void channelCreated(Status status, Channel channel) {
            logger.info("Channel '" + channel.getChannelName() + "' created with status: " + status + ".");
        }

        @Override
        public void channelStateChange(Channel channel, ConnectionState connectionState) {
            logger.info("Channel '" + channel.getChannelName() + "' " + connectionState + ".");
        }

    }</pre>

<p>ChannelRequester.channelCreated method gets called when channel instance is
created. ChannelRequester.channelStateChange gets called on very channel state
change. The implementation above just logs all the information. </p>

<h5>Implementation of ChannelGetRequester:</h5>
<pre>
    static class ChannelGetRequesterImpl implements ChannelGetRequester
    {
        private final Logger logger;
        private final Channel channel;
        private final CountDownLatch doneSignaler;

        private volatile PVStructure pvStructure = null;

        public ChannelGetRequesterImpl(Logger logger, Channel channel, CountDownLatch doneSignaler)
        {
            this.logger = logger;
            this.channel = channel;
            this.doneSignaler = doneSignaler;
        }

        @Override
        public String getRequesterName() {
            return getClass().getName();
        }

        @Override
        public void message(String message, MessageType messageType) {
            logger.log(LoggingUtils.toLevel(messageType), message);
        }

        @Override
        public void channelGetConnect(Status status, ChannelGet channelGet,
                                          PVStructure pvStructure, BitSet bitSet) {
            logger.info("ChannelGet for '" + channel.getChannelName() + "' connected with status: " + status + ".");
            if (status.isSuccess())
            {
                this.pvStructure = pvStructure;
                channelGet.get(true);
            }
            else
                doneSignaler.countDown();
        }

        @Override
        public void getDone(Status status) {
            logger.info("getDone for '" + channel.getChannelName() + "' called with status: " + status + ".");

            if (status.isSuccess())
            {
                // NOTE: no need to call channelGet.lock()/unlock() since we read pvStructure in the same thread (i.e. in the callback)
                System.out.println(pvStructure.toString());
            }

            doneSignaler.countDown();
        }
    }</pre>

<p>ChannelGetRequester.channelGetConnect gets called when ChannelGet request is
created on server side. Client must always check status for errors. In case of
success, pvStructure is not null and it holds a reference to the data structure
(container) where values will be stored on actual get request. The
implementation above issues actual get request on success by calling
"channelGet.get(true)". The "true" parameter indicates to self-destroy this
request after get is done. If more than one get operation needs to be done, a
programmer should call "channel.get(false)" as many time as needed and so reuse
resources related to a get request (moreover this allows pvAccess to optimize
network utilization and transfer only values that has changed since the last
get request). User can always destroy a request by calling
"channelGet.destroy()".<br />
ChannelGetRequester.getDone gets called on get operation completion. On success
indicated by status parameter, pvStructure holds the latest data.</p>

<h3>Starting Channel Access</h3>

<p>Before using channel access, the appropriate support must be started. Each
support is started by calling the start method of a factory that starts the
support. For example the client side of network based channel access is started
by calling:</p>
<pre>    org.epics.pvaccess.ClientFactory.start();</pre>

<p>Package org.epics.pvaccess provides the following factories:</p>
<dl>
  <dt>ClientFactory</dt>
    <dd>This starts the client side pvAccess API of the network support for
      pvAccess. This is the only support that needs to be started by a
      stand-alone client. The example shown in the previous section calls
    this.</dd>
  <dt>ServerFactory</dt>
    <dd>This starts the server side pvAccess API of the network support for
      pvAccess. For example the pvIOCJava can start this.</dd>
</dl>

<h3>ChannelAccess, and ChannelProvider</h3>

<p>In order to connect to a channel a client must:</p>
<ol>
  <li>Call ChannelAccessFactory.getChannelAccess() to get the ChannelAccess
    interface.</li>
  <li>Call ChannelAccess.getProvider(String providerName) to get a
    ChannelProvider.</li>
  <li>Call ChannelProvider.createChannel(String channelName, ...) to create a
    Channel.</li>
</ol>

<p>A client must know the channel name and the name of the channel provider.</p>

<h4>ChannelAccessFactory</h4>

<p>Class org.epics.pvaccess.client.ChannelAccessFactory has the following
public methods:</p>
<pre>public class ChannelAccessFactory {
    public static ChannelAccess getChannelAccess();
    public static void registerChannelProvider(ChannelProvider channelProvider);
    public static void unregisterChannelProvider(ChannelProvider channelProvider);
}</pre>

<p>where</p>
<dl>
</dl>
<dl>
  <dt>getChannelAccess</dt>
    <dd>This gets the single instance of ChannelAccess</dd>
  <dt>registerChannelProvider</dt>
    <dd>This registers a ChannelProvider. Usually user code does not call this,
      e.g. it is called via the factories in <b>org.epics.pvaccess</b></dd>
  <dt>unregisterChannelProvider</dt>
    <dd>This unregisters a ChannelProvider. Usually user code does not call
      this, e.g. it is called via the factories in
    <b>org.epics.pvaccess</b></dd>
</dl>

<h4>ChannelAccess</h4>
<pre>interface ChannelAccess {
    ChannelProvider getProvider(String providerName);
    String[] getProviderNames();
}</pre>

<p>where</p>
<dl>
  <dt>getProvider</dt>
    <dd>Get the provider with the specified name. A null is returned if no
      provider with that name has been registered.</dd>
  <dt>getProviderNames</dt>
    <dd>Get the names of all the registered providers.</dd>
</dl>

<h4>ChannelProvider</h4>
<pre>interface ChannelProvider {
    static final public short PRIORITY_MIN = 0;
    static final public short PRIORITY_MAX = 99;
    static final public short PRIORITY_LINKS_DB = PRIORITY_MAX;
    static final public short PRIORITY_ARCHIVE = (PRIORITY_MAX + PRIORITY_MIN) / 2;
    static final public short PRIORITY_OPI = PRIORITY_MIN;

    void destroy();
    String getProviderName();
    ChannelFind channelFind(String channelName, ChannelFindRequester channelFindRequester);
    Channel createChannel(String channelName, ChannelRequester, short priority);
    Channel createChannel(String channelName, ChannelRequester channelRequester, short priority, String address);
}</pre>

<p>where</p>
<dl>
  <dt>destroy</dt>
    <dd>The channel provider will shutdown and remove all resources it is
    using.</dd>
  <dt>getProviderName</dt>
    <dd>Get the name of the provider.</dd>
  <dt>channelFind</dt>
    <dd>Find a channel. The details are described in this section.</dd>
  <dt>createChannel</dt>
    <dd>Create a channel. A Channel is described in the next section.</dd>
</dl>

<h4>ChannelFind</h4>

<p>This method is to be used to by local pvAccess implementations (e.g.
pvAccess server queries pvIOCJava). A client can determine if a channel exists
without creating a channel. The client must implement a requester interface and
the implentation provides an interface that the client can use to cancel the
request. The interfaces are:</p>
<pre>interface ChannelFindRequester {
    void channelFindResult(Status status, ChannelFind channelFind, boolean wasFound);
}

interface ChannelFind {
     ChannelProvider getChannelProvider();
     void cancelChannelFind();
} </pre>

<p>where</p>
<dl>
  <dt>channelFindResult</dt>
    <dd>This is called by the implementation. It may or may not get called. For
      a remote call it is normally called only if the channel is found. A local
      provider will usually call it immediately and report if it has the
      requested channel. Thus this can be called before the channelFind method
      returns.</dd>
  <dt>getChannelProvider</dt>
    <dd>Get the channel provider.</dd>
  <dt>cancelChannelFind</dt>
    <dd>Cancel the find request.</dd>
</dl>

<h3>Channel</h3>

<p>The Channel interface provides access to the services a channel access
provider implements for a channel. The principal services are: process, get,
put, putGet, RPC, array, and monitor. Each of these and some other services are
described in later sections of this package overview.</p>

<p>As described in the previous section a Channel is created via a call to the
method:</p>
<pre>    ChannelProvider.createChannel(String channelName,ChannelRequester channelRequester)</pre>

<p>The caller must implement the interface:</p>
<pre>interface ChannelRequester extends Requester {
    void channelCreated(Status status, Channel channel);
    void channelStateChange(Channel channel, ConnectionState connectionState);
}</pre>

<p>where</p>
<dl>
  <dt>Requester</dt>
    <dd>This is defined in package org.epics.pvdata.pv. It has two methods:
      getRequesterName and message.</dd>
  <dt>channelCreated</dt>
    <dd>This is called when a channel has been created. The argument provides
      the channel unless status was not success.</dd>
  <dt>channelStateChange</dt>
    <dd>A channel connection state change has occured. This is called the first
      time when a channel has been created and connected to a server or
      destroyed.</dd>
</dl>

<p>The Channel interface is:</p>
<pre>interface Channel extends Requester{
    public enum ConnectionState {
         NEVER_CONNECTED, CONNECTED, DISCONNECTED, DESTROYED
    };

    ChannelProvider getProvider();
    String getRemoteAddress();
    ConnectionState getConnectionState();
    void destroy();
    String getChannelName();
    ChannelRequester getChannelRequester();
    boolean isConnected();
    AccessRights getAccessRights(PVField pvField);
    void getField(GetFieldRequester requester,String subField);
    ChannelProcess createChannelProcess(
        ChannelProcessRequester channelProcessRequester,
        PVStructure pvOption);
    ChannelGet createChannelGet(
        ChannelGetRequester channelGetRequester,
        PVStructure pvRequest);
    ChannelPut createChannelPut(
        ChannelPutRequester channelPutRequester,
        PVStructure pvRequest);
    ChannelPutGet createChannelPutGet(
        ChannelPutGetRequester channelPutGetRequester,
        PVStructure pvRequest);
    ChannelRPC createChannelRPC(
        ChannelRPCRequester channelRPCRequester,
        PVStructure pvRequest);
    ChannelArray createChannelArray(
        ChannelArrayRequester channelArrayRequester,
        PVStructure pvRequest);
    Monitor createMonitor(
        MonitorRequester MonitorRequester,
        PVStructure pvRequest);
}</pre>

<p>where</p>
<dl>
  <dt>getProvider</dt>
    <dd>Get the provider.</dd>
  <dt>getRemoteAddress</dt>
    <dd>Get the network address of the server.</dd>
  <dt>destroy</dt>
    <dd>Destroy the channel and all resources used by the channel.</dd>
  <dt>getChannelName</dt>
    <dd>The name of the channel, e.g. the name if the PVRecord.</dd>
  <dt>getChannelRequester</dt>
    <dd>Get the channel requester. This is normally called by the
      implementation rather than the client.</dd>
  <dt>isConnected</dt>
    <dd>Is the channel connected?</dd>
  <dt>getAccessRights</dt>
    <dd>Get the access rights for the channel.</dd>
</dl>

<p>The remaining methods are described in later sections of this package
overview.</p>

<h3>AccessRights</h3>

<p>Access Rights are not currently implemented.</p>
<pre>enum AccessRights {
    none,
    read,
    readWrite
}</pre>

<h3>GetField</h3>

<p>The method:</p>
<pre>    Channel.getField(GetFieldRequester requester, String subField);</pre>

<p>Gets the introspection interface for the specified sub field of the record
it which the channel is connected. The subField can be null, which means get
the introspection interface for the entire record, or is of the form
"name.name..." . Thus it can be a request for any field within a record. The
requester must implement the interface:</p>
<pre>interface GetFieldRequester extends Requester {
    void getDone(Status status, Field field);
}</pre>

<p>where</p>
<dl>
  <dt>getDone</dt>
    <dd>A getField request has finished. A null is returned if the request
      fails and status contains a reason of a failure. If the request succeeds
      Field is the introspection interface. </dd>
</dl>

<h3>ChannelRequest</h3>

<p>Many of the interfaces described in later sections extend the following
interface.</p>
<pre>interface ChannelRequest extends Destroyable {}</pre>

<p>where Destroyable has the single method:</p>
<dl>
  <dt>destroy</dt>
    <dd>Destroy whatever the extended interface implements. It will free all
      resources it uses.</dd>
</dl>

<p>Many of the interface described in the later sections are created via a
create call that has as one of it's arguments:</p>
<pre>       PVStructure pvRequest</pre>

<p>A request structure is defined in package org.epics.ioc.pvCopy but, for
convenience part is repeated here.</p>

<h4>PVStructure pvRequest</h4>

<p>This is a PVStructure that describes the fields and options in PVRecord that
are to be accessed. The format is defined by org.epics.pvdata.pvCopy. See the
package overview for details.</p>

<h4>CreateRequest</h4>
<p>Many of the Channel methods have an argument <b>PVStructure pvRequest</b>.
CreateRequest is a class that provides methods to create a pvRequest
structure from an ascii string.
CreateRequest has the methods:</p>
<pre>
public class CreateRequest {
    public static CreateRequest create();
    public PVStructure createRequest(String request);
    public String getMessage();
}
</pre>
<p>where</p>
<dl>
  <dt>create</dt>
    <dd>This is a static method that creates an instance of CreateRequest.</dd>
  <dt>createRequest</dt>
    <dd>Each call attempts to create a PVStructure from request.
     If successful then a PVStructure is returned.
     If it fails <b>null</b> is returned and getMessage can be called
     to find the reason for the failure.
     </dd>
  <dt>getMessage</dt>
    <dd>The reason why the last call to createRequest failed.</dd>
</dl>

<p>See the package documentation for
org.epics.iov.pvCopy/package.html for a detailed description. A few examples
are repeated here. </p>

<h4>Examples</h4>

<p>The following examples are for either a simple record or for a power supply
record. These are records that have one of the following structures:</p>
<pre>simpleRecord
    value
    alarm
    timeStamp
    display
    .. other fields like input, etc

powerSupply
    alarm
    timeStamp
    power
       value
       alarm
       .. other fields
    voltage
       value
       alarm
       .. other fields
    current
       value
       alarm
       .. other fields
    .. other fields</pre>

<h5>Simple example</h5>

<p>The following creates a request for three fields: alarm, timeStamp, and
power.value</p>
<pre>
CreateRequest createRequest = CreateRequest.create();
PVStructure pvRequest = createRequest.createRequest("field(alarm,timeStamp,power.value)");
if(pvRequest==null) {
    String message = "createRequest failed " + createRequest.getMessage();
    System.out.println(message);
    // take drastic action
}
</pre>

<p>The PVStructure holding data for the requester will have the structure:</p>
<pre> pvData
     alarm           // from record.alarm
     timeStamp       // from record.timeStamp
     value           // from record.value</pre>

<p>Note that if the actual record does not have a requested field than that
field will not be present in the structure returned to the client.</p>

<h5>Power Supply Example</h5>

<p>The following creates a request for alarm, timeStamp, power, current, and
voltage. Power, current, and voltage will each be a structure with two fields:
value and alarm.</p>
<pre>    PVStructure pvRequest = createRequest.createRequest(
       "field(alarm,timeStamp"
       + ",power{power.value,power.alarm}"
       + ",current{current.value,current.alarm}"
       + ",voltage{voltage.value,voltage.alarm})");</pre>

<p>The resulting structure that appears to the client has the form:</p>
<pre>pvData
   alarm          // from record.alarm
   timeStamp      // from record.timeStamp
   power          // appears because of pvRequest
      value       // from record.power.value
      alarm       // from record.power.alarm
   current        // appears because of pvRequest
      value       // from record.current.value
      alarm       // from record.current.alar.
   voltage        // appears because of pvRequest
      value       // from record.voltage.value
      alarm       // from record.voltage.alarm</pre>

<h3>ChannelProcess</h3>

<p>A ChannelProcess is created via a call to:</p>
<pre>interface Channel extends Requester {
   ChannelProcess createChannelProcess(
       ChannelProcessRequester channelProcessRequester);
}</pre>

<p>The requester must implement the interface:</p>
<pre>interface ChannelProcessRequester extends Requester {
    void channelProcessConnect(Status status, ChannelProcess channelProcess);
    void processDone(Status status);
}</pre>

<p>where</p>
<dl>
  <dt>channelProcessConnect</dt>
    <dd>This returns the interface for requesting that a record be processed.
      Status is the result for the create request. channelProcess is null if
      status is not success.</dd>
  <dt>processDone</dt>
    <dd>This is called when a process request is done. Status is the result for
      the process request. </dd>
</dl>

<p>The following is the interface for requesting that a record be processed.</p>
<pre>interface ChannelProcess extends ChannelRequest {
    void process(boolean lastRequest);
}</pre>

<p>where</p>
<dl>
  <dt>process</dt>
    <dd>Process the record. If lastRequest is true than it is a one time
      request, i.e. it is the same as calling destroy after the process is
      complete. Another process request must not be issued until processDone is
      called.</dd>
</dl>

<h3>ChannelGet</h3>

<p>A ChannelGet is created via a call to:</p>
<pre>interface Channel extends Requester {
    ChannelGet createChannelGet(ChannelGetRequester channelGetRequester, PVStructure pvRequest);
}</pre>

<p>where</p>
<dl>
  <dt>channelGetRequester</dt>
    <dd>Described next.</dd>
  <dt>pvRequest</dt>
    <dd>This was described in a previous section. BUT for channelGet the
      request string for createRequest.createRequest has the form:
      "record[options]field(fieldOptions)". An example of a record options is
      "process=true". The fieldOptions are as defined by pvCopy.</dd>
</dl>

<p>The requester must implement the interface.</p>
<pre>interface ChannelGetRequester extends Requester {
    void channelGetConnect(Status status, ChannelGet channelGet, PVStructure pvStructure, BitSet bitSet);
    void getDone(Status status);
}</pre>

<p>where</p>
<dl>
  <dt>channelGetConnect</dt>
    <dd>This is called if the createProcess fails or when the client request is
      connected to the server. Status provides the result of the createChannel
      request. If status is not success than the other arguments are null.
      channelGet is the interface for requesting gets. All data will be
      returned in pvStructure. bitSet shows which fields have new data. If a
      bit of bitSet is set for a structure field that means that all fields of
      the structure have new values. For example of bit 0 of bitSet is set then
      all fields of pvStructure have new data. Note that each PVField
      implements a method getFieldOffset(). this can be used with bitSet to
      determine which fields have new data values. See BitSet and PVField in
      org.epics.pvdata for details.</dd>
  <dt>getDone</dt>
    <dd>The get request is done. status provides the result of the get request.
      If successful the pvStructure and bitSet returned by the call to
      channelGetConnect contain the data.</dd>
</dl>

<p>The following is the interface for requesting data from a record.</p>
<pre>interface ChannelGet extends ChannelRequest {
    void get(boolean lastRequest);
}</pre>

<p>where</p>
<dl>
  <dt>get</dt>
    <dd>Get data. If lastRequest is true than it is a one time request, i.e. it
      is the same as calling destroy after the get is complete. Another get
      request must not be issued until getDone is called.</dd>
</dl>

<h3>ChannelPut</h3>

<p>A ChannelPut is created via a call to:</p>
<pre>interface Channel extends Requester {
    ChannelPut createChannelPut(ChannelPutRequester channelPutRequester, PVStructure pvRequest);
}</pre>

<p>where</p>
<dl>
  <dt>channelPutRequester</dt>
    <dd>Described next.</dd>
  <dt>pvRequest</dt>
    <dd>This was described in a previous section. BUT for channelPut the
      request string for createRequest.createRequest has the form:
      "record[options]field(fieldOptions)". An example of a record options is
      "process=true". The fieldOptions are as defined by pvCopy.</dd>
</dl>

<p>The requester must implement the interface.</p>
<pre>interface ChannelPutRequester extends Requester {
    void channelPutConnect(Status status, ChannelPut channelPut, PVStructure pvStructure, BitSet bitSet);
    void putDone(Status status);
    void getDone(Status status);
}</pre>

<p>where</p>
<dl>
  <dt>channelPutConnect</dt>
    <dd>This is called if the createChannelPut fails or when the client request
      is connected to the server. Status provides the result of the
      createChannelPut request. If status is not success than the other
      arguments are null. channelPut is the interface for requesting puts and
      gets. The caller puts data into pvStructure pvStructure and sets bits in
      bitSet to shows which fields have new data before making a put request.
      If a bit of bitSet is set for a structure field that means that all
      fields of the structure have new values. For example of bit 0 of bitSet
      is set then all fields of pvStructure have new data. Note that each
      PVField implements a method getFieldOffset(). this can be used with
      bitSet to determine which fields have new data values. See BitSet and
      PVField in org.epics.pvdata for details.</dd>
  <dt>putDone</dt>
    <dd>The put request is done. status provides the result of the put request.
    </dd>
  <dt>getDone</dt>
    <dd>The get request is done. status provides the result of the put request.
    </dd>
</dl>

<p>The following is the interface for requesting data from a record.</p>
<pre>interface ChannelPut extends ChannelRequest {
    void put(boolean lastRequest);
    void get();
}</pre>

<p>where</p>
<dl>
  <dt>put</dt>
    <dd>Put data. If lastRequest is true than it is a one time request, i.e. it
      is the same as calling destroy after the put is complete.</dd>
  <dt>get</dt>
    <dd>Get the current data from the record. The record is never processed.
      The request just gets the current values which is put into the
      pvStructure returned in the call to channelPutConnect.</dd>
  <dt>NOTE: Only one of put and get can be outstanding at the same time.
  Another get or put must not be issued until getDone or putDone is called.</dt>
</dl>

<h3>ChannelPutGet</h3>

<p>A channelPutGet request puts data into a record, optionally processes the
record, and gets data from the record.</p>

<p>A channel putGet is created via a call to:</p>
<pre>interface Channel extends Requester {
    ChannelPutGet createChannelPutGet(ChannelPutGetRequester channelPutGetRequester, PVStructure pvRequest);
}</pre>

<p>where</p>
<dl>
  <dt>channelPutGetRequester</dt>
    <dd>Described next.</dd>
  <dt>pvPutRequest</dt>
    <dd>This was described in a previous section. BUT for channelPutGet the
      request string for createRequest.createRequest has the form:
      "record[process=true]putField(fieldOptions)getField(fieldOptions)". An
      example of a record options is "process=true". The fieldOptions are as
      defined by pvCopy.</dd>
</dl>

<p>The requester must implement the interface.</p>
<pre>interface ChannelPutGetRequester extends Requester {
    void channelPutGetConnect(Status status, ChannelPutGet channelPutGet,
            PVStructure pvPutStructure, PVStructure pvGetStructure);
    void putGetDone(Status status);
    void getPutDone(Status status);
    void getGetDone(Status status);
}</pre>

<p>where</p>
<dl>
  <dt>channelPutGetConnect</dt>
    <dd>This is called if the createChannelPutGet fails or when the client
      request is connected to the server. Status provides the result of the
      createChannelPutGet request. If status is not success than the other
      arguments are null. channelPutGet is the interface for requesting putGet,
      getPut and getGet. pvPutStructure holds the put data and pvGetStructure
      holds the get data. </dd>
  <dt>putGetDone</dt>
    <dd>The putGet request is done.</dd>
  <dt>getPutDone</dt>
    <dd>The getPut request is done.</dd>
  <dt>getGetDone</dt>
    <dd>The getGet request is done.</dd>
</dl>

<p>The following is the interface for requesting data from a record.</p>
<pre>interface ChannelPutGet extends ChannelRequest {
    void putGet(boolean lastRequest);
    void getPut();
    void getGet();
}</pre>

<p>where</p>
<dl>
  <dt>putGet</dt>
    <dd>First put the pvPutStructure data into the record. Then if process is
      true process the record. Finally get data from the record and put it into
      pvGetStructure. If lastRequest is true than it is a one time request,
      i.e. it is the same as calling destroy after the putGet is complete.</dd>
  <dt>getPut</dt>
    <dd>Get current data from the record and put it into pvPutStructure. The
      record is never processed. The request just gets the current values which
      is put into the pvPutStructure returned in the call to
      channelPutGetConnect.</dd>
  <dt>getGet</dt>
    <dd>Get current data from the record and put it into pvGetStructure. The
      record is never processed. The request just gets the current values which
      is put into the pvGetStructure returned in the call to
      channelPutGetConnect.</dd>
</dl>

<p>NOTE: Only one of putGet, getPut, or getGet can be outstanding at the same
time. Another request must not be issued until the appropriate xxxDone is
called.</p>

<h3>ChannelRPC</h3>

<p>A ChannelRPC is like a putProcessGet except that a completly different
PVStructure can be returned for each request. It is created via a call to:</p>
<pre>interface Channel extends Requester {
    ChannelRPC createChannelRPC(ChannelRPCRequester channelRPCRequester, PVStructure pvRequest);
}</pre>

<p>where</p>
<dl>
  <dt>channelRPCRequester</dt>
    <dd>Described next.</dd>
  <dt>pvRequest</dt>
    <dd>This was described in a previous section. BUT for channelRPC the
      request string for createRequest.createRequest has the form:
      "record[options]field(fieldOptions)". Normally no record options are
      entered. The fieldOptions are as defined by pvCopy.</dd>
</dl>

<p>The requester must implement the interface.</p>
<pre>interface ChannelRPCRequester extends Requester {
    void channelRPCConnect(Status status, ChannelRPC channelRPC);
    void requestDone(Status status, PVStructure pvResponse);
}</pre>

<p>where</p>
<dl>
  <dt>channelRPCConnect</dt>
    <dd>Status provides the result of the createChannelRPC request. If status
      is not success than the other argument is null.</dd>
  <dt>requestDone</dt>
    <dd>The request is done. status provides the result of the request. If
      successful a pvResponse is returned. </dd>
</dl>

<p>The following is the interface for requesting data from a record.</p>
<pre>interface ChannelRPC extends ChannelRequest {
    void request(PVStructure pvArgument, boolean lastRequest);
}</pre>

<p>where</p>
<dl>
  <dt>request</dt>
    <dd>pvArgument is the structure that is sent to the server. If lastRequest
      is true than it is a one time request, i.e. Send it is the same as
      calling destroy after the request is complete.</dd>
</dl>

<p>Only one request at a time can outstanding (this will be allowed in a
future).</p>

<h3>ChannelArray</h3>

<p>ChannelArray provides the ability to read or write a sub-array of an array
field in a record. Note that all the other transfer methods can also read or
write arrays but always transfer entire arrays. ChannelArray provides the
ability to transfer a subarray. A ChannelArray is created via a call to:</p>
<pre>interface Channel extends Requester {
    ChannelArray createChannelArray(
        ChannelArrayRequester channelArrayRequester,
        PVStructure pvRequest);
}</pre>

<p>where</p>
<dl>
  <dt>channelArrayRequester</dt>
    <dd>Described next.</dd>
  <dt>pvRequest</dt>
    <dd>This must be a PVStructure created as follows:
      <pre>
CreateRequest createRequest = CreateRequest.create();
PVStructure pvRequest = createRequest.createRequest(subField);
if(pvRequest==null) {
    String message = createRequest.getMessage();
    // take drastic action
}
    </pre>
    </dd>
</dl>

<p>The requester must implement the interface.</p>
<pre>interface ChannelArrayRequester extends Requester {
    void channelArrayConnect(Status status, ChannelArray channelArray, PVArray pvArray);
    void putArrayDone(Status status);
    void getArrayDone(Status status);
}</pre>

<p>where</p>
<dl>
  <dt>channelArrayConnect</dt>
    <dd>This is called if the createChannelArray fails or when the client
      request is connected to the server. Status provides the result of the
      createChannelArray request. If status is not success than the other
      arguments are null. channelArray is the interface for requesting puts and
      gets. pvArray holds the data to put or get.</dd>
  <dt>putArrayDone</dt>
    <dd>The put request is done.</dd>
  <dt>getArrayDone</dt>
    <dd>The get request is done.</dd>
</dl>

<p>The following is the interface for getting or putting array data from a
record.</p>
<pre>interface ChannelArray extends ChannelRequest{
    void putArray(boolean lastRequest, int offset, int count);
    void getArray(boolean lastRequest, int offset, int count);
}</pre>

<p>where</p>
<dl>
  <dt>putArray</dt>
    <dd>Put array data. The offset is the offset in the server and the count is
      the total number of elements to write. If lastRequest is true than it is
      a one time request, i.e. it is the same as calling destroy after the put
      is complete.</dd>
  <dt>getArray</dt>
    <dd>Get array data. The offset is the offset in the server and the count is
      the total number of elements to read. If lastRequest is true than it is a
      one time request, i.e. it is the same as calling destroy after the get is
      complete.</dd>
</dl>

<h3>Monitor</h3>

<p>Monitor provides the abiliy to set monitors on data in a PVRecord. What
triggers a monitor depends on the monitor support in the server. The standard
server provides support for the following: onPut, onChange, onAbsoluteChange,
and onPercentChange.</p>

<p>A Monitor is created via a call to:</p>
<pre>    void createMonitor(
        MonitorRequester monitorRequester,
        PVStructure pvRequest);
}</pre>

<p>where</p>
<dl>
  <dt>monitorRequester</dt>
    <dd>Described next.</dd>
  <dt>pvRequest</dt>
    <dd>This is defined by pvCopy and pvMonitor. See their package overviews
      for details (org.epics.pvdata.pvCopy and org.epics.pvdata.pvMonitor). The
      format of the request for CreateRequest.createRequest has the form
      "record[options]field(fieldOptions)". Note that you can specify monitor
      options for individual fields. See the package overview for pvMonitor for
      details.</dd>
</dl>

<p>The requester must implement the interface.</p>
<pre>interface MonitorRequester extends Requester{
    void monitorConnect(Status status, Monitor monitor, Structure structure));
    void monitorEvent((Monitor monitor);
    void unlisten();
}</pre>

<p>where</p>
<dl>
  <dt>monitorConnect</dt>
    <dd>This is called if the createMonitor fails or when the client request is
      connected to the server.
       <dl>
           <dt>status</dt>
             <dd>The result of the createMonitor request.
                If status is not success than the other arguments are null.
             </dd>
           <dt>monitor</dt>
               <dd>The interface for the Monitor.</dd>
           <dt>structure</dt>
               <dd>The introspection interface for the data that will
                be returned for each monitor event.</dd>
        </dl>
    </dd>
  <dt>monitorEvent</dt>
    <dd>monitorEvent is called when a monitor occurs. The client must call
      monitor.poll to get data for the monitor. See below. </dd>
  <dt>unlisten</dt>
    <dd>The server has issued an unlisten request.</dd>
</dl>

<p>The following is the Monitor interface which is defined in project pvData</p>
<pre>interface Monitor extends Destroyable {
    Status start();
    Status stop();
    MonitorElement poll();
    void release(MonitorElement monitorElement);
}</pre>

<p>where</p>
<dl>
  <dt>start</dt>
    <dd>Start monitoring</dd>
  <dt>stop</dt>
    <dd>Stop monitoring</dd>
  <dt>poll</dt>
    <dd>Poll for monitor event. Null is returned when no more events are
      available. The client must call this method in order to get monitor
    data.</dd>
  <dt>release</dt>
    <dd>When the client has processed the monitor event returned by poll the
      client must call release before again calling poll.</dd>
</dl>

<p>A monitorElement is defined as:</p>
<pre>interface MonitorElement {
    PVStructure getPVStructure();
    BitSet getChangedBitSet();
    BitSet getOverrunBitSet();
}</pre>

<p>where</p>
<dl>
  <dt>getPVStructure</dt>
    <dd>The data structure.</dd>
  <dt>getChangedBitSet</dt>
    <dd>A bitset which has a bit set for each field of the data structure which
      has changed since the last monitor.</dd>
  <dt>getOverrunBitSet</dt>
    <dd>A bitset which has a bit set for each field of the data structure which
      has changed more than once since the last monitor.</dd>
</dl>

<h2>Package org.epics.pvaccess.server</h2>

<h3>Overview</h3>

<p>This package defines the server interfaces for pvAccess, which is the
version of channel access that fully supports structured data as defined by
PVData.
<h3>Server Context</h3>

<p>This is an interface implemented by pvAccess server:</p>
<pre>interface ServerContext {
    Version getVersion();
    void initialize(ChannelAccess channelAccess) throws CAException, IllegalStateException;
    void run(int seconds) throws CAException, IllegalStateException;
    void shutdown() throws CAException, IllegalStateException;
    void destroy() throws CAException, IllegalStateException;
    void printInfo();
    void printInfo(PrintStream out);
    void dispose();
    void setBeaconServerStatusProvider(BeaconServerStatusProvider beaconServerStatusProvider);
}</pre>
</p>

<p>where</p>
<dl>
  <dt>getVersion</dt>
    <dd>Get server implementation version.</dd>
  <dt>initialize</dt>
    <dd>Force to initialize server immediately (user does not need to call this).</dd>
  <dt>run</dt>
    <dd>Run the server for specified amount of time (seconds), 0 stands for forever.</dd>
  <dt>shutdown</dt>
    <dd>Shutdown the server.</dd>
  <dt>destroy</dt>
    <dd>Destroy server instance.</dd>
  <dt>printInfo</dt>
    <dd>Print server info to the System.out.</dd>
  <dt>dispose</dt>
    <dd>Silently destroy the server instance.</dd>
  <dt>setBeaconServerStatusProvider</dt>
    <dd>Set BeaconServerStatusProvider instance to be used by the server (optional).</dd>
</dl>
<p>
To start pvAccess server you can simply use the following code:
</p>
<pre>org.epics.pvaccess.ServerFactory.start();</pre>
</div>
</body>
</html>
