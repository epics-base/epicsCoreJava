/*
 * Copyright - See the COPYRIGHT that is included with this distribution.
 * EPICS pvData is distributed subject to a Software License Agreement found
 * in file LICENSE that is included with this distribution.
 */
package org.epics.pvaccess.impl.remote.test;

import junit.framework.TestCase;
import org.epics.pvaccess.PVFactory;
import org.epics.pvaccess.impl.remote.IntrospectionRegistry;
import org.epics.pvaccess.util.BooleanHolder;
import org.epics.pvdata.factory.FieldFactory;
import org.epics.pvdata.pv.*;

import java.nio.ByteBuffer;


/**
 * JUnit test for IR supported serialization.
 * @author mse
 *
 */
public class IRSerializationTest extends TestCase {

	private static class IRControl implements SerializableControl, DeserializableControl {
		/**
		 * Incoming (codes generated by other party) introspection registry.
		 */
		protected final IntrospectionRegistry incomingIR = new IntrospectionRegistry();

		/**
		 * Outgoing (codes generated by this party) introspection registry.
		 */
		protected final IntrospectionRegistry outgoingIR = new IntrospectionRegistry();

		public Field cachedDeserialize(ByteBuffer buffer) {
			return incomingIR.deserialize(buffer, this);
		}

		public void cachedSerialize(Field field, ByteBuffer buffer) {
			outgoingIR.serialize(field, buffer, this);
		}

		public void ensureData(int size) {
			// TODO Auto-generated method stub

		}

		public void alignData(int alignment) {
			// TODO Auto-generated method stub

		}

		public void flushSerializeBuffer() {
			// TODO Auto-generated method stub

		}

		public void ensureBuffer(int size) {
			// TODO Auto-generated method stub

		}

		public void alignBuffer(int alignment) {
			// TODO Auto-generated method stub

		}
	}

	final String decode = "fd:01:00:80:00:03:06:72:65:63:6f:72:64:fd:02:00:80:00:01:08:5f:6f:70:74:69:6f:6e:73:fd:03:00:80:00:02:09:71:75:65:75:65:53:69:7a:65:26:06:61:74:6f:6d:69:63:00:01:61:fd:04:00:80:15:65:70:69:63:73:3a:6e:74:2f:4e:54:53:63:61:6c:61:72:3a:31:2e:30:05:05:76:61:6c:75:65:43:05:61:6c:61:72:6d:fd:05:00:80:07:61:6c:61:72:6d:5f:74:03:08:73:65:76:65:72:69:74:79:22:06:73:74:61:74:75:73:22:07:6d:65:73:73:61:67:65:60:09:74:69:6d:65:53:74:61:6d:70:fd:06:00:80:06:74:69:6d:65:5f:74:03:10:73:65:63:6f:6e:64:73:50:61:73:74:45:70:6f:63:68:23:0b:6e:61:6e:6f:73:65:63:6f:6e:64:73:22:07:75:73:65:72:54:61:67:22:07:64:69:73:70:6c:61:79:fd:07:00:80:09:64:69:73:70:6c:61:79:5f:74:05:08:6c:69:6d:69:74:4c:6f:77:43:09:6c:69:6d:69:74:48:69:67:68:43:0b:64:65:73:63:72:69:70:74:69:6f:6e:60:06:66:6f:72:6d:61:74:60:05:75:6e:69:74:73:60:07:63:6f:6e:74:72:6f:6c:fd:08:00:80:09:63:6f:6e:74:72:6f:6c:5f:74:03:08:6c:69:6d:69:74:4c:6f:77:43:09:6c:69:6d:69:74:48:69:67:68:43:07:6d:69:6e:53:74:65:70:43:01:62:fe:04:00";
	final String decodeData = "06:41:33:d3:34:33:0d:00:00:00:00:01:00:00:00:00:00:80:4f:40:00:00:00:00:00:00:00:00:00:6d:0d:f4:56:00:00:00:00:5a:d4:7a:08:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:80:84:2e:41:00:00:04:61:72:62:2e:00:00:00:00:00:00:00:00:00:00:00:00:80:84:2e:41:00:00:00:00:00:00:00:00:00:00:00:00:00:80:4f:40:00:00:00:00:00:00:00:00:00:6d:0d:f4:56:00:00:00:00:5a:d4:7a:08:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:88:c3:40:00:00:04:61:72:62:2e:00:00:00:00:00:00:00:00:00:00:00:00:00:88:c3:40:00:00:00:00:00:00:00:00";

	public void testDecode()
	{
		ByteBuffer buffer = ByteBuffer.allocate(1 << 16);
		String[] sbytes = decode.split(":");
		for (String sb : sbytes)
			buffer.put((byte)Integer.parseInt(sb, 16));
		buffer.flip();

		IRControl ic = new IRControl();
		Field field = ic.cachedDeserialize(buffer);
		System.out.println(field);



		ByteBuffer databuffer = ByteBuffer.allocate(1 << 16);
		sbytes = decodeData.split(":");
		for (String sb : sbytes)
			databuffer.put((byte)Integer.parseInt(sb, 16));
		databuffer.flip();


		PVField pvField = PVFactory.getPVDataCreate().createPVField(field);
		((PVStructure)pvField).getPVFields()[2].deserialize(databuffer, ic);
		System.out.println(pvField);
	}

	public void testRegisterIntrospectionInterface() {

		IntrospectionRegistry introspectionRegistry =
				new IntrospectionRegistry();

		Field field1 = FieldFactory.getFieldCreate().createScalar(ScalarType.pvDouble);

		BooleanHolder existing = new BooleanHolder(true);

		short key = introspectionRegistry.registerIntrospectionInterface(field1, existing);

		assertEquals(1, key);
		assertFalse(existing.value);

	}

}
